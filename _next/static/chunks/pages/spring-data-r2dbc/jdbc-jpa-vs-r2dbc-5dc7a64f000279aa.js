(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[596],{532:function(e,a,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/spring-data-r2dbc/jdbc-jpa-vs-r2dbc",function(){return t(3822)}])},3822:function(e,a,t){"use strict";t.r(a),t.d(a,{__toc:function(){return g},default:function(){return l}});var n=t(5893),r=t(2673),i=t(373),d=t(8426);t(9128);var o=t(2643),s={src:"/docs-spring-data-reactive/_next/static/media/jdbc.3cf4e96a.png",height:493,width:484,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAICAAAAADhZOFXAAAAOUlEQVR42g3LwQ3AMBACMPYftwcJgVRq/TfODZUeLG/RXvC2OjJEPkMJvl1sjbelmouTzCT/asR0f7LYPeYmbWKZAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:8},c={src:"/docs-spring-data-reactive/_next/static/media/r2dbc-io.94aeb551.png",height:1121,width:1196,blurDataURL:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAgAAAAHCAIAAAC6O5sJAAAAbElEQVR42j2MWQrDMAwFNdIzhvT+xyyF/qRZbFUkkIERaHu8P19whcYYM2emNbmqb1r23zhOIEoHSy81B9thChwKM84SE0yp3u9pkaV7KmJ7LfQekM+uEMS67nUEBrh7RBUE1lr0rsw7B7v4A0gGJmU1Lp9pAAAAAElFTkSuQmCC",blurWidth:8,blurHeight:7};let g=[{depth:2,value:"JDBC, JPA 와의 차이점",id:"jdbc-jpa-와의-차이점"},{depth:2,value:"JDBC 기반의 JPA",id:"jdbc-기반의-jpa"},{depth:2,value:"R2DBC",id:"r2dbc"}];function _createMdxContent(e){let a=Object.assign({h2:"h2",p:"p",img:"img",blockquote:"blockquote",ul:"ul",li:"li",a:"a",strong:"strong"},(0,o.a)(),e.components);return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(a.h2,{id:"jdbc-jpa-와의-차이점",children:"JDBC, JPA 와의 차이점"}),"\n",(0,n.jsx)(a.h2,{id:"jdbc-기반의-jpa",children:"JDBC 기반의 JPA"}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{placeholder:"blur",src:s})}),"\n",(0,n.jsxs)(a.p,{children:["JDBC, JPA 는 블로킹 기반의 동기(Synchrnoization) 방식의 I/O 연산을 수행합니다. 데이터베이스에 접근해서 커넥션을 획득하고, CRUD 를 수행하기 위해서는 TCP 통신을 수행해야 하는데, JPA 는 JDBC 를 기반으로 이루어져있고 JDBC 는 TCP 통신을 블로킹 기반의 동기(Synchronization)방식으로 수행합니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["JDBC 는 굉장히 오래된 라이브러리입니다. AIO와 같은 Java 1.8 이후의 TCP 소켓 통신 스펙(비동기 논블로킹 네트워킹)이 적용되기에는 무리가 있는 라이브러리입니다. ",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.blockquote,{children:["\n",(0,n.jsx)(a.p,{children:"참고 : 블로킹, 논블로킹, 동기, 비동기에 대한 개념은 아래 문서를 참고해주세요."}),"\n",(0,n.jsxs)(a.ul,{children:["\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.a,{href:"https://chagchagchag.github.io/docs-spring-webflux/concurrent-programming-basic/sync-vs-async/",children:"동기 vs 비동기"})}),"\n"]}),"\n",(0,n.jsxs)(a.li,{children:["\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.a,{href:"https://chagchagchag.github.io/docs-spring-webflux/concurrent-programming-basic/blocking-vs-nonblocking/",children:"블로킹 vs 논블로킹"})}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsxs)(a.p,{children:["현재 가장 안정적인 Java LTS 버전은 Java 17 입니다. 그리고 Java 21 이 새로운 LTS 로 떠올랐습니다. JDK1.5 이전부터 작성되었을 JDBC 라이브러리는 더 이상 모던한 애플리케이션에 적합하지 않을지도 모릅니다. 네트워킹을 위한 비동기 논블로킹 TCP 통신 역시 JAVA 8 이후에 도입된 점을 보면, 블로킹 기반의 동기연산을 하는 네트워크 통신을 하는 JDBC는 굉장히 오래되었으며, 최신 모바일 환경에 대응하기에 어려움이 많은 데이터 접근 레이어가 아니지 않나 싶습니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.strong,{children:"JPA 의 더티체킹"}),(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["JPA 에서 흔히 이야기하는 Write Behind, 변경감지 개념은 r2dbc 환경에서 큰 장점이 되지 못합니다. Write Behind 를 한다는 이야기는 엔티티 캐시를 내부에 보관하고 있는다는 의미이고 다른말로 이야기하면 Mutable 하다는 이야기입니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["JPA 에서는 객체의 스냅샷 등을 통해 변경감지를 하는 등의 연산을 통해 엔티티의 변경을 감지하지만, R2DBC 로 넘어오면서 개별 데이터의 흐름을 Immutable 하게 처리하는 R2dbc 에서는 JPA 의 변경감지 기능이 더 이상 필요가 없어졌습니다. 다중 트랜잭션, 분산 트랜잭션 환경을 겪어본다면 더티체킹 개념보다는 이벤트의 트랜잭셔널함에 더 집중을 하게 됩니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["따라서 Jpa 의 더티체킹이 R2dbc 에서 지원이 안된다는 점에 실망하지 않으셔도 될 것 같습니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsx)("br",{}),"\n",(0,n.jsx)(a.h2,{id:"r2dbc",children:"R2DBC"}),"\n",(0,n.jsxs)(a.blockquote,{children:["\n",(0,n.jsxs)(a.p,{children:["참고 : ",(0,n.jsx)(a.a,{href:"https://r2dbc.io/",children:"R2DBC (Reactive Relational Database Connectivity)"}),(0,n.jsx)("br",{})]}),"\n"]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{src:"https://r2dbc.io/images/PVLG-R2DBC-Logo-RGB.png",alt:""})}),"\n",(0,n.jsxs)(a.blockquote,{children:["\n",(0,n.jsxs)(a.p,{children:["이미지 출처 : ",(0,n.jsx)(a.a,{href:"https://r2dbc.io/",children:"https://r2dbc.io/"})]}),"\n"]}),"\n",(0,n.jsxs)(a.p,{children:["JDBC 는 데이터베이스와 통신을 하는 데에 있어서 동기적이고 블로킹 기반의 통신을 하기 때문에 대규모의 트래픽을 처리하기에 어려움이 많습니다. 반면 R2DBC 는 비동기 논블로킹 네트워크 통신 기반으로 동작하기 때문에 데이터베이스 IO 작업 수행시 애플리케이션의 응답성을 향상시키고, 동시성을 증가시키며, 리액티브 스트림 기반의 연산을 수행하기 때문에 데이터베이스의 변경 사항을 실시간으로 감지하고 처리할 수 있다는 것 역시 장점입니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:["R2DBC 는 여러 기업과 개발자 커뮤니티에 의해 공동으로 개발되고 유지보수 되어온 오픈소스 프로젝트이며, R2DBC의 주요 컨트리뷰터는 Pivotal 의 개발자들이 대 다수입니다.",(0,n.jsx)("br",{})]}),"\n",(0,n.jsxs)(a.p,{children:[(0,n.jsx)(a.a,{href:"https://r2dbc.io",children:"https://r2dbc.io"})," 에서는 아래와 같은 다양한 정보들을 제공하고 있기 때문에 가급적이면 꼭 방문해서 세부적인 내용들을 읽어보시기 바랍니다. 요즘 구글 크롬의 번역기 성능도 좋으니 꼭 번역기를 이용해서 한번씩은 읽어보시길 추천드립니다."]}),"\n",(0,n.jsx)(a.p,{children:(0,n.jsx)(a.img,{placeholder:"blur",src:c})}),"\n",(0,n.jsx)("br",{})]})}let p={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:a}=Object.assign({},(0,o.a)(),e.components);return a?(0,n.jsx)(a,{...e,children:(0,n.jsx)(_createMdxContent,{...e})}):_createMdxContent(e)},pageOpts:{filePath:"pages/spring-data-r2dbc/jdbc-jpa-vs-r2dbc.mdx",route:"/spring-data-r2dbc/jdbc-jpa-vs-r2dbc",timestamp:1711961124e3,pageMap:[{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"spring-data-mongodb-reactive",route:"/spring-data-mongodb-reactive",children:[{kind:"MdxPage",name:"aggregation-pipeline",route:"/spring-data-mongodb-reactive/aggregation-pipeline"},{kind:"MdxPage",name:"document-bson-bson-codec",route:"/spring-data-mongodb-reactive/document-bson-bson-codec"},{kind:"MdxPage",name:"entity",route:"/spring-data-mongodb-reactive/entity"},{kind:"MdxPage",name:"mongo-collection-functions",route:"/spring-data-mongodb-reactive/mongo-collection-functions"},{kind:"MdxPage",name:"mongodb-features",route:"/spring-data-mongodb-reactive/mongodb-features"},{kind:"MdxPage",name:"mongodb-reactive-streams-driver",route:"/spring-data-mongodb-reactive/mongodb-reactive-streams-driver"},{kind:"MdxPage",name:"mongodb-tools",route:"/spring-data-mongodb-reactive/mongodb-tools"},{kind:"MdxPage",name:"query-methods",route:"/spring-data-mongodb-reactive/query-methods"},{kind:"MdxPage",name:"reactive-mongo-operation",route:"/spring-data-mongodb-reactive/reactive-mongo-operation"},{kind:"MdxPage",name:"reactive-mongo-repository",route:"/spring-data-mongodb-reactive/reactive-mongo-repository"},{kind:"MdxPage",name:"reactive-mongo-template",route:"/spring-data-mongodb-reactive/reactive-mongo-template"},{kind:"MdxPage",name:"spring-data-object-mapping-and-creation",route:"/spring-data-mongodb-reactive/spring-data-object-mapping-and-creation"},{kind:"MdxPage",name:"transactional-transactional-operator",route:"/spring-data-mongodb-reactive/transactional-transactional-operator"},{kind:"Meta",data:{"mongodb-features":"MongoDB Features","mongodb-tools":"MongoDB 접근 도구들","mongodb-reactive-streams-driver":"MongoDB Reactive Streams Driver","mongo-collection-functions":"MongoCollection 의 다양한 연산들","document-bson-bson-codec":"Document, BSON, BSON Codec",entity:"Entity","spring-data-object-mapping-and-creation":"Spring Data Reactive 의 객채생성 방식과 매핑방식","reactive-mongo-template":"ReactiveMongoTemplate","reactive-mongo-operation":"ReactiveMongoOperation","reactive-mongo-repository":"ReactiveMongoRepository","query-methods":"Query 메서드","aggregation-pipeline":"Aggregation Pipeline","transactional-transactional-operator":"@Transactional, TransactionalOperator"}}]},{kind:"MdxPage",name:"spring-data-mongodb-reactive",route:"/spring-data-mongodb-reactive"},{kind:"Folder",name:"spring-data-r2dbc",route:"/spring-data-r2dbc",children:[{kind:"MdxPage",name:"entity-mysql-type-mapping",route:"/spring-data-r2dbc/entity-mysql-type-mapping"},{kind:"MdxPage",name:"example-mysql-docker-container",route:"/spring-data-r2dbc/example-mysql-docker-container"},{kind:"MdxPage",name:"jdbc-jpa-vs-r2dbc",route:"/spring-data-r2dbc/jdbc-jpa-vs-r2dbc"},{kind:"MdxPage",name:"mysql-features",route:"/spring-data-r2dbc/mysql-features"},{kind:"MdxPage",name:"query-methods",route:"/spring-data-r2dbc/query-methods"},{kind:"MdxPage",name:"r2dbc-drivers-r2dbc-spi",route:"/spring-data-r2dbc/r2dbc-drivers-r2dbc-spi"},{kind:"MdxPage",name:"r2dbc-entity-template-r2dbc-entity-operations",route:"/spring-data-r2dbc/r2dbc-entity-template-r2dbc-entity-operations"},{kind:"MdxPage",name:"r2dbc-h2-settings",route:"/spring-data-r2dbc/r2dbc-h2-settings"},{kind:"MdxPage",name:"r2dbc-repository",route:"/spring-data-r2dbc/r2dbc-repository"},{kind:"MdxPage",name:"simple-r2dbc-code",route:"/spring-data-r2dbc/simple-r2dbc-code"},{kind:"MdxPage",name:"spring-data-object-mapping-and-creation",route:"/spring-data-r2dbc/spring-data-object-mapping-and-creation"},{kind:"MdxPage",name:"transactional-transactional-operator",route:"/spring-data-r2dbc/transactional-transactional-operator"},{kind:"Meta",data:{"mysql-features":"MySQL 특징","jdbc-jpa-vs-r2dbc":"JDBC, JPA 와의 차이점","r2dbc-drivers-r2dbc-spi":"R2DBC 드라이버, R2DBC SPI, Connection 설정","r2dbc-h2-setting":"R2DBC 에서의 h2 설정","simple-r2dbc-code":"R2DBC 기반 Raw 레벨 코드, Transaction","entity-mysql-type-mapping":"Entity, MySQL 타입 매핑","spring-data-object-mapping-and-creation":"Spring Data Reactive 의 객체생성 방식과 필드 매핑방식","r2dbc-repository":"R2dbcRepository","query-methods":"Query Methods","transactional-transactional-operator":"@Transactional, TransactionalOperator","r2dbc-entity-template-r2dbc-entity-operations":"R2dbcEntityTemplate, R2dbcEntityOperations, FluentR2dbcOperations","example-mysql-docker-container":"예제 용도의 MySQL Docker Container","r2dbc-h2-settings":"R2dbc H2 Settings"}}]},{kind:"MdxPage",name:"spring-data-r2dbc",route:"/spring-data-r2dbc"},{kind:"Folder",name:"spring-data-redis-reactive",route:"/spring-data-redis-reactive",children:[{kind:"MdxPage",name:"known-cache-strategies",route:"/spring-data-redis-reactive/known-cache-strategies"},{kind:"MdxPage",name:"luttuce-examples",route:"/spring-data-redis-reactive/luttuce-examples"},{kind:"MdxPage",name:"redis-connector",route:"/spring-data-redis-reactive/redis-connector"},{kind:"MdxPage",name:"redis-data-structures",route:"/spring-data-redis-reactive/redis-data-structures"},{kind:"MdxPage",name:"redis-replication-sentinel-cluster",route:"/spring-data-redis-reactive/redis-replication-sentinel-cluster"},{kind:"MdxPage",name:"spring-data-redis-reactive-redis-operations",route:"/spring-data-redis-reactive/spring-data-redis-reactive-redis-operations"},{kind:"Meta",data:{"redis-replication-sentinel-cluster":"Redis Replication,Sentinel, Cluster","redis-connector":"Redis Connector (Lettuce, Jedis)","redis-data-structures":"레디스 자료구조들","luttuce-examples":"luttuce 기반 예제 코드들","spring-data-redis-reactive-redis-operations":"Spring Data Redis Reactive, RedisOperations","known-cache-strategies":"캐싱전략의 종류"}}]},{kind:"MdxPage",name:"spring-data-redis-reactive",route:"/spring-data-redis-reactive"},{kind:"Meta",data:{index:"Introduction","spring-data-r2dbc":"Spring Data R2dbc","spring-data-mongodb-reactive":"Spring Data MongoDB Reactive","spring-data-redis-reactive":"Spring Data Redis Reactive",contact:{title:"Contact ↗",type:"page",href:"-",newWindow:!0}}}],flexsearch:{codeblocks:!0},title:"Jdbc Jpa Vs R2dbc",headings:g},pageNextRoute:"/spring-data-r2dbc/jdbc-jpa-vs-r2dbc",nextraLayout:i.ZP,themeConfig:d.Z};var l=(0,r.j)(p)},8426:function(e,a,t){"use strict";var n=t(5893);t(7294);let r={logo:(0,n.jsx)("span",{children:"Docs Spring Data Reactive"}),project:{link:"https://github.com/chagchagchag/docs-spring-data-reactive"},docsRepositoryBase:"https://github.com/chagchagchag/docs-spring-data-reactive",footer:{text:"Nextra Docs Template"}};a.Z=r},5789:function(){}},function(e){e.O(0,[774,796,888,179],function(){return e(e.s=532)}),_N_E=e.O()}]);