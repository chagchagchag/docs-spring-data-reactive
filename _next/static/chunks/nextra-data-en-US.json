{"/spring-data-mongodb-reactive":{"title":"Spring Data Mongodb Reactive","data":{"spring-data-mongodb-reactive#Spring Data MongoDB Reactive":""}},"/":{"title":"Introduction","data":{"":"Spring Data Reactive 문서보관소입니다."}},"/spring-data-mongodb-reactive/mongodb-features":{"title":"Mongodb Features","data":{"mongodb-features#MongoDB Features":"","mongo-db#Mongo DB":"MongoDB 는 오픈소스 NoSQL 데이터베이스입니다. 2007 년 10gen 이라는 회사에서 Paas 로 MongoDB 개발을 시작했고, 2009 년에 오픈소스 모델로 전환해서 사용지원, 기타 서비스를 제공하는 방식을 따르게 되었습니다. 2013년에는 10gen 이라는 회사 명이 MongoDB Inc. 로 변경되었으며 현재 전 세계에서 대중적으로 알려진 NoSQL 데이터베이스가 되었습니다.스키마가 정의되어 있지 않아도 데이터 저장을 유연하게 할 수 있습니다. 또한 다양한 종류의 index를 지원하고, 4.0 부터 multi docoument transaction 을 지원하기에 트랜잭션의 ACID 가 보장됩니다.몽고DB를 운영할 때 레플리카셋과 샤드 클러스터를 적용하면 데이터를 여러 노드에 분산해서 저장하고 처리하는 것이 가능해지며, 장애에 내성이 강한 데이터베이스로 전환이 가능합니다.","mongodb-bson#MongoDB BSON":"Binary 형식의 JSON 데이터를 BSON 이라고 부릅니다. MongoDB는 데이터를 BSON 형식으로 저장합니다.BSON 은 JSON 보다 인코딩/디코딩이 빠르고, 다양한 데이터 타입들이 BSON 에 지원됩니다.\ndocument id : ObjectId\n바이너리 데이터 : BinData\n날짜 : Date, ISODate\n정규표현식\nBSON 타입에 대한 자세한 내용은 아래의 링크들에서 자세히 확인 가능합니다.bsonspec.org\nbsonspec.org\nbsonspec.org/implementation.html\nMongodb.com\nWhat is BSON?\nHow is BSON different from JSON?\nAdvantages of BSON\nHow to convert JSON to BSON\nImport and export BSON documents\nBSON Document Example","mongodb-bson-인코딩#MongoDB BSON 인코딩":"BSON 은 필드의 순서에 따라서 인코딩이 달라지며, 첫줄은 document 의 크기를 의미합니다.\nbson converter 는 https://onlinejsontools.com/convert-json-to-bson 을 사용했습니다.","mongodb-document-collection-database#MongoDB Document, Collection, Database":"TODO : 그림 추가","mongodb-트랜잭션#MongoDB 트랜잭션":"4.0 버전 이후부터는 multi-document 트랜잭션 ACID 를 지원하기 시작했습니다.레플리카셋과 샤드클러스터가 적용된 MongoDB 환경에서 트랜잭션 사용 시 쿼리가 브로드캐스트 되는데, 이 경우 성능에 일정 부분은 영향을 줄 수 있다는 점을 감안해야 합니다.RDBMS 에서도 트랜잭션 자체가 길면 데이터 처리의 지연이 발생하며, 이런 부분에 대해서 트랜잭션을 짧게 구성하는 등의 처리를 하기에 트랜잭션에 대해서는 RDBMS, MongoDB 모두 트레이드 오프가 있다는 점을 감안할 수 있을 듯 합니다."}},"/spring-data-mongodb-reactive/mongo-collection-document-bson-bson-codec":{"title":"Mongo Collection Document Bson Bson Codec","data":{"mongocollection-document-bson-bson-codec#MongoCollection, Document, BSON, BSON Codec":"","mongocollection-의-다양한-연산들#MongoCollection 의 다양한 연산들":"기본 연산\ncountDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\natomic 연산\nfindOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)\nindex 연산\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","기본-연산#기본 연산":"countDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)","countdocuments-#countDocuments (...)":"","find-#find (...)":"","aggregate-#aggregate (...)":"","watch-#watch (...)":"","bulkwrite-#bulkWrite (...)":"","insertone-#insertOne (...)":"","insertmany-#insertMany (...)":"","updateone-#updateOne (...)":"","updatemany-#updateMany (...)":"","atomic-연산#atomic 연산":"findOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)","findoneanddelete-#findOneAndDelete (...)":"","findoneandreplace-#findOneAndReplace (...)":"","findoneandupdate#findOneAndUpdate(...)":"","index-연산#index 연산":"createIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","createindexes-#createIndexes (...)":"","listindexes-#listIndexes (...)":"","dropindexes-#dropIndexes (...)":"","document#Document":"","bson-bson-codec#BSON, BSON Codec":""}},"/spring-data-mongodb-reactive/spring-data-mongodb-reactive":{"title":"Spring Data Mongodb Reactive","data":{"spring-data-mongodb-reactive#Spring Data MongoDB Reactive":""}},"/spring-data-mongodb-reactive/mongodb-reactive-streams-driver":{"title":"Mongodb Reactive Streams Driver","data":{"mongodb-reactive-streams-driver#MongoDB Reactive Streams Driver":"","참고자료#참고자료":"Github | mongo-java-driver-reactivestreams\nMongoDB Reactive Streams Java Driver\nMongoDB Reactive Streams Documentation\nmongodb.com/docs/drivers/reactive-streams\nReference Documentation\nSource Code\nAPI Documentation\nTutorials\nmongodb.github.io/mongo-java-driver\n공식 도큐먼테이션 페이지이며, 버전명을 클릭해서 넘어가는 문서 페이지에서 Reactive Streams Driver 에 대한 설명을 모두 다루고 있습니다.\nMongoDB Reactive Streams Driver Documentation\nMongoDB Reactive Streams Driver Quick Start","mongodb-driver#MongoDB Driver":"Java 언어를 사용할 때 지원되는 MongoDB Driver 는 아래와 같이 두 종류가 있습니다.\n참고 : MongoDB Java Drivers\nJava Driver : Synchronous 하게 동작하는 Mongo Driver\nReactive Streams Driver : 비동기 스트림 프로세싱을 지원하는 Reactive Streams API 기반의 Driver","java-driver-synchronous-driver#Java Driver (Synchronous Driver)":"결과값을 확인해야 다음 연산이 이뤄지는 Synchronous API 이며, Blocking 기반의 IO 연산방식의 Driver 입니다. 클라이언트측에서 요청을 했을 때 결과값을 받기 전 까지는 Blocking 이 발생합니다.","reactive-streams-driver#Reactive Streams Driver":"Reactive Streams Driver 는 논블로킹 방식의 비동기 연산으로 동작합니다. Spring Reactive Stack 내에서 사용되며, 높은 성능, 안정성을 제공합니다.","spring-data-mongodb-와-reactive-streams-driver#Spring Data MongoDB 와 Reactive Streams Driver":"Spring Data MongoDB Reactive 라이브러리에는 아래와 같은 Database 접근 요소들이 있습니다.\nReactiveMongoRepository\nReactiveMongoTemplate\nReactiveMongoDatabaseFactory\n그리고 Spring Data MongoDB Reactive 라이브러리들은 아래의 Driver 기반의 코드들을 한단계 감싸서 고수준으로 제공하는 것입니다. 아주 드물게 복잡한 쿼리나 이런 것들을 작성해야 할 경우 아래와 같은 MongoClient, MongoDatabase, MongoCollection 기반으로 작성하기도 합니다.\nMongoCollection\nMongoDatabase\nMongoClient","reactive-streams-driver-1#Reactive Streams Driver":"Spring Data MongoDB Reactive 는 Reactive Streams Driver 의 API 를 감싸고 있는 고수준 API 입니다.Spring Data MongoDB Reactive 에서 Reactive Streams MongoDB Driver 를 이용해서 대표적으로 3 계층으로 나눠서 상호작용을 합니다.MongoClient\nMongoDB 클러스터를 가리키는 객체이며, 커넥션 객체들을 생성하거나 바인딩하고 있는 역할을 합니다.\n흔히 이야기하는 접속객체 같은 역할과 MongoDatabse Factory 역할을 합니다.\nMongoDatabase\nMongoDB 의 Database 를 가리키는 역할을 합니다.\ncodec, write concern, read preference 등과 같은 정보들을 바인딩하고 있습니다.\nMongoClient 객체를 통해서 MongoDatabase 객체를 얻어올 수 있습니다.\nMongoCollection\nMongoDB 의 collection 을 얻어오고 바인딩하고 있는 객체입니다.\nMongoDatabase 객체를 통해서 MongoCollection 객체를 얻어올 수 있습니다.\n마지막으로 위의 그림에는 없는 MongoClients 라는 클래스가 하나 더 있습니다.MongoClients 클래스는 MongoClient 라는 Mongodb 접속을 위한 MongoClient 객체를 만드는 MongoClient Factory 역할을 하는 클래스입니다. 그리고 이렇게 MongoClients 클래스를 통해 생성된 MongoClient 객체는 Connection 에 대한 정보들을 담고 있습니다.","eg-connection-생성#e.g. Connection 생성":"참고자료 : MongoDB Reactive Streams Driver Quick Start\n먼저 단순한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport com.mongodb.reactivestreams.client.MongoCollection;\r\nimport com.mongodb.reactivestreams.client.MongoDatabase;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.bson.Document;\r\n\r\n@Slf4j\r\npublic class MongoClientExample {\r\n  public static void main(String[] args) {\r\n    MongoClient mongoClient = MongoClients.create(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoDatabase helloworld = mongoClient.getDatabase(\"helloworld\");\r\n    log.info(\"database == {} \", helloworld.getName());\r\n    MongoCollection<Document> book = helloworld.getCollection(\"book\");\r\n    log.info(\"collection = {} \", book.getNamespace().getCollectionName());\r\n\r\n    log.info(\"Bye Bye. Close ~!!!\");\r\n    mongoClient.close();\r\n  }\r\n}\n위에서 설명했던 MongoClients 클래스를 통해 MongoClient 객체를 생성합니다. 그리고 얻어낸 mongoClient 객체로 database 명을 얻어오고, collection 을 얻어와서 컬렉션 명을 출력하고 있습니다. 접속 주소에는 컬렉션 명과, 데이터베이스 명을 지정하지 않았는데도 잘 읽어오는 것을 보면, MongoClient 는 내부적으로 접속을 위한 통신작업을 한다는 것을 알 수 있습니다.\n출력\n// ...\r\n\r\n19:28:56.824 [main] INFO io...MongoClientExample -- database == helloworld \r\n19:28:56.828 [main] INFO io...MongoClientExample -- collection = book \r\n19:28:56.828 [main] INFO io...MongoClientExample -- Bye Bye. Close ~!!!\n이번에는 조금 복잡한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.ConnectionString;\r\nimport com.mongodb.MongoClientSettings;\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class MongoClientExample2 {\r\n  public static void main(String[] args) {\r\n    var connection = new ConnectionString(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoClientSettings mongoClientSettings = MongoClientSettings.builder()\r\n        .applyConnectionString(connection)\r\n        .build();\r\n\r\n    try(MongoClient mongoClient = MongoClients.create(mongoClientSettings)){\r\n      var database = mongoClient.getDatabase(\"helloworld\");\r\n      log.info(\"database : {}\", database.getName());\r\n\r\n      var collection = database.getCollection(\"book\");\r\n      log.info(\"collection : {}\", collection.getNamespace().getCollectionName());\r\n\r\n      log.info(\"Finish. Bye Bye~!!\");\r\n    }\r\n\r\n  }\r\n}\n내용은 위의 예제와 비슷하므로 설명은 생략하도록 하겠습니다.출력\n// ...\r\n\r\n19:36:06.295 [main] INFO io...MongoClientExample2 -- database : helloworld\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- collection : book\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- Finish. Bye Bye~!!"}},"/spring-data-mongodb-reactive/mongodb-tools":{"title":"Mongodb Tools","data":{"mongodb-접근-도구들#MongoDB 접근 도구들":"","mongodb-클라우드-인스턴스#MongoDB 클라우드 인스턴스":"문서 작성을 위한 용도로 사용하는 MongoDB는 Atlas MongoDB 를 사용했습니다. 개발PC가 점점 노후화 되어서 팬 소음도 너무 크고 가끔은 컴퓨터가 터질것 같아 선택하게 되었습니다. 데이터베이스 등급은 무료 인스턴스를 선택했습니다.","mongodb-docker#MongoDB docker":"로컬에서만 실행하시거나, testcontainers 를 사용중이시라면, docker-compose 파일을 만들어두고 이것을 읽어들이는게 제일 편하고 빠릅니다. 이런 이유로 이번 문서에서는 docker-compose 파일도 추가해둡니다.","single-broker#single broker":"브로커 1기만 갖춰진 docker-compose 파일입니다.\nversion: '3.8'\r\nservices:\r\n  mongo:\r\n    image: mongo:6.0.5\r\n    ports:\r\n      - 27017:27017\r\n    environment:\r\n      MONGO_INITDB_DATABASE: foobar\r\n      MONGO_INITDB_ROOT_USERNAME: root\r\n      MONGO_INITDB_ROOT_PASSWORD: 1111","multi-broker#multi broker":"TODO : 추가예정입니다. 현재 개발 PC가 도커 구동시마다 팬 소음이 너무 커져서 문서작업을 되도록 뒤로 미루고 있습니다.","mongodb-compass#MongoDB compass":"Mongodb Compass\nwindows :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-win32-x64.msi\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/\nmacos :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-darwin-arm64.dmg\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/","mongodb-data-explorer#MongoDB Data Explorer":"설치한 Atlas 인스턴스는 Compass 로도 접속할 수 있겠지만, 브라우저에서 사용가능한 Mongodb Data Explorer 로도 접속가능합니다.\nhttps://cloud.mongodb.com","mongoose#mongoose":"몽구스를 이용한 스키마 모델링 방법도 있습니다.설치\nyarn add mongooose\nTODO : Mongoose 사용법에 대해서는 시간이 되는대로 정리하겠습니다.","mongodb-shell#MongoDB Shell":"","설치--환경변수-등록#설치 & 환경변수 등록":"windows\nhttps://downloads.mongodb.com/compass/mongosh-2.0.0-x64.msi 다운로드 & 설치\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nmacos\nbrew isntall mongosh\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nbrew install 이 아닌 Manually Install 을 원하신다면 Install Mongosh → Procedure → macOS 를 선택해주세요. 그리고 사용가능한 바이너리를 확인하시려면  Install from .zip File. 을 확인해주세요.\nMS윈도우즈 사용자의 경우 다운로드 받은 mongosh 파일을 Path 에 추가시킨 후 터미널에서 접근 가능합니다. MacOS 사용자의 경우에도 brew 로 설치하기보다는 별도로 다운로드 받은 디렉터리를 추가하고 싶다면 별도로 바이너리를 다운받으신후 Path 에 추가해주시면 됩니다.제 경우에는 MacOS 를 사용할 때에는 ~/username/workspace/bin 같은 디렉터리에 바이너리를 모아두었었는데, Manually Install 방식이 친절하게 제공되면 Manually Install 로 설치 후에 필요 없어지면 바이너리와 이와 관련된 디렉터리를 지워버리는 방식으로 개발 PC를 관리해왔는데, 가능한 경우에 한해서 이 방식으로 설치를 했었습니다. 가끔은 불편하더라도 나중에 관리가 깔끔하게 되려면 오히려 이런 방식이 더 편할 것 같기도 합니다.","database-선택-접근#Database 선택, 접근":"### 데이터베이스 선택\r\nuse [데이터베이스명]\r\n\r\n### 현재 사용중인 데이터베이스 확인\r\ndb\r\n\r\n### 서버 내의 데이터베이스 리스트\r\n### 최소 한개의 Document 를 가진 DB만 출력됩니다.\r\nshow dbs\r\n\r\n### 컬렉션에 Document insert\r\ndb.[컬렉션명].insertOne({k:v, ...})\r\n\r\n### db 내에 도큐먼트 조회\r\ndb.[데이터베이스명].find()\r\n\r\n### 데이터베이스 drop\r\n### 현재 선택한 데이터베이스를 drop\r\ndb.dropDatabase()","collection#Collection":"Collection 에 대한 자세한 옵션들(clusteredIndex, timeseries 옵션 등등)에 대한 설명은 MongoDB Manual/db.createCollection() 을 참고해주시기 바랍니다.\n## Collection 생성\r\ndb.createCollection(컬렉션 명)\r\n\r\n## 생성된 컬렉션 들 조회\r\nshow collections\r\n\r\n## 컬렉션 내의 모든 document 리스트들 조회\r\ndb.book.find()\r\n\r\n## 컬렉션 DROP\r\ndb.book.drop()","eof#EOF":"이번 문서에서는 접근환경에 대해서만 간단하게 정리했습니다. 추후에 시간이 된다면, MongoDB에서 지원하는 조회쿼리, aggregation 쿼리나, Date 형식의 데이터들, 인덱싱 개념들 등을 정리해두도록 하겠습니다."}},"/spring-data-r2dbc":{"title":"Spring Data R2DBC","data":{}},"/spring-data-r2dbc/mysql-features":{"title":"Mysql Features","data":{"mysql-특징#MySQL 특징":"자세한 내용은 docs-mysql-essential을 참고해주시기 바랍니다."}},"/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{}},"/spring-data-r2dbc/spring-data-r2dbc":{"title":"Spring Data R2dbc","data":{"spring-data-r2dbc#Spring Data R2DBC":""}},"/spring-data-redis-reactive/redis-data-structures":{"title":"Redis Data Structures","data":{"레디스-자료구조들#레디스 자료구조들":"String\nLIST\nSET\nSorted Set\nSortedSet\r\n정렬된 Set 자료구조입니다.\r\n잘 알려진 MergeSort 나 개선된 QuickSort 등을 통해 내부적으로 정렬을 수행하는데 보통 O(Nlog(M)) 또는 O(log(N)) 이 소요되는 경우가 많습니다.\r\n예를 들면, 주식 종목 검색이나 주식 종목 초성검색을 구현할 때 Sorted Set을 사용합니다.\r\n혹시라도 주식 종목검색, 초성검색 예제가 궁금하다면 여기를 참고하시면 될 것 같습니다.List, Set\r\nList 의 LPUSH, LPOP, RPUSH, RPOP 을 적절하게 활용해서 작업 대기열을 구성할 수도 있습니다. 요청의 고유값을 식별하기 위해서는 Set 에 요청 ID 를 기록해두는 방식을 사용합니다.\r\n최근 트렌드는 가급적 작업 대기열 등은 Kafka,Kafka Streams 또는 RabbitMQ를 사용하는 추세입니다. 하지만 팀내 인력상황, 마감기한 및 여러가지 운영 요소로 인해 큰 비용이 필요하지 않을 경우 간단하게 레디스 기반으로 작업 대기열을 구성하는 경우도 많습니다.\r\n이 경우, Redis 서버가 다운될 경우 작업 대기열의 데이터들 모두 유실될 수 있다는 점에 착안해서 예외 처리등을 명확히 해둬야 합니다.\nString\r\n특정 값을 저장하는 용도로 사용합니다. 단순 문자열을 저장할 수도 있겠지만 구분자(DELIMITER)를 기반으로 여러가지 요청 식별자를 조합해서 어떤 요청이 있었는지를 기반으로 조회가 가능하도록 저장하는 경우도 많습니다.","string-자료구조#String 자료구조":"단순한 문자열 데이터 형식\r\n주요 연산으로는 set, get 이 있습니다.\r\nset, get 은 시간복잡도가 각각 O(1) 입니다.","eg-set#e.g. set":"set coupon:1 \"Apple 50% Discount Event\"\r\nOK","eg-get#e.g. get":"get coupon:1\r\n\"Apple 50% Discount Event\"\n이렇게 생성한 자료구조는 del 명령어로 삭제 가능합니다.","list-자료구조#List 자료구조":"리스트와 같은 선형자료 구조\r\nLPUSH 로 리스트의 제일 왼쪽(head)에 데이터를 추가할 수도 있고 RPUSH 로 리스트의 제일 오른쪽(tail)에 데이터를 추가할 수 있습니다.","lrange#LRANGE":"redis.io/commands - LRANGE\nLIST 내의 지정된 범위에 해당하는 요소들을 반환합니다.\n시간복잡도 O(S+N) 에 해당하는 연산입니다.\nS는 시작 Offset 의 Head/Tail 로부터의 거리 (distance)를 의미합니다.\nN은 지정된 Range 내에 속한 요소들의 개수를 의미합니다.\nLRANGE key start stop","lpush#LPUSH":"redis.io/commands - LPUSH\n리스트의 제일 왼쪽(head)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLPUSH key element [element ...]","rpush#RPUSH":"redis.io/commands - RPUSH\n리스트의 제일 오른쪽(tail)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nRPUSH key element [element ...]","lpop#LPOP":"redis.io/commands - LPOP\n리스트의 첫 번째 요소(Head)를 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nLPOP key [count]\n리스트의 첫 번째로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 제일 처음 요소로부터 3개의 요소를 POP 하게 됩니다.","rpop#RPOP":"redis.io/commands - RPOP\n리스트의 제일 마지막 요소(Tail)을 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nRPOP key [count]\n리스트의 마지막으로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 맨끝에서 3개의 요소를 POP 하게 됩니다.","llen#LLEN":"redis.io/commands - LLEN\n현재 리스트의 사이즈를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLLEN key","lpos#LPOS":"redis.io/commands - LPOS\n리스트 내에서 일치하는 요소를 찾는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다. 만약 MAXLEN 을 명시해서 호출하면 상수 시간 내에 수행됩니다.\nLPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]","set-자료구조#SET 자료구조":"어느 언어에서든 제공되는 Set 개념에 해당하는 자료구조입니다.","smembers#SMEMBERS":"redis.io/commands - SMEMBERS\nkey 에 해당하는 Set 에 저장된 모든 요소들을 반환합니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nSMEMBERS key","sadd#SADD":"redis.io/commands - SADD\nkey 에 해당하는 Set 에 요소를 추가합니다. 이때 요소 하나만 지정할 수도 있고 요소 여러개를 지정해서 여러개의 요소를 한번에 추가할 수 도 있습니다.\n요소 하나를 추가할 때는 시간복잡도 O(1) 에 해당하는 연산입니다. 만약 요소 K 개를 하나의 명령어로 추가할 경우에는 O(K) 의 시간복잡도를 가집니다.\nSADD key member [member ...]","sismember#SISMEMBER":"redis.io/commands - SISMEMBER\nkey 에 해당하는 Set 에 member 에 해당하는 요소가 존재하는지 검사합니다. 존재한다면 1을, 존재하지 않는다면 0 을 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSISMEMBER key member","scard#SCARD":"redis.io/commands - SCARD\nkey 에 해당하는 Set의 사이즈(Cardinality, 요소의 갯수)를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSCARD key","srem#SREM":"redis.io/commands - SREM\nkey 에 해당하는 Set 내에서 인자값으로 전달받은 member를 삭제하는 연산입니다. 지우고자 하는 요소가 여러개라면 지루려는 요소들을 모두 인자값으로 전달해주면 됩니다.\n지워야하는 요소수가 K개일 경우 시간복잡도 O(K) 가 소요되는 연산입니다.\nSREM key member [member ...]","sorted-set#Sorted Set":"스코어를 기반으로 순서를 지정해서 정렬된 상태로 저장하는 문자열 컬렉션입니다.\r\nSet 자료구조이므로 중복을 허용하지 않습니다.","zrange#ZRANGE":"redis.io/commands - ZRANGE\nkey 에 해당하는 SortedSet 에서 cli 에 명시한 Range 에 해당하는 요소들을 리턴하는 연산입니다.\nO(log(N)+M) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미하며, M 은 반환된 요소 수를 의미합니다.\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]\r\n[WITHSCORES]","zadd#ZADD":"redis.io/commands - ZADD\nkey 에 해당하는 SortedSet 에 score 와 함께 요소들을 저장합니다. score 를 기반으로 정렬되며, score가 같은 요소는 문자열 정렬을 통해 오름차순 정렬되어 저장됩니다.\nO(log(N)) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미합니다.\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member\r\n...]\ne.g. redis> ZADD myzset 1 \"one\"\ne.g. redis> ZADD myzset 2 \"two\" 3 \"three\"","zcard#ZCARD":"redis.io/commands - ZCARD\nkey 에 해당하는 SortedSet 의 사이즈(Cardinality, 요소의 개수)를 리턴합니다.\nO(1) 의 시간복잡도가 소요됩니다.\nZCARD key","zpopmin#ZPOPMIN":"redis.io/commands - ZPOPMIN\nkey 에 해당하는 SortedSet 에서 score 가 가장 낮은 순으로 요소들 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMIN key [count]","zpopmax#ZPOPMAX":"redis.io/commands - ZPOPMAX\nkey 에 해당하는 SortedSet 에서 score 가 가장 높은 요소들을 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMAX key [count]"}},"/spring-data-redis-reactive/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{"spring-data-redis-reactive#Spring Data Redis Reactive":""}},"/spring-data-redis-reactive/known-cache-strategies":{"title":"Known Cache Strategies","data":{"많이-알려진-캐시-전략들#많이 알려진 캐시 전략들":"Cache Aside\nfeat. Spring Cache Manager\nWrite Back\nfeat. 작업 대기열\nWirte Through\n캐싱과 IO 작업을 함께 처리"}}}