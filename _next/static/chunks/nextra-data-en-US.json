{"/":{"title":"Introduction","data":{"":"Spring Data Reactive 문서보관소입니다.\n예제코드 Github Repository\nSpring Data R2DBC Example : [https://github.com/chagchagchag/example-spring-data-r2dbc-mysql]\nSpring Data MongoDB Reactive : example-spring-data-mongo-reactive"}},"/spring-data-mongodb-reactive":{"title":"Spring Data Mongodb Reactive","data":{"spring-data-mongodb-reactive#Spring Data MongoDB Reactive":""}},"/spring-data-mongodb-reactive/entity":{"title":"Entity","data":{"entity#Entity":"MongoDB 내의 컬렉션 내에 존재하는 하나의 Document 에 해당하는 객체를 표현하는 클래스를 Entity 라고 부르며, @Document 애노테이션을 통해 Entity 를 식별합니다. spring data mongodb reactive 에서는 Document 를 Entity 단위로 식별하기 위해서 필요한 데이터베이스관련 세팅들에 대한 metadata 들을 @Id, @Field 등과 같은 애노테이션으로 제공해주고 있습니다.","document#@Document":"클래스 레벨의 애노테이션입니다.Entity 로 식별할 데이터의 단위를 표현한 클래스를  @Document 애노테이션을 붙여서 적용합니다.collection 명을 별도로 지정 가능합니다.","id#@Id":"필드 레벨의 애노테이션입니다._id 필드에 대해 적용하는 애노테이션입니다.Mongodb 의 모든 도큐먼트는 _id 필드가 필요합니다.MappingMongoConverter 는 아래의 방식을 통해 _id 를 식별해서 매핑하거나 자동으로 추가합니다.\n@Id 가 붙어있는 필드가 있을 경우 _id 필드를 매핑\n필드 명이 id 이고 @Field 를 통해서 별도의 이름이 부여되지 않은 경우 이 필드를 _id 필드로 매핑합니다.\nid 필드가 제공되지 않는 경우에는 자동으로 _id 필드가 추가됩니다.","dbref#@DBRef":"필드 레벨의 애노테이션입니다.MongoDB 의 DBRef 형태로 저장해야 하는 필드에 사용하는 애노테이션 입니다.","indexed#@Indexed":"필드 레벨의 애노테이션입니다.이 애노테이션이 표시된 필드에 대해서 인덱스를 생성합니다. 기본적으로는 자동 생성이 비활성화이며, 별도의 설정이 필요합니다.","compoundindex#@CompoundIndex":"클래스 레벨의 애노테이션입니다.여러 필드로 구성된 복합 인덱스를 적용하고자 할 때 사용하는 애노테이션입니다.","textindexed#@TextIndexed":"필드 레벨의 애노테이션입니다.필드에 text index 를 적용합니다.","hashindexed#@HashIndexed":"필드 레벨의 애노테이션입니다.필드에 hash index 를 적용합니다.","persistenceconstructor#@PersistenceConstructor":"생성자에 명시하는 애노테이션입니다.Spring Data Object Mapping 문서에서 자세하게 객체 생성규칙, 필드 주입 원칙 등에 대해 정리합니다.\nTODO : 링크 추가 필요","field#@Field":"필드 레벨의 애노테이션입니다.Entity 로 인식할 클래스 내의 필드에 대해 적용합니다. @Field 가 붙은 필드는 convention 기반이 아닌 Field 에 명시한 name 을 적용해서 인식합니다.","transient#@Transient":"필드 레벨의 애노테이션입니다.Entity 로 인식할 클래스 내의 필드 중 Document 매핑에서 제외할 필드에 대해 @Transient 애노테이션을 적용합니다.","version#@Version":"필드 레벨의 애노테이션입니다.낙관적 락(Optimistic Lock) 을 적용하고자 할 때 사용하는 애노테이션입니다. Entity 가 Update 될 때마다 자동으로 Update 됩니다."}},"/spring-data-mongodb-reactive/mongodb-features":{"title":"Mongodb Features","data":{"mongodb-features#MongoDB Features":"","mongo-db#Mongo DB":"MongoDB 는 오픈소스 NoSQL 데이터베이스입니다. 2007 년 10gen 이라는 회사에서 Paas 로 MongoDB 개발을 시작했고, 2009 년에 오픈소스 모델로 전환해서 사용지원, 기타 서비스를 제공하는 방식을 따르게 되었습니다. 2013년에는 10gen 이라는 회사 명이 MongoDB Inc. 로 변경되었으며 현재 전 세계에서 대중적으로 알려진 NoSQL 데이터베이스가 되었습니다.스키마가 정의되어 있지 않아도 데이터 저장을 유연하게 할 수 있습니다. 또한 다양한 종류의 index를 지원하고, 4.0 부터 multi docoument transaction 을 지원하기에 트랜잭션의 ACID 가 보장됩니다.몽고DB를 운영할 때 레플리카셋과 샤드 클러스터를 적용하면 데이터를 여러 노드에 분산해서 저장하고 처리하는 것이 가능해지며, 장애에 내성이 강한 데이터베이스로 전환이 가능합니다.","mongodb-bson#MongoDB BSON":"Binary 형식의 JSON 데이터를 BSON 이라고 부릅니다. MongoDB는 데이터를 BSON 형식으로 저장합니다.BSON 은 JSON 보다 인코딩/디코딩이 빠르고, 다양한 데이터 타입들이 BSON 에 지원됩니다.\ndocument id : ObjectId\n바이너리 데이터 : BinData\n날짜 : Date, ISODate\n정규표현식\nBSON 타입에 대한 자세한 내용은 아래의 링크들에서 자세히 확인 가능합니다.bsonspec.org\nbsonspec.org\nbsonspec.org/implementation.html\nMongodb.com\nWhat is BSON?\nHow is BSON different from JSON?\nAdvantages of BSON\nHow to convert JSON to BSON\nImport and export BSON documents\nBSON Document Example","mongodb-bson-인코딩#MongoDB BSON 인코딩":"BSON 은 필드의 순서에 따라서 인코딩이 달라지며, 첫줄은 document 의 크기를 의미합니다.\nbson converter 는 https://onlinejsontools.com/convert-json-to-bson 을 사용했습니다.","mongodb-document-collection-database#MongoDB Document, Collection, Database":"TODO : 그림 추가","mongodb-트랜잭션#MongoDB 트랜잭션":"4.0 버전 이후부터는 multi-document 트랜잭션 ACID 를 지원하기 시작했습니다.레플리카셋과 샤드클러스터가 적용된 MongoDB 환경에서 트랜잭션 사용 시 쿼리가 브로드캐스트 되는데, 이 경우 성능에 일정 부분은 영향을 줄 수 있다는 점을 감안해야 합니다.RDBMS 에서도 트랜잭션 자체가 길면 데이터 처리의 지연이 발생하며, 이런 부분에 대해서 트랜잭션을 짧게 구성하는 등의 처리를 하기에 트랜잭션에 대해서는 RDBMS, MongoDB 모두 트레이드 오프가 있다는 점을 감안할 수 있을 듯 합니다."}},"/spring-data-mongodb-reactive/mongo-collection-functions":{"title":"Mongo Collection Functions","data":{"mongocollection-의-다양한-연산들#MongoCollection 의 다양한 연산들":"","참고자료#참고자료":"mongodb.github.io/mongo-java-driver\ndirver core : Aggregates, Filters 등 다양한 집계 연산을 위한 core 라이브러리 및 여러가지 codec, geojson 등이 포함된 라이브러리입니다.\nAggregates, Filters 등과 같은 필터나 Aggregate 를 Bson 으로 생성하는 헬퍼 팩토리 메서드 들은 주로 com.mongodb.client.model 에 위치해있습니다.\nJava Reactive Streams Driver","요약#요약":"기본 연산\ncountDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\natomic 연산\nfindOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)\nindex 연산\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","기본-연산#기본 연산":"countDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)","countdocuments-#countDocuments (...)":"참고\nMongoCollection.java\ncountDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nCollection 메타 데이터를 이용해서 컬렉션 내의 Document 의 갯수를 반환합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Counts the number of documents in the collection according to the given options.\r\n     * ...\r\n     */\r\n    Publisher<Long> countDocuments(ClientSession clientSession, Bson filter, CountOptions options);\r\n}\nClientSession : ClientSession 을 통해서 multi document transaction 을 지원합니다.\nBson filter : Bson 구현채를 이용해서 filter 연산이 가능합니다.\nCountOptions options : hint, limit, skip, maxTime, collation 등과 같은 정보를 Option 으로 넘기는 것이 가능합니다.","find-#find (...)":"참고\nMongoCollection.java\nFilters\nfind(ClientSession clientSession, Bson filter)\n컬렉션 내에서 filter 에 해당되는 모든 도큐먼트들을 불러옵니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Finds all documents in the collection.\r\n     * ...\r\n     */\r\n    FindPublisher<TDocument> find();\r\n}\nFilters 에서 제공하는 정적 팩토리 메서드 들 에는 eq, ne, gt, gte, lt, lte, in, nin, and, or, not, nor, exists, type, mod, regex, text 등과 같은 연산자를 지원하는 메서드 들이 있는데 모두 Bson 객체를 Filter 에 맞는 형식으로 객체를 생성하는 메서드 들입니다.\n자세한 내용은 IDE 에서 Filters 클래스를 찾아보거나 Filters 를 참고해주세요.","aggregate-#aggregate (...)":"참고\nMongoCollection.java\naggregate(List<? extends Bson> pipeline)\nAggregates\npipline 에 해당하는 Bson 식들에 대해 필터링, 집계, 그루핑 등과 같은 aggregation  을 수행합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Aggregates documents according to the specified aggregation pipeline.\r\n     * ...\r\n     */\r\n    AggregatePublisher<TDocument> aggregate(List<? extends Bson> pipeline);\r\n}\nAggregates 클래스에서는 aggregation 표현식을 Bson 객체로 생성해내는 다양한 종류의 정적 팩토리 메서드들이  헬퍼 메서드로 존재합니다.지원되는 메서드 들은 굉장히 다양하며 그 중 대표적으로 잘 알려진 메서드 들은 아래와 같습니다.\naddFields, set, bucket, bucketAuto\nsort, sortByCount\ncount\nmatch, project\nskip, limit, lookup\nfacet, graphLookup, group, unionWith, unwind, out, merge, replaceRoot, replaceWith, sample","watch-#watch (...)":"참고\nMongoCollection.java\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nChangeStreamPublisher\n컬렉션에 대한 변경사항 발생시 변경사항에 대한 Stream (Change Stream) 을 만들어냅니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Creates a change stream for this collection.\r\n     * ...\r\n     */\r\n    ChangeStreamPublisher<Document> watch(ClientSession clientSession, List<? extends Bson> pipeline);\r\n}\nChangeStreamPublisher 타입을 반환합니다. 이렇게 만들어진 ChangeStream 은 subscribe 시에 onNext 이벤트를 통해 읽어들여집니다.","bulkwrite-#bulkWrite (...)":"참고\nMongoCollection.java\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\nBulkWriteOptions\nWriteModel\ninsert, updates, replaces, delete 연산을 한번에 모아서 bulk 연산을 수행합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Executes a mix of inserts, updates, replaces, and deletes.\r\n     * ...\r\n     */\r\n    Publisher<BulkWriteResult> bulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests,\r\n                              BulkWriteOptions options);\r\n}\n입력인자를 보면 WriteModel 이 보입니다. 이 WriteModel 은 interface 이며 구체타입 들은 아래와 같습니다.\nDeleteManyModel : 조건을 만족하는 모든 Document 를 찾아서 모두 삭제할 수 있도록 표현된 Model 객체입니다.\nDeleteOneModel : 조건을 만족하는 하나의 Document 를 찾아서 삭제할 수 있도록 표현된 Model 객체입니다.\nInsertOneModel : 하나의 Document 를 Inert 할 수 있도록 표현된 Model 객체입니다.\nReplaceOneModel : 조건을 만족하는 하나의 Document 를 찾아서 Replace 할 수 있도록 표현된 Model 객체입니다.\nUpdateManyModel : 조건을 만족하는 2개 이상의 Document 를 찾아서 수정할 수 있도록 표현된 Model 객체입니다.\nUpdateOneModel : 조건을 만족하는 하나의 Document 를 찾아서 수정할 수 있도록 표현된 Model 객체입니다.","insertone-#insertOne (...)":"참고\nMongoCollection.java\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\nInsertOneOptions, InsertOneOptions.java\n하나의 document 를 insert 할 수 있도록 MongoCollection 클래스에서 지원되는 메서드입니다.만약 id 와 같은 식별자가 누락되어 있다면, mongodb-java-driver 가 자동으로 생성합니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Inserts the provided document. If the document is missing an identifier, the driver should generate one.\r\n     * ...\r\n     */\r\n    Publisher<InsertOneResult> insertOne(ClientSession clientSession, TDocument document, InsertOneOptions options);\r\n}\nInsertOneOptions 가 보입니다. InsertOneOptions 는 validation 을 우회할 지 결정하는 필드를가지고 있습니다.\npackage com.mongodb.client.model;\r\n/**\r\n * The options to apply to an operation that inserts a single document into a collection.\r\n */\r\npublic final class InsertOneOptions {\r\n    private Boolean bypassDocumentValidation;\r\n    private BsonValue comment;\r\n    // ... \r\n}","insertmany-#insertMany (...)":"참고\nMongoCollection.java\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nInsertManyOptions, InsertManyOptions.java\n여러개의 Document 를 insert 할 수 있도록 제공되는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Inserts one or more documents.  A call to this method is equivalent to a call to the {@code bulkWrite} method\r\n     * ...\r\n     */\r\n    Publisher<InsertManyResult> insertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options);\r\n}\nInsertManyOptions 가 보입니다. InsertManyOptions 는 validation 을 우회할 지, insert 순서를 보장할지를 결정하는 필드들을 가지고 있습니다.\npackage com.mongodb.client.model;\r\n/**\r\n * The options to apply to an operation that inserts multiple documents into a collection.\r\n */\r\npublic final class InsertManyOptions {\r\n    private boolean ordered = true;\r\n    private Boolean bypassDocumentValidation;\r\n    private BsonValue comment;\r\n    // ...\r\n}","updateone-#updateOne (...)":"참고\nMongoCollection.java\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nUpdateOptions, UpdateOptions.java\nfilter 를 통해 찾아지는 도큐먼트 1개를 update 하는 연산이며, UpdateOptions 를 통해서 upsert, hint, collation, variables 를 명시할 수 있습니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Update a single document in the collection according to the specified arguments.\r\n     * ...\r\n     */\r\n    Publisher<UpdateResult> updateOne(Bson filter, List<? extends Bson> update, UpdateOptions updateOptions);\r\n}\nUpdateOptions 가 보입니다. UpdateOptions 에는 아래와 같이 upsert, hint, collation, variables 등을 지정할 수 있는 필드들이 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply when updating documents.\r\n */\r\npublic class UpdateOptions {\r\n    private boolean upsert;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","updatemany-#updateMany (...)":"참고\nMongoCollection.java\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nfilter 를 통해 찾아지는 1개 또는 두개 이상의 모든 도큐먼트들을 update 하는 연산이며, UpdateOptions 를 통해서 upsert, hint, collation, variables 를 명시할 수 있습니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Update all documents in the collection according to the specified arguments.\r\n     * ...\r\n     */\r\n    Publisher<UpdateResult> updateMany(ClientSession clientSession, Bson filter, Bson update, UpdateOptions updateOptions);\r\n}\nUpdateOptions 가 보입니다. UpdateOptions 에는 아래와 같이 upsert, hint, collation, variables 등을 지정할 수 있는 필드들이 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply when updating documents.\r\n */\r\npublic class UpdateOptions {\r\n    private boolean upsert;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","atomic-연산#atomic 연산":"findOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)","findoneanddelete-#findOneAndDelete (...)":"참고\nMongoCollection.java\nfindOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\n원자적으로 도큐먼트 하나를 찾아낸 후 삭제하는 것을 보장하는 연산입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and remove it.\r\n     * ...\r\n     */\r\n    Publisher<TDocument> findOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options);\r\n}\nFindOneAndDeleteOptions.java 의 내용은 아래와 같습니다.sort 옵션, collation 옵션, hint 옵션, comment 옵션을 따로 지정할 수 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and deletes it.\r\n */\r\npublic class FindOneAndDeleteOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private long maxTimeMS;\r\n    private Collation collation;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    \r\n    // ...\r\n}","findoneandreplace-#findOneAndReplace (...)":"참고\nMongoCollection.java\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfilter 에 해당하는 하나의 도큐먼트를 찾아서 원자적으로 Replace 하는 것이 보장되는 함수입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and replace it.\r\n     * ...\r\n     */\r\n    @Nullable\r\n    Publisher<TDocument> findOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options);\r\n}\nFindOneAndReplaceOptions 의 코드는 아래와 같습니다. hint, sort, upsert 여부, validation 을 건너뛸지에 대한 여부인 bypassDocumentValidation, collation, hint 를 지정할 수 있음을 확인 가능합니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and replaces it.\r\n */\r\npublic class FindOneAndReplaceOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private boolean upsert;\r\n    private ReturnDocument returnDocument = ReturnDocument.BEFORE;\r\n    private long maxTimeMS;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","findoneandupdate#findOneAndUpdate(...)":"참고\nMongoCollection.java\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)\nfilter 에 해당하는 하나의 도큐먼트를 찾아서 원자적으로 Update 하는 것이 보장되는 함수입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and update it.\r\n     * ...\r\n     */\r\n    @Nullable\r\n    Publisher<TDocument> findOneAndUpdate(Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options);\r\n}\nFindOneAndUpdateOptions.java 의 코드는 아래와 같습니다. upsert 여부, sort 를 어떻게할지, validation 을 skip 할지에 대한 옵션인 bypassDocumentValidation, collation, hint 를 옵션으로 설정할 수 있음을 확인 가능합니다.\npackage com.mongodb.client.model;\r\n\r\n// ...\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and updates it.\r\n */\r\npublic class FindOneAndUpdateOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private boolean upsert;\r\n    private ReturnDocument returnDocument = ReturnDocument.BEFORE;\r\n    private long maxTimeMS;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","index-연산#index 연산":"컬렉션의 특정 필드들에 대해 insdex 생성, 조회, 삭제 기능을 제공합니다.\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","createindexes-#createIndexes (...)":"참고\nMongoCollection.java\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\n인자로 전달된 IndexModel 리스트에 대해 여러개의 인덱스들을 생성하는 역할을 하는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Create multiple indexes.\r\n     * ...\r\n     */\r\n    Publisher<String> createIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions);\r\n}\nCreateIndexOptions.java 의 내용은 아래와 같습니다.\nmaxTimeMS : 연산 수행시 최대 몇 ms 만큼을 기다릴지를 결정합니다.\ncommitQuorum : 커밋 시에 여러 브로커 들 간에 투표시 어떻게 할지에 대한 옵션입니다. Quorum은 분산 시스템에서 데이터 일관성과 가용성을 보장하기 위한 개념 중 하나입니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to the command when creating indexes.\r\n *\r\n * @mongodb.driver.manual reference/command/createIndexes Index options\r\n * @since 3.6\r\n */\r\npublic class CreateIndexOptions {\r\n    private long maxTimeMS;\r\n    private CreateIndexCommitQuorum commitQuorum;\r\n    // ...\r\n}","listindexes-#listIndexes (...)":"참고\nMongoCollection.java\nlistIndexes(ClientSession clientSession)\n컬렉션에 존재하는 모든 index 들을 조회하는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Get all the indexes in this collection.\r\n     * ...\r\n     */\r\n    ListIndexesPublisher<Document> listIndexes(ClientSession clientSession);\r\n}","dropindex-#dropIndex (...)":"참고\nMongoCollection.java\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)\n컬렉션에서 indexName 에 해당하는 인덱스를 DROP 하는 역할의 메서드 입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Drops the index given its name.\r\n     * ...\r\n     */\r\n    Publisher<Void> dropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions);\r\n}\nDropIndexOptions.java 의 내용은 아래와 같습니다.\npackage com.mongodb.client.model;\r\n// ...\r\n\r\n/**\r\n * The options to apply to the command when dropping indexes.\r\n */\r\npublic class DropIndexOptions {\r\n    private long maxTimeMS;\r\n    // ...\r\n}"}},"/spring-data-mongodb-reactive/mongodb-tools":{"title":"Mongodb Tools","data":{"mongodb-접근-도구들#MongoDB 접근 도구들":"","mongodb-클라우드-인스턴스#MongoDB 클라우드 인스턴스":"문서 작성을 위한 용도로 사용하는 MongoDB는 Atlas MongoDB 를 사용했습니다. 개발PC가 점점 노후화 되어서 팬 소음도 너무 크고 가끔은 컴퓨터가 터질것 같아 선택하게 되었습니다. 데이터베이스 등급은 무료 인스턴스를 선택했습니다.","mongodb-docker#MongoDB docker":"로컬에서만 실행하시거나, testcontainers 를 사용중이시라면, docker-compose 파일을 만들어두고 이것을 읽어들이는게 제일 편하고 빠릅니다. 이런 이유로 이번 문서에서는 docker-compose 파일도 추가해둡니다.","single-broker#single broker":"브로커 1기만 갖춰진 docker-compose 파일입니다.\nversion: '3.8'\r\nservices:\r\n  mongo:\r\n    image: mongo:6.0.5\r\n    ports:\r\n      - 27017:27017\r\n    environment:\r\n      MONGO_INITDB_DATABASE: foobar\r\n      MONGO_INITDB_ROOT_USERNAME: root\r\n      MONGO_INITDB_ROOT_PASSWORD: 1111","multi-broker#multi broker":"TODO : 추가예정입니다. 현재 개발 PC가 도커 구동시마다 팬 소음이 너무 커져서 문서작업을 되도록 뒤로 미루고 있습니다.","mongodb-compass#MongoDB compass":"Mongodb Compass\nwindows :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-win32-x64.msi\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/\nmacos :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-darwin-arm64.dmg\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/","mongodb-data-explorer#MongoDB Data Explorer":"설치한 Atlas 인스턴스는 Compass 로도 접속할 수 있겠지만, 브라우저에서 사용가능한 Mongodb Data Explorer 로도 접속가능합니다.\nhttps://cloud.mongodb.com","mongoose#mongoose":"몽구스를 이용한 스키마 모델링 방법도 있습니다.설치\nyarn add mongooose\nTODO : Mongoose 사용법에 대해서는 시간이 되는대로 정리하겠습니다.","mongodb-shell#MongoDB Shell":"","설치--환경변수-등록#설치 & 환경변수 등록":"windows\nhttps://downloads.mongodb.com/compass/mongosh-2.0.0-x64.msi 다운로드 & 설치\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nmacos\nbrew isntall mongosh\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nbrew install 이 아닌 Manually Install 을 원하신다면 Install Mongosh → Procedure → macOS 를 선택해주세요. 그리고 사용가능한 바이너리를 확인하시려면  Install from .zip File. 을 확인해주세요.\nMS윈도우즈 사용자의 경우 다운로드 받은 mongosh 파일을 Path 에 추가시킨 후 터미널에서 접근 가능합니다. MacOS 사용자의 경우에도 brew 로 설치하기보다는 별도로 다운로드 받은 디렉터리를 추가하고 싶다면 별도로 바이너리를 다운받으신후 Path 에 추가해주시면 됩니다.제 경우에는 MacOS 를 사용할 때에는 ~/username/workspace/bin 같은 디렉터리에 바이너리를 모아두었었는데, Manually Install 방식이 친절하게 제공되면 Manually Install 로 설치 후에 필요 없어지면 바이너리와 이와 관련된 디렉터리를 지워버리는 방식으로 개발 PC를 관리해왔는데, 가능한 경우에 한해서 이 방식으로 설치를 했었습니다. 가끔은 불편하더라도 나중에 관리가 깔끔하게 되려면 오히려 이런 방식이 더 편할 것 같기도 합니다.","database-선택-접근#Database 선택, 접근":"### 데이터베이스 선택\r\nuse [데이터베이스명]\r\n\r\n### 현재 사용중인 데이터베이스 확인\r\ndb\r\n\r\n### 서버 내의 데이터베이스 리스트\r\n### 최소 한개의 Document 를 가진 DB만 출력됩니다.\r\nshow dbs\r\n\r\n### 컬렉션에 Document insert\r\ndb.[컬렉션명].insertOne({k:v, ...})\r\n\r\n### db 내에 도큐먼트 조회\r\ndb.[데이터베이스명].find()\r\n\r\n### 데이터베이스 drop\r\n### 현재 선택한 데이터베이스를 drop\r\ndb.dropDatabase()","collection#Collection":"Collection 에 대한 자세한 옵션들(clusteredIndex, timeseries 옵션 등등)에 대한 설명은 MongoDB Manual/db.createCollection() 을 참고해주시기 바랍니다.\n## Collection 생성\r\ndb.createCollection(컬렉션 명)\r\n\r\n## 생성된 컬렉션 들 조회\r\nshow collections\r\n\r\n## 컬렉션 내의 모든 document 리스트들 조회\r\ndb.book.find()\r\n\r\n## 컬렉션 DROP\r\ndb.book.drop()","eof#EOF":"이번 문서에서는 접근환경에 대해서만 간단하게 정리했습니다. 추후에 시간이 된다면, MongoDB에서 지원하는 조회쿼리, aggregation 쿼리나, Date 형식의 데이터들, 인덱싱 개념들 등을 정리해두도록 하겠습니다."}},"/spring-data-mongodb-reactive/mongodb-reactive-streams-driver":{"title":"Mongodb Reactive Streams Driver","data":{"mongodb-reactive-streams-driver#MongoDB Reactive Streams Driver":"","참고자료#참고자료":"Github | mongo-java-driver-reactivestreams\nMongoDB Reactive Streams Java Driver\nMongoDB Reactive Streams Documentation\nmongodb.com/docs/drivers/reactive-streams\nReference Documentation\nSource Code\nAPI Documentation\nTutorials\nmongodb.github.io/mongo-java-driver\n공식 도큐먼테이션 페이지이며, 버전명을 클릭해서 넘어가는 문서 페이지에서 Reactive Streams Driver 에 대한 설명을 모두 다루고 있습니다.\nMongoDB Reactive Streams Driver Documentation\nMongoDB Reactive Streams Driver Quick Start","mongodb-driver#MongoDB Driver":"Java 언어를 사용할 때 지원되는 MongoDB Driver 는 아래와 같이 두 종류가 있습니다.\n참고 : MongoDB Java Drivers\nJava Driver : Synchronous 하게 동작하는 Mongo Driver\nReactive Streams Driver : 비동기 스트림 프로세싱을 지원하는 Reactive Streams API 기반의 Driver","java-driver-synchronous-driver#Java Driver (Synchronous Driver)":"결과값을 확인해야 다음 연산이 이뤄지는 Synchronous API 이며, Blocking 기반의 IO 연산방식의 Driver 입니다. 클라이언트측에서 요청을 했을 때 결과값을 받기 전 까지는 Blocking 이 발생합니다.","reactive-streams-driver#Reactive Streams Driver":"Reactive Streams Driver 는 논블로킹 방식의 비동기 연산으로 동작합니다. Spring Reactive Stack 내에서 사용되며, 높은 성능, 안정성을 제공합니다.","spring-data-mongodb-와-reactive-streams-driver#Spring Data MongoDB 와 Reactive Streams Driver":"Spring Data MongoDB Reactive 라이브러리에는 아래와 같은 Database 접근 요소들이 있습니다.\nReactiveMongoRepository\nReactiveMongoTemplate\nReactiveMongoDatabaseFactory\n위와 같은 Spring Data MongoDB Reactive 라이브러리들은 아래의 Driver 기반의 코드들을 한단계 감싸서 고수준으로 제공하고 있습니다. 아주 드물게 복잡한 쿼리나 이런 것들을 작성해야 할 경우 아래와 같은 MongoClient, MongoDatabase, MongoCollection 기반으로 작성하기도 합니다.\nMongoCollection\nMongoDatabase\nMongoClient","reactive-streams-driver-1#Reactive Streams Driver":"Spring Data MongoDB Reactive 는 Reactive Streams Driver 의 API 를 감싸고 있는 고수준 API 입니다.Spring Data MongoDB Reactive 에서 Reactive Streams MongoDB Driver 를 이용해서 대표적으로 3 계층으로 나눠서 상호작용을 합니다.MongoClient\nMongoDB 클러스터를 가리키는 객체이며, 커넥션 객체들을 생성하거나 바인딩하고 있는 역할을 합니다.\n흔히 이야기하는 접속객체 같은 역할과 MongoDatabse Factory 역할을 합니다.\nMongoDatabase\nMongoDB 의 Database 를 가리키는 역할을 합니다.\ncodec, write concern, read preference 등과 같은 정보들을 바인딩하고 있습니다.\nMongoClient 객체를 통해서 MongoDatabase 객체를 얻어올 수 있습니다.\nMongoCollection\nMongoDB 의 collection 을 얻어오고 바인딩하고 있는 객체입니다.\nMongoDatabase 객체를 통해서 MongoCollection 객체를 얻어올 수 있습니다.\n마지막으로 위의 그림에는 없는 MongoClients 라는 클래스가 하나 더 있습니다.MongoClients 클래스는 MongoClient 라는 Mongodb 접속을 위한 MongoClient 객체를 만드는 MongoClient Factory 역할을 하는 클래스입니다. 그리고 이렇게 MongoClients 클래스를 통해 생성된 MongoClient 객체는 Connection 에 대한 정보들을 담고 있습니다.","eg-connection-생성#e.g. Connection 생성":"참고자료 : MongoDB Reactive Streams Driver Quick Start\n먼저 단순한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport com.mongodb.reactivestreams.client.MongoCollection;\r\nimport com.mongodb.reactivestreams.client.MongoDatabase;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.bson.Document;\r\n\r\n@Slf4j\r\npublic class MongoClientExample {\r\n  public static void main(String[] args) {\r\n    MongoClient mongoClient = MongoClients.create(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoDatabase helloworld = mongoClient.getDatabase(\"helloworld\");\r\n    log.info(\"database == {} \", helloworld.getName());\r\n    MongoCollection<Document> book = helloworld.getCollection(\"book\");\r\n    log.info(\"collection = {} \", book.getNamespace().getCollectionName());\r\n\r\n    log.info(\"Bye Bye. Close ~!!!\");\r\n    mongoClient.close();\r\n  }\r\n}\n위에서 설명했던 MongoClients 클래스를 통해 MongoClient 객체를 생성합니다. 그리고 얻어낸 mongoClient 객체로 database 명을 얻어오고, collection 을 얻어와서 컬렉션 명을 출력하고 있습니다. 접속 주소에는 컬렉션 명과, 데이터베이스 명을 지정하지 않았는데도 잘 읽어오는 것을 보면, MongoClient 는 내부적으로 접속을 위한 통신작업을 한다는 것을 알 수 있습니다.\n출력\n// ...\r\n\r\n19:28:56.824 [main] INFO io...MongoClientExample -- database == helloworld \r\n19:28:56.828 [main] INFO io...MongoClientExample -- collection = book \r\n19:28:56.828 [main] INFO io...MongoClientExample -- Bye Bye. Close ~!!!\n이번에는 조금 복잡한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.ConnectionString;\r\nimport com.mongodb.MongoClientSettings;\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class MongoClientExample2 {\r\n  public static void main(String[] args) {\r\n    var connection = new ConnectionString(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoClientSettings mongoClientSettings = MongoClientSettings.builder()\r\n        .applyConnectionString(connection)\r\n        .build();\r\n\r\n    try(MongoClient mongoClient = MongoClients.create(mongoClientSettings)){\r\n      var database = mongoClient.getDatabase(\"helloworld\");\r\n      log.info(\"database : {}\", database.getName());\r\n\r\n      var collection = database.getCollection(\"book\");\r\n      log.info(\"collection : {}\", collection.getNamespace().getCollectionName());\r\n\r\n      log.info(\"Finish. Bye Bye~!!\");\r\n    }\r\n\r\n  }\r\n}\n내용은 위의 예제와 비슷하므로 설명은 생략하도록 하겠습니다.출력\n// ...\r\n\r\n19:36:06.295 [main] INFO io...MongoClientExample2 -- database : helloworld\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- collection : book\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- Finish. Bye Bye~!!"}},"/spring-data-mongodb-reactive/aggregation-pipeline":{"title":"Aggregation Pipeline","data":{"aggregation-pipeline#Aggregation Pipeline":"Aggregation Pipeline 을 spring data mongodb reactive 기반으로 작성할 때에는 @Aggregation 을 사용해서 작성하는 방식이 있고, MongoTemplate 을 이용해 Java 코드를 작성하는 방식도 있습니다. 이번 문서에서는 두가지 예제를 모두 정리합니다.\n@Aggregation 을 이용한 방식\nMongoTemplate 을 이용해 Aggregation 을 수행하는 방식","참고자료#참고자료":"@Aggregation 관련 자료들\nSpring Data Reactive MongoDB aggregation pipeline , github - spring-reactve-mongodb-aggregation\nInvoiceRepository.java\nInvoiceCountSummary.java\nInvoice.java\nsrc/main/resources/initdb/invoice.js\nAggregation Query\nmongodb.com - MongoDB Aggregation Operations\n$count(aggregation accumulator)\n$sum(aggregation)\nMongo group and push: pushing all fields\nhow to use mongodb aggregate and retrieve entire documents\nMongoDB Aggregation error : Pipeline stage specification object must contain exactly one field\n$group (aggregation)\nLearn How to Use Group in MongoDB Aggregation Pipeline\nSpring Data MongoDB BigDecimal Support\nSpring Data MongoDB BigDecimal support\njsonobject.tistory.com/466","aggregation-이란#Aggregation 이란?":"","샘플-데이터#샘플 데이터":"이번 예제에서 사용할 샘플 데이터는 아래와 같습니다. helloworld 라는 데이터베이스가 있고 이 데이터베이스 안의 book 이라는 컬렉션을 예제로 사용합니다. 그리고 데이터를 자세히 보면, \"바람과 함께 사라지다\" 라는 책이 다양한 종류로 존재하며 가격은 10000, 15000, 20000, 25000, 30000 원대가 있으며, 판매 상태는 SOLD_OUT, FOR_SALE 이 존재함을 알 수 있습니다.","aggregation-pipeline-1#Aggregation pipeline":"오늘 Java 코드로 구현해볼 Aggregation pipeline 은 아래와 같습니다.10000원 ~ 25000원 사이의 가격이면서, saleStatus 가 FOR_SALE 인 것은 몇개인지, SOLD_OUT 인 것은 몇개인지 집계 코드를 통해 체크하는 예제입니다.\n[\r\n  {\r\n  \t$match: {\r\n    \tprice: {\r\n      \t$gte: 10000,\r\n      \t$lte: 25000\r\n    \t}\r\n  \t}\r\n\t},\r\n  {\r\n    $group: {\r\n    \t_id: {saleStatus: '$saleStatus'},\r\n    \tcnt: {$count:{}},\r\n  \t}\r\n  },\r\n  {\r\n    $project: {\r\n      status: '$_id.saleStatus',\r\n      cnt: '$cnt'\r\n    }\r\n  }\r\n]\n이 Aggregation pipeline 을 실행한 결과는 아래와 같습니다.","mongotemplate-설정#MongoTemplate 설정":"","mongoreactiveconfigurationjava#MongoReactiveConfiguration.java":"설명은 생략하겠습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport org.bson.json.StrictJsonWriter;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\n\r\n@Configuration\r\npublic class MongoReactiveConfiguration {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n\r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory dbFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(dbFactory);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    // 이렇게 할 수도 있지만, 하나의 프로젝트에서 여러 몽고 database 를 사용할 수 있으므로 비활성화\r\n//    String database = mongoProperties.getMongoClientDatabase();\r\n    final String database = \"helloworld\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate helloworldReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(helloworldReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n\r\n  @Bean\r\n  public MongoCustomConversions mongoCustomConversions(){\r\n    return new MongoCustomConversions(\r\n        Arrays.asList(\r\n            new BigDecimalToDecimal128Converter(),\r\n            new Decimal128ToBigDecimalConverter()\r\n        )\r\n    );\r\n  }\r\n\r\n}","bigdecimaltodecimal128converterjava#BigDecimalToDecimal128Converter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n\r\npublic class BigDecimalToDecimal128Converter implements Converter<BigDecimal, Decimal128> {\r\n  @Override\r\n  public Decimal128 convert(BigDecimal source) {\r\n    return source == null ? null : new Decimal128(source);\r\n  }\r\n}","decimal128tobigdecimalconverterjava#Decimal128ToBigDecimalConverter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n\r\npublic class Decimal128ToBigDecimalConverter implements Converter<Decimal128, BigDecimal> {\r\n  @Override\r\n  public BigDecimal convert(Decimal128 source) {\r\n    return source == null ? null : source.bigDecimalValue();\r\n  }\r\n}","repository-scan-설정#Repository Scan 설정":"MongodbReactiveExampleApplication.java\npackage io.chagchagchag.example_mongo.mongodb_reactive_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;\r\n\r\n@EnableReactiveMongoRepositories(\r\n\t\tbasePackages = {\r\n\t\t\t\t\"io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book\",\r\n\t\t},\r\n\t\treactiveMongoTemplateRef = \"helloworldReactiveMongoTemplate\"\r\n)\r\n@SpringBootApplication\r\npublic class MongodbReactiveExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(MongodbReactiveExampleApplication.class, args);\r\n\t}\r\n\r\n}","document#Document":"Document 는 아래와 같습니다. 설명은 생략합니다.","bookdocumentjava#BookDocument.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.Getter;\r\nimport org.bson.types.ObjectId;\r\nimport org.springframework.data.mongodb.core.mapping.Document;\r\nimport org.springframework.data.mongodb.core.mapping.Field;\r\nimport org.springframework.data.mongodb.core.mapping.FieldType;\r\n\r\n@Getter\r\n@Document(collection = \"book\")\r\npublic class BookDocument {\r\n  private ObjectId id;\r\n  private String name;\r\n  @Field(targetType = FieldType.DECIMAL128)\r\n  private BigDecimal price;\r\n  private LocalDateTime publishedAt;\r\n  private SaleStatus saleStatus;\r\n}","aggregation-을-이용한-코드#@Aggregation 을 이용한 코드":"","bookdocumentaggregaterepositoryjava#BookDocumentAggregateRepository.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.ReactiveMongoRepository;\r\nimport reactor.core.publisher.Flux;\r\n\r\npublic interface BookDocumentAggregateRepository extends ReactiveMongoRepository<BookDocument, ObjectId> {\r\n  @Aggregation(pipeline = {\r\n      \"{ $match: {price: {$gte: ?0, $lte:  ?1}} }\",\r\n      \"{ $group: {_id:  {saleStatus: '$saleStatus'}, cnt: {$count: {}}}}\",\r\n      \"{ $project:  {status: '$_id.saleStatus', cnt: '$cnt'}}\"\r\n  })\r\n  Flux<BookCountAggregate> aggregateGroupByStatusAndCounting(BigDecimal lowerLimit, BigDecimal upperLimit);\r\n}\n$match : lowerLimit ~ upperLimit 의 범위에 해당하는 데이터들을 찾습니다.\n$group : saleStatus 로 group by 합니다. 그리고 각 Status 별 Counting 을 합니다.\n$project : 반환값인 BookCountAggregate 에 맞게끔 projection 을 하는 표현식입니다.\n위 코드에서 사용한 BookCountAggregate 는 아래와 같습니다.","bookcountaggregatejava#BookCountAggregate.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\npublic record BookCountAggregate (\r\n    String status,\r\n    Double cnt\r\n){\r\n}","bookdocumentaggregationtestjava#BookDocumentAggregationTest.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.aggregation;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentAggregateRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.util.DelayUtil;\r\nimport java.math.BigDecimal;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n// TODO : 문서작업 모두 끝나고 나면 TestContainers 버전으로 전환하기\r\n@SpringBootTest\r\npublic class BookDocumentAggregationTest {\r\n  private Logger log = LoggerFactory.getLogger(BookDocumentAggregationTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n\r\n  @Autowired\r\n  private BookDocumentAggregateRepository bookDocumentAggregateRepository;\r\n  \r\n  @DisplayName(\"REMOTE_AGGREGATION_PIPELINE_책_제목으로_검색한_결과에_대해_SALE_STATUS_별_카운팅_집계를_수행\")\r\n  @Test\r\n  public void TEST_REMOTE_AGGREGATION_PIPELINE_책_제목으로_검색한_결과에_대해_SALE_STATUS_별_카운팅_집계를_수행(){\r\n    // given\r\n    \r\n    // when\r\n    var b = bookDocumentAggregateRepository\r\n        .aggregateGroupByStatusAndCounting(BigDecimal.valueOf(10000), BigDecimal.valueOf(25000))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    b.stream().forEach(bookCountAggregate -> {\r\n      log.info(\"status = \" + bookCountAggregate.status());\r\n      log.info(\"cnt = \" + bookCountAggregate.cnt());\r\n    });\r\n\r\n    DelayUtil.delayMs(10*1000);\r\n  }\r\n}\n출력결과를 보면 SOLD_OUT, FOR_SALE 상태 각각에 대한 카운팅이 정상적으로 출력되었음을 확인 가능합니다.\n출력결과\n2024-03-31T20:14:58.831+09:00  INFO 494364 --- [mongodb_reactive_example] [           main] .c.e.m.e.b.a.BookDocumentAggregationTest : status = SOLD_OUT\r\n2024-03-31T20:14:58.831+09:00  INFO 494364 --- [mongodb_reactive_example] [           main] .c.e.m.e.b.a.BookDocumentAggregationTest : cnt = 2.0\r\n2024-03-31T20:14:58.831+09:00  INFO 494364 --- [mongodb_reactive_example] [           main] .c.e.m.e.b.a.BookDocumentAggregationTest : status = FOR_SALE\r\n2024-03-31T20:14:58.831+09:00  INFO 494364 --- [mongodb_reactive_example] [           main] .c.e.m.e.b.a.BookDocumentAggregationTest : cnt = 2.0\r\n\r\nProcess finished with exit code 0","mongotemplate-을-이용해-aggregation-을-수행하는-방식#MongoTemplate 을 이용해 Aggregation 을 수행하는 방식":"TODO : 정리 예정"}},"/spring-data-mongodb-reactive/query-methods":{"title":"Query Methods","data":{"query-method#Query Method":"쿼리 메서드는 JPA 에서 지원하는 쿼리메서드 처럼 동작합니디.Spring Data MongoDB Reactive 기반으로 Query Method 를 구현할 때에는 ReactiveMongoRepository, ReactiveSortingRepository 와 같은 Repository interface 들을 상속받아서 구현합니다.예를 들면 아래와 같은 모습입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  Flux<BookDocument> findAllByName(Publisher<String> name);\r\n\r\n  Mono<BookNameDocument> findFirstByName(String name);\r\n\r\n  Mono<Long> deleteByName(String name);\r\n\r\n  Mono<BookDocument> deleteByPriceGreaterThan(BigDecimal price);\r\n\r\n  @Query(\"{'name': ?0}\")\r\n  Flux<BookDocument> findAllByName(String name);\r\n\r\n  @Query(\"{_id:  $0}\")\r\n  @Update(value = \"{$set:  {name: ?1}}\")\r\n  Mono<Integer> updateNameById(String id, String name);\r\n}\nReactiveMongoRepository, ReactiveSortingRepository 등과 같은 Repository 관련 interface 들은 Spring Data MongoDB Reactive 에서는 아래와 같은 상속 구조로 정의되어 있습니다.\n이번 문서에서는 주요 쿼리들을 작성하고 출력결과는 어떻게 되는지 살펴봅니다. testcontainer 를 사용할 수도 있겠지만 환경설정 과정을 정리하는데에 시간이 많이 걸리기에 비교적 간단한 방법으로 문서를 작성하기로 했고, 따라서  원격지에 저장된 데이터를 기준으로 쿼리를 수행했을 때의 출력결과만 표시하는 방식으로 문서를 정리합니다.","예제-데이터#예제 데이터":"이번 예제에서 사용할 샘플 데이터는 아래와 같습니다. helloworld 라는 데이터베이스가 있고 이 데이터베이스 안의 book 이라는 컬렉션을 예제로 사용합니다. 그리고 데이터를 자세히 보면, \"바람과 함께 사라지다\" 라는 책이 다양한 종류로 존재하며 가격은 10000, 15000, 20000, 25000, 30000 원대가 있으며, 판매 상태는 SOLD_OUT, FOR_SALE, HOLD 가 존재함을 알 수 있습니다.","참고#참고":"다른 문서에도 정리해두겠지만, Repository 코드 작성시 인자값의 타입 등에 대해 아래의 규칙을 갖습니다. 아직은 떠오르는게 아래 내용밖에 없기 때문에 추가적으로 생각날때마다 더 추가해두겠습니다.\nenum 타입 : Spring Data MongoDB 에서 Enum 타입은 별도로 Converting 이 필요 없고, String 으로 변환되어 데이터베이스에 추가/수정되고, String 타입은 Enum 타입으로 변환되어 읽어들일 수 있습니다.\nBigDecimal 타입 : Spring Data MongoDB 에서 BigDecimal 타입은 별도의 Converter 코드를 작성해야 합니다. 아래에 제공하는 설정 코드에서 그 내용을 확인 가능합니다.","mongotemplate-설정#MongoTemplate 설정":"","mongoreactiveconfigurationjava#MongoReactiveConfiguration.java":"설명은 생략하겠습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport org.bson.json.StrictJsonWriter;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\n\r\n@Configuration\r\npublic class MongoReactiveConfiguration {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n\r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory dbFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(dbFactory);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    // 이렇게 할 수도 있지만, 하나의 프로젝트에서 여러 몽고 database 를 사용할 수 있으므로 비활성화\r\n//    String database = mongoProperties.getMongoClientDatabase();\r\n    final String database = \"helloworld\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n\r\n  @Bean(name = \"helloworldReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate helloworldReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(helloworldReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n\r\n  @Bean\r\n  public MongoCustomConversions mongoCustomConversions(){\r\n    return new MongoCustomConversions(\r\n        Arrays.asList(\r\n            new BigDecimalToDecimal128Converter(),\r\n            new Decimal128ToBigDecimalConverter()\r\n        )\r\n    );\r\n  }\r\n\r\n}","bigdecimaltodecimal128converterjava#BigDecimalToDecimal128Converter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n\r\npublic class BigDecimalToDecimal128Converter implements Converter<BigDecimal, Decimal128> {\r\n  @Override\r\n  public Decimal128 convert(BigDecimal source) {\r\n    return source == null ? null : new Decimal128(source);\r\n  }\r\n}","decimal128tobigdecimalconverterjava#Decimal128ToBigDecimalConverter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n\r\npublic class Decimal128ToBigDecimalConverter implements Converter<Decimal128, BigDecimal> {\r\n  @Override\r\n  public BigDecimal convert(Decimal128 source) {\r\n    return source == null ? null : source.bigDecimalValue();\r\n  }\r\n}","repository-scan-설정#Repository Scan 설정":"MongodbReactiveExampleApplication.java\npackage io.chagchagchag.example_mongo.mongodb_reactive_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;\r\n\r\n@EnableReactiveMongoRepositories(\r\n\t\tbasePackages = {\r\n\t\t\t\t\"io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book\",\r\n\t\t},\r\n\t\treactiveMongoTemplateRef = \"helloworldReactiveMongoTemplate\"\r\n)\r\n@SpringBootApplication\r\npublic class MongodbReactiveExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(MongodbReactiveExampleApplication.class, args);\r\n\t}\r\n\r\n}","find-연산들#find 연산들":"","eg-1--가격이-가장-높은-책을-조회#e.g. 1 : 가격이 가장 높은 책을 조회":"Repository 코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ...\r\n  \r\n  Mono<BookDocument> findFirstByNameOrderByPriceDesc(String name);\r\n  \r\n  // ...\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\n// ...\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n\r\n  @DisplayName(\"TEST_FIND_QUERY__가격이_가장_높은_책을_조회\")\r\n  @Test\r\n  public void TEST_FIND_QUERY__가격이_가장_높은_책을_조회(){\r\n    // given\r\n\r\n    // when\r\n    BookDocument book = bookDocumentRepository\r\n        .findFirstByNameOrderByPriceDesc(\"바람과 함께 사라지다\")\r\n        .block();\r\n\r\n    // then\r\n    log.info(\"book.name = \" + book.getName());\r\n    log.info(\"book.price = \" + book.getPrice());\r\n    log.info(\"book.saleStatus = \" + book.getSaleStatus());\r\n  }\r\n\r\n}\n출력결과\n2024-03-31T20:42:31.045+09:00  INFO 634464 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다\r\n2024-03-31T20:42:31.045+09:00  INFO 634464 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.price = 30000\r\n2024-03-31T20:42:31.045+09:00  INFO 634464 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.saleStatus = FOR_SALE","eg-2--객체-프로젝션-테스트#e.g. 2 : 객체 프로젝션 테스트":"도큐먼트에서 원하는 필드만 조회해오는 예제입니다.Repository 코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ...\r\n  \r\n  Mono<BookNameDocument> findFirstByNameOrderByPublishedAtDesc(String name);\r\n\r\n  // ...\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookNameDocument;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n  \r\n  // ...\r\n\r\n  @DisplayName(\"FIND_QUERY__프로젝션_테스트_가장_최근에_발간된_책을_1건_조회\")\r\n  @Test\r\n  public void TEST_FIND_QUERY__프로젝션_테스트_가장_최근에_발간된_책을_1건_조회(){\r\n    // given\r\n\r\n    // when\r\n    BookNameDocument bookName = bookDocumentRepository\r\n        .findFirstByNameOrderByPublishedAtDesc(\"바람과 함께 사라지다\")\r\n        .block();\r\n\r\n    // then\r\n    log.info(\"book.name = \" + bookName.getName());\r\n  }\r\n\r\n}\n출력결과\n2024-03-31T22:18:57.051+09:00  INFO 1082904 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다\r\n\r\nProcess finished with exit code 0","delete-연산들#delete 연산들":"delete 연산의 쿼리 메서드는 아래의 규칙을 따릅니다.\n반환형을 Flux<T> 로 선언한 경우 : 삭제한 document 데이터의 시퀀스를 반환\n반환형을 Mono<T> 으로 선언한 경우 : 삭제한 document 를 반환\n반환형을 Mono<Long> 으로 선언한 경우 : 삭제한 document 들의 개수를 반환","eg-1-salestatus-가-hold-이면서-23999-원-이상인-책을-삭제#e.g. 1: SaleStatus 가 HOLD 이면서, 23999 원 이상인 책을 삭제":"Repository 코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ...\r\n  \r\n  Flux<BookDocument> deleteBySaleStatusAndPriceGreaterThan(SaleStatus saleStatus, BigDecimal price);\r\n  \r\n  // ...\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookNameDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n\r\n  // ... \r\n  \r\n  @DisplayName(\"DELETE_QUERY__DELETE_테스트_SALE_STATUS_가_HOLD_이면서_가격이_23999원_이상의_책을_삭제\")\r\n  @Test\r\n  public void TEST_DELETE_QUERY__DELETE_테스트_SALE_STATUS_가_HOLD_이면서_가격이_23999원_이상의_책을_삭제(){\r\n    // given\r\n\r\n    // when\r\n    List<BookDocument> deletedBookList = bookDocumentRepository\r\n        .deleteBySaleStatusAndPriceGreaterThan(SaleStatus.HOLD, BigDecimal.valueOf(23999))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    // then\r\n    log.info(\">>> deleted book list ...\");\r\n    deletedBookList.stream()\r\n        .forEach(bookDocument -> {\r\n          log.info(\"book.name = {}, book.price = {}\", bookDocument.getName(), bookDocument.getPrice());\r\n        });\r\n  }\r\n}\n출력결과\n2024-03-31T23:31:56.619+09:00  INFO 161352 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : >>> deleted book list ...\r\n2024-03-31T23:31:56.619+09:00  INFO 161352 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다, book.price = 25000","eg-2-salestatus-가-hold-인-모든-책을-삭제#e.g. 2: SaleStatus 가 HOLD 인 모든 책을 삭제":"위에서 이미 SaleStatus 가 HOLD 인 책중 23999 원 이상인 책을 삭제했기 때문에, 현재 SaleStatus 가 HOLD 인 책은 1개만 남아있는 상태입니다.이번에는 SaleStatus 가 HOLD 인 모든 데이터를 삭제하는 Query Method 를 테스트해봅니다.Repository코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ...\r\n  \r\n  Mono<BookDocument> deleteBySaleStatus(SaleStatus saleStatus);\r\n  \r\n  // ...\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookNameDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n\r\n  // ...\r\n  \r\n  @DisplayName(\"DELETE_QUERY__DELETE_테스트_SALE_STATUS_가_HOLD_인_모든_도큐먼트_삭제\")\r\n  @Test\r\n  public void TEST_DELETE_QUERY__DELETE_테스트_SALE_STATUS_가_HOLD_인_모든_도큐먼트_삭제(){\r\n    // given\r\n    \r\n    // when\r\n    BookDocument deleted = bookDocumentRepository\r\n        .deleteBySaleStatus(SaleStatus.HOLD)\r\n        .block();\r\n\r\n    // then\r\n    log.info(\">>> deleted book\");\r\n    log.info(\r\n        \"deleted book.name = {}, book.price = {}, book.saleStatus = {}\",\r\n        deleted.getName(), deleted.getPrice(), deleted.getSaleStatus()\r\n    );\r\n  }\r\n  \r\n}\n출력결과\n2024-03-31T23:41:45.278+09:00  INFO 214168 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : >>> deleted book\r\n2024-03-31T23:41:45.279+09:00  INFO 214168 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : deleted book.name = 바람과 함께 사라지다, book.price = 20000, book.saleStatus = HOLD\r\n\r\nProcess finished with exit code 0\n데이터 결과를 보면 아래와 같이 HOLD 인 데이터들이 모두 삭제되어 있습니다.","query#@Query":"이번에는 @Query 를 이용한 쿼리를 살펴봅니다.","eg-1-salestatus-가-for_sale-인-모든-도큐먼트-들을-조회#e.g. 1: SaleStatus 가 FOR_SALE 인 모든 도큐먼트 들을 조회":"Repository 코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ... \r\n\r\n  @Query(\"{saleStatus: ?0}\")\r\n  Flux<BookDocument> findBySaleStatus(SaleStatus saleStatus);\r\n\r\n}\r\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookNameDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n\r\n  // ...\r\n\r\n  @DisplayName(\"QUERY_ANNOTATION__SALE_STATUS_가_FOR_SALE_인_책들을_조회\")\r\n  @Test\r\n  public void TEST_QUERY_ANNOTATION__SALE_STATUS_가_FOR_SALE_인_책들을_조회(){\r\n    // given\r\n\r\n    // when\r\n    List<BookDocument> forSaleBooks = bookDocumentRepository\r\n        .findBySaleStatus(SaleStatus.FOR_SALE)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    // then\r\n    forSaleBooks.forEach(bookDocument -> {\r\n      log.info(\"book.name = {}, book.price = {}, book.saleStatus = {}\",\r\n          bookDocument.getName(),\r\n          bookDocument.getPrice(),\r\n          bookDocument.getSaleStatus());\r\n    });\r\n  }\r\n}\n출력결과\n2024-04-01T00:23:26.691+09:00  INFO 356064 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다, book.price = 20000, book.saleStatus = FOR_SALE\r\n2024-04-01T00:23:26.692+09:00  INFO 356064 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다, book.price = 25000, book.saleStatus = FOR_SALE\r\n2024-04-01T00:23:26.692+09:00  INFO 356064 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 바람과 함께 사라지다, book.price = 30000, book.saleStatus = FOR_SALE","eg-2-salestatus-가-for_sale-인-모든-책들의-이름을-글루코스-혁명-이라는-책-제목으로-업데이트#e.g. 2: SaleStatus 가 FOR_SALE 인 모든 책들의 이름을 글루코스 혁명 이라는 책 제목으로 업데이트":"Repository 코드\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.bson.types.ObjectId;\r\nimport org.reactivestreams.Publisher;\r\nimport org.springframework.data.mongodb.repository.Aggregation;\r\nimport org.springframework.data.mongodb.repository.Query;\r\nimport org.springframework.data.mongodb.repository.Update;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDocumentRepository extends ReactiveSortingRepository<BookDocument, ObjectId> {\r\n  // ...\r\n  \r\n  @Query(\"{saleStatus: ?0}\")\r\n  @Update(value = \"{$set : {name: ?1}}\")\r\n  Mono<Long> updateBookNameBySaleStatus(SaleStatus saleStatus, String toBeChanged);\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.find;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentRepository;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookNameDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport reactor.core.publisher.Flux;\r\nimport reactor.core.publisher.Mono;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentFindTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDocumentFindTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentRepository bookDocumentRepository;\r\n  \r\n  // ...\r\n  \r\n  @DisplayName(\"QUERY_ANNOTATION__SALE_STATUS_가_FOR_SALE_인_책들의_이름을_글루코스_혁명_이라는_제목으로_업데이트\")\r\n  @Test\r\n  public void TEST_QUERY_ANNOTATION__SALE_STATUS_가_FOR_SALE_인_책들의_이름을_글루코스_혁명_이라는_제목으로_업데이트(){\r\n    // given\r\n\r\n    // when\r\n    Long updatedBooks = bookDocumentRepository\r\n        .updateBookNameBySaleStatus(SaleStatus.FOR_SALE, \"글루코스 혁명\")\r\n        .block();\r\n\r\n    List<BookDocument> forSaleBooks = bookDocumentRepository\r\n        .findBySaleStatus(SaleStatus.FOR_SALE)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    // then\r\n    log.info(\"updatedBook count = {}\", updatedBooks);\r\n\r\n    forSaleBooks.forEach(bookDocument -> {\r\n      log.info(\"book.name = {}, book.saleStatus = {}\", bookDocument.getName(), bookDocument.getSaleStatus());\r\n    });\r\n  }\r\n\r\n}\n출력결과\n2024-04-01T00:44:28.497+09:00  INFO 457016 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : updatedBook count = 3\r\n2024-04-01T00:44:28.498+09:00  INFO 457016 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 글루코스 혁명, book.saleStatus = FOR_SALE\r\n2024-04-01T00:44:28.499+09:00  INFO 457016 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 글루코스 혁명, book.saleStatus = FOR_SALE\r\n2024-04-01T00:44:28.499+09:00  INFO 457016 --- [main] i.c.e.m.e.b.find.BookDocumentFindTest    : book.name = 글루코스 혁명, book.saleStatus = FOR_SALE\r\n\r\nProcess finished with exit code 0\nDatabase 내의 결과를 확인해보면 아래와 같이 잘 반영되었음을 확인가능합니다.","querymethod-에서-지원되는-mongodb-query-연산#QueryMethod 에서 지원되는 MongoDB Query 연산":"TODO : 추가 예정"}},"/spring-data-mongodb-reactive/reactive-mongo-template":{"title":"Reactive Mongo Template","data":{"reactivemongotemplate#ReactiveMongoTemplate":"ReactiveMongoTemplate 은 ReactiveMongoOperations, ApplicationContextAware 를 implements 하는 클래스입니다.\nReactiveMongoTemplate 은 MongoConverter, ReactiveMongoDatabaseFactory 를 결합해서 하나의 ReactiveMongoTemplate 객체를 생성하는 방식으로 객체를 생성해서 @Bean 으로 등록하는 경우가 많습니다. 보통 ReactiveMongoTemplate 을 사용하면 MongoDB의 쿼리들을 BSON 형태로 굉장히 다양하게 제공되는 유용한 쿼리를 할수 있고 PojoCodec, CustomCodec 등을 등록하지 않더라도 메소드 체이닝을 통해서 결과값을 Entity 형태로 돌려받을 수 있습니다.ReactiveMongoTemplate 은 쿼리를 통해서 내부적으로 데이터를 변환해서 리턴하려면 ReactiveMongoTemplate 내부에서 MongoCollection 에 접근을 하게 됩니다. 이때 ReactiveMongoDatabaseFactory 객체의 getMongoDatabase() 를 통해서 MongoDatabase 를 얻어오고 MongoCollection 에 접근하게 됩니다.ReactiveMongoOperations 는 굉장히 다양한 연산들을 지원하는 interface 이며, 다음 문서에서 ReactiveMongoOperations 에 대해 자세히 정리합니다.","생성자#생성자":"참고 : ReactiveMongoTemplate.java\nReactiveMongoTemplate 의 생성자는 아래와 같이 4 종류가 있습니다.\npackage org.springframework.data.mongodb.core;\r\n\r\n// ...\r\n\r\npublic class ReactiveMongoTemplate implements ReactiveMongoOperations, ApplicationContextAware {\r\n    public ReactiveMongoTemplate(MongoClient mongoClient, String databaseName) {\r\n\t\t// ...\r\n\t}\r\n    \r\n    public ReactiveMongoTemplate(ReactiveMongoDatabaseFactory mongoDatabaseFactory) {\r\n\t\t// ...\r\n\t}\r\n    \r\n    public ReactiveMongoTemplate(ReactiveMongoDatabaseFactory mongoDatabaseFactory,\r\n\t\t\t@Nullable MongoConverter mongoConverter) {\r\n\t\t// ...\r\n\t}\r\n    \r\n    public ReactiveMongoTemplate(ReactiveMongoDatabaseFactory mongoDatabaseFactory,\r\n\t\t\t@Nullable MongoConverter mongoConverter, Consumer<Throwable> subscriptionExceptionHandler) {\r\n        // ...\r\n    }\r\n}\n첫번째 생성자인 ReactiveMongoTemplate(MongoClient mongoClient, String databaseName) 을 사용하면 단순한 ReactiveMongoTemplate  객체를 생성하는 것이 가능합니다.일반적으로는 두번째 또는 세번째 생성자처럼 ReactiveMongoDatabaseFactory 또는 MongoConverter 를 받아서 ReactiveMongoTemplate 을 생성해서 @Bean 으로 등록하는 경우가 많습니다.","configuration#Configuration":"간단한 ReactiveMongoTemplate 을 설정 코드는 아래와 같습니다. 설명은 생략하겠습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\n\r\n@Configuration\r\npublic class MongoReactiveConfiguration {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n\r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory dbFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(dbFactory);\r\n  }\r\n\r\n  @Bean(name = \"bookReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory bookReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    // 이렇게 할 수도 있지만, 하나의 프로젝트에서 여러 몽고 database 를 사용할 수 있으므로 비활성화\r\n//    String database = mongoProperties.getMongoClientDatabase();\r\n    final String database = \"book\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n\r\n  @Bean(name = \"bookReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate bookReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory bookReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(bookReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n}\n이렇게 생성한 MongoTemplate 은 어떤 MongoTemplate 을 사용할지 아래와 같이 @EnableReactiveMongoRepositories 에 명시해줘야 합니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example;\r\n\r\nimport org.springframework.boot.SpringApplication;\r\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\r\nimport org.springframework.data.mongodb.repository.config.EnableReactiveMongoRepositories;\r\n\r\n@EnableReactiveMongoRepositories(\r\n\t\tbasePackages = {\r\n\t\t\t\t\"io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book\",\r\n\t\t},\r\n\t\treactiveMongoTemplateRef = \"bookReactiveMongoTemplate\"\r\n)\r\n@SpringBootApplication\r\npublic class MongodbReactiveExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(MongodbReactiveExampleApplication.class, args);\r\n\t}\r\n\r\n}","reactivemongodatabasefactory#ReactiveMongoDatabaseFactory":"참고 : ReactiveMongoDatabaseFactory\nReactiveMongoDatabaseFactory 의 코드는 아래와 같습니다. 자세한 코드는 ReactiveMongoDatabaseFactory 를 참고해주시기 바랍니다.\npackage org.springframework.data.mongodb;\r\npublic interface ReactiveMongoDatabaseFactory extends CodecRegistryProvider {\r\n    Mono<MongoDatabase> getMongoDatabase() throws DataAccessException;\r\n\tMono<MongoDatabase> getMongoDatabase(String dbName) throws DataAccessException;\r\n\tPersistenceExceptionTranslator getExceptionTranslator();\r\n\tCodecRegistry getCodecRegistry();\r\n\tMono<ClientSession> getSession(ClientSessionOptions options);\r\n\tReactiveMongoDatabaseFactory withSession(ClientSession session);\r\n\tdefault boolean isTransactionActive() {\r\n\t\treturn false;\r\n\t}\r\n}\ngetMongoDatabase()\nMongoDatabase 객체를 얻어옵니다.\ngetCodecRegistry()\nBson 에서 Java 코드로, Java코드에서 Bson 으로 변환을 수행하는 CodecRegistry 를 반환합니다.\nReactiveMongoTemplate 는 ReactiveMongoDatabaseFactory 객체를 멤버필드로 바인딩하고 있고, MongoDatabase 객체는 ReactiveMongoDatabaseFactory 객체를 통해서 접근 가능하고  MongoCollection 객체는 MongoDatabase 객체를 통해 접근 가능합니다."}},"/spring-data-mongodb-reactive/document-bson-bson-codec":{"title":"Document Bson Bson Codec","data":{"document-bson-bson-codec#Document, BSON, BSON Codec":"","참고자료#참고자료":"mongodb.com/docs/manual/reference/bson-types/\nMongoDB Docs - BSON Types\nmongodb.github.io/mongo-java-driver\nCodecProvider\nQuick Start Pojo\norg.bson.Document","document#Document":"BSON 에서 제공하는 타입에는 Document 라는 타입이 있습니다. 아래와 같이 MongoCollection 에 query 를 통해 조회한 결과는 org.bson.Document 로 변환됩니다.\n이  org.bson.Document 타입은 bson library 에 속하는 타입입니다.\npackage org.bson;\r\n\r\n// ...\r\npublic class Document implements Map<String, Object>, Serializable, Bson {\r\n    private static final Codec<Document> DEFAULT_CODEC =\r\n            withUuidRepresentation(fromProviders(asList(new ValueCodecProvider(),\r\n                    new CollectionCodecProvider(), new IterableCodecProvider(),\r\n                    new BsonValueCodecProvider(), new DocumentCodecProvider(), new MapCodecProvider())), UuidRepresentation.STANDARD)\r\n                    .get(Document.class);\r\n    // ...\r\n    \r\n}","bson#BSON":"참고 : MongoDB Docs - BSON Types\n아래 내용은 MongoDB Docs - BSON Types 의 내용 중 Java 자료형과, Bson 라이브러리에 존재하는 타입들에 대해서만 정리한 내용입니다. (DBPointer, Undefined 등의 타입들은 제외했습니다.)\nBSON Type\tNumber\tJava Type\tDouble\t1\tDouble, Float\tString\t2\tCharacter, String, Enum\tObject\t3\t\tArray\t4\t\tBinary Data\t5\tBinary (bson 라이브러리 지원 타입), byte[]\tObjectId\t7\tObjectId (bson 라이브러리 지원 타입)\tBoolean\t8\tBoolean, AtomicBoolean\tDate\t9\tDate, Instant, LocalDate, LocalDateTime, LocalTime\tNull\t10\t\tRegular Expression\t11\tPattern\tJavaScript\t13\tCode (bson 라이브러리 지원 타입)\t32-bit integer\t16\tInteger, Byte, Short, AtomicInteger\tTimestamp\t17\t\t64-bit integer\t18\tLong, AtomicLong\tDecimal128\t19\tDecimal128 (bson 라이브러리 지원 타입), BigDecimal\tMin Key\t-1\tMinKey (bson 라이브러리 지원 타입)\tMax Key\t127\tMaxKey (bson 라이브러리 지원 타입)","bson-codec#BSON Codec":"예를 들면, MongoDB 로부터 Date 타입으로 전달되는 값을 LocalDate 또는 LocalDateTime 으로 변환해야 할 때가 있습니다. 또는 LocalDate, LocalDateTime 타입을 MongoDB driver 의 bson 라이브러리에서 지원하는 타입으로 변환해야 하는 경우가 있습니다.이런 경우에 보통 기본제공되는 Provider 를 확장(extends) 해서 CodecProvider, Codec 을 직접 정의해서 사용합니다. 이번 섹션에서는 mongodb driver 에서 제공하는 bson 라이브러리의 코덱에는 어떤 것들이 있는지 정리해봅니다.","mongoclientsettingsdefault_codec_registry#MongoClientSettings.DEFAULT_CODEC_REGISTRY":"MongoClientSettings 클래스 내에서는 기본적으로 많이 사용되는 Codec 들의 Registry 를 CodecRegistry 타입의 DEFAULT_CODEC_REGISTRY 라는 필드를 통해 제공합니다.Java 타입 관련 코덱 프로바이더들\nValueCodecProvider, IterableCodecProvider, MapCodecProvider, Jsr310CodecProvider, JsonObjectCodecProvider, JsonObjectCodecProvider, EnumCodecProvider, Jep395RecordCodecProvider, KotlinCodecProvider, CollectionCodecProvider\nBson 타입관련 코덱 프로바이더들\nDBRefCodecProvider,  DBObjectCodecProvider, DocumentCodecProvider, CollectionCodecProvider, GeoJsonCodecProvider, GridFSFileCodecProvider, BsonCodecProvider, ExpressionCodecProvider\n@Immutable\r\npublic final class MongoClientSettings {\r\n    private static final CodecRegistry DEFAULT_CODEC_REGISTRY =\r\n            fromProviders(asList(new ValueCodecProvider(),\r\n                    new BsonValueCodecProvider(),\r\n                    new DBRefCodecProvider(),\r\n                    new DBObjectCodecProvider(),\r\n                    new DocumentCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new CollectionCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new IterableCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new MapCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new GeoJsonCodecProvider(),\r\n                    new GridFSFileCodecProvider(),\r\n                    new Jsr310CodecProvider(),\r\n                    new JsonObjectCodecProvider(),\r\n                    new BsonCodecProvider(),\r\n                    new EnumCodecProvider(),\r\n                    new ExpressionCodecProvider(),\r\n                    new Jep395RecordCodecProvider(),\r\n                    new KotlinCodecProvider()));\r\n    // ...\r\n}\n원래는 위의 코드에 List 내에 대입되는 Provider 객체들을 코드에서 선언한 순서대로 설명을 작성하려 했지만, Java 타입과 BSON 타입 설명이 섞이기 시작하면서 어지러워보여서 Java 타입 프로바이더와 BSON 타입 코덱 프로바이더를 따로 나눠서 정리합니다.","java-타입-코덱-프로바이더#Java 타입 코덱 프로바이더":"ValueCodecProvider (Java)\nJava 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Java 에서 제공하는 클래스\nencode : Java 에 존재하는 타입 → BSON 데이터\nIterableCodecProvider (Java)\nIterable 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → List\nencode : List → BSON 데이터\nMapCodecProvider (Java)\nMap 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Map\nencode : Map → BSON 데이터\nJsr310CodecProvider (Java)\nJava 의 Instant, LocalDate, LocalDateTime 등 Date, Time 등의 시간 관련 타입들을 encode/decode 하기 위한 Codec 객체에 대한 프로바이더 입니다.\ndecode : BSON 데이터 → LocalDate, LocalDateTime\nencode : LocalDate, LocalDateTime → BSON 데이터\nEnumCodecProvider (Java)\nEnum 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Enum\nencode : Enum → BSON 데이터\nJep395RecordCodecProvider : (Java)\nJava 의 Record 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Record\nencode : Record → BSON 데이터\nKotlinCodecProvider : (Java, Kotlin)\nKotlin 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Kotlin\nencode : Kotlin → BSON 데이터\nCollectionCodecProvider\nJava 의 Collection 인터페이스 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\nCollectionCodecProvider 는 interface 이기에, Java 의 Collection 타입 중 Map, Iterable 에 해당하는 것이 없는 등의 경우에 Collection 구현체 → BSON, BSON → Collection 구현체로 변환하는 코드를 직접 작성해야 할 때 사용합니다.\ndecode : BSON 데이터 → Collection 타입 (BSON 라이브러리 내의 타입)\nencode : Collection 타입 (BSON 라이브러리 내의 타입) → BSON 데이터","bson-타입-코덱-프로바이더#BSON 타입 코덱 프로바이더":"주로 mongodb-driver 에서 구현해둔 프로바이더 들입니다. 드라이버 계층에서 mongodb 에서 가져온 bson 데이터를 BSON 라이브러리에서 지원하는 BSON 타입으로 변환하는데에 사용됩니다. 응용 계층 프로그래머가 직접 접근할 일은 드뭅니다.\nJsonObjectCodecProvider\nBSON 라이브러리 내의 JsonObject 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → JsonObject (BSON 라이브러리 내의 타입)\nencode : JsonObject (BSON 라이브러리 내의 타입) → BSON 데이터\nDBRefCodecProvider\nBSON 라이브러리 내의 DBRef 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → DBRef (BSON 라이브러리 내의 타입)\nencode : DBRef (BSON 라이브러리 내의 타입) → BSON 데이터\nDBObjectCodecProvider\nBSON 라이브러리 내의 DBObject 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → DBObject (BSON 라이브러리 내의 타입)\nencode : DBObject (BSON 라이브러리 내의 타입) → BSON 데이터\nDocumentCodecProvider\nBSON 라이브러리 내의 Document 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Document (BSON 라이브러리 내의 타입)\nencode : Document (BSON 라이브러리 내의 타입) → BSON 데이터\nGeoJsonCodecProvider\nBSON 라이브러리 내의 GeoJson 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → GeoJson (BSON 라이브러리 내의 타입)\nencode : GeoJson (BSON 라이브러리 내의 타입) → BSON 데이터\nGridFSFileCodecProvider\nBSON 라이브러리 내의 GridFSFile 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → GridFSFile (BSON 라이브러리 내의 타입)\nencode : GridFSFile (BSON 라이브러리 내의 타입) → BSON 데이터\nBsonCodecProvider\nBSON 라이브러리 내의 Bson 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Bson (BSON 라이브러리 내의 타입)\nencode : Bson (BSON 라이브러리 내의 타입) → BSON 데이터\nExpressionCodecProvider\nBSON 라이브러리 내의 Expression 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Expression (BSON 라이브러리 내의 타입)\nencode : Expression (BSON 라이브러리 내의 타입) → BSON 데이터","예제---valuecodecprovider#예제 - ValueCodecProvider":"이번에 살펴볼 예제는 Mongodb Cloud 내의 helloworld.person 이라는 컬렉션을 획득하고, 도큐먼트를 조회해오는데, 이 도큐먼트의 BSON 데이터를 읽어들여서 Java 의 값으로 변환하는 예제입니다. 그리고 Subscribe 는 reactivestreams 의 Subscriber 를 이용해서 subscribe 하는 예제입니다.예제는 공식 도큐먼트의 Quick Start Pojo 문서를 참고해서 작성한 예제입니다.\n자세한 설명은 생략하도록 하겠습니다.","personjava#Person.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec.valueobject;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.util.Objects;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.bson.codecs.pojo.annotations.BsonId;\r\nimport org.bson.codecs.pojo.annotations.BsonProperty;\r\nimport org.bson.types.ObjectId;\r\n\r\n@Getter @Setter\r\npublic class Person {\r\n  @BsonId\r\n  @BsonProperty(value = \"_id\")\r\n  private ObjectId id;\r\n  @BsonProperty(value = \"name\")\r\n  private String name;\r\n  @BsonProperty(value = \"salary\")\r\n  private BigDecimal salary;\r\n\r\n  @Override\r\n  public int hashCode() {\r\n    return Objects.hash(id, name, salary);\r\n  }\r\n\r\n  @Override\r\n  public boolean equals(Object obj) {\r\n    if(this == obj) return true;\r\n    if(obj == null || getClass() != obj.getClass()) return false;\r\n    Person p = (Person) obj;\r\n    return Objects.equals(id, p.getId())\r\n        && Objects.equals(salary, p.getSalary())\r\n        && Objects.equals(name, p.getName());\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return \"Person{\" +\r\n        \"id=\" + id +\r\n        \", name='\" + name + '\\'' +\r\n        \", salary=\" + salary +\r\n        '}';\r\n  }\r\n}","customvaluecodecprovider#CustomValueCodecProvider":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec;\r\n\r\nimport java.lang.reflect.Type;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport org.bson.BsonReader;\r\nimport org.bson.BsonWriter;\r\nimport org.bson.codecs.Codec;\r\nimport org.bson.codecs.DecoderContext;\r\nimport org.bson.codecs.EncoderContext;\r\nimport org.bson.codecs.ValueCodecProvider;\r\nimport org.bson.codecs.configuration.CodecRegistry;\r\n\r\npublic class CustomValueCodecProvider extends ValueCodecProvider {\r\n  @Override\r\n  public <T> Codec<T> get(Class<T> clazz, List<Type> typeArguments, CodecRegistry registry) {\r\n    if(clazz == BigDecimal.class){\r\n      return new Codec<T>(){\r\n        @Override\r\n        public void encode(BsonWriter bsonWriter, T value, EncoderContext encoderContext) {\r\n          bsonWriter.writeString(((BigDecimal) value).toString());\r\n        }\r\n\r\n        @Override\r\n        public Class<T> getEncoderClass() {\r\n          return (Class<T>) BigDecimal.class;\r\n        }\r\n\r\n        @Override\r\n        public T decode(BsonReader bsonReader, DecoderContext decoderContext) {\r\n          return (T) new BigDecimal(bsonReader.readString());\r\n        }\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}","codecexamplejava#CodecExample.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec;\r\n\r\nimport com.mongodb.ConnectionString;\r\nimport com.mongodb.MongoClientSettings;\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport com.mongodb.reactivestreams.client.MongoCollection;\r\nimport com.mongodb.reactivestreams.client.MongoDatabase;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec.valueobject.Person;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.bson.codecs.configuration.CodecRegistries;\r\nimport org.bson.codecs.configuration.CodecRegistry;\r\nimport org.bson.codecs.pojo.PojoCodecProvider;\r\nimport org.reactivestreams.Subscriber;\r\nimport org.reactivestreams.Subscription;\r\n\r\n@Slf4j\r\npublic class CodecExample {\r\n  public static void main(String[] args) {\r\n    CodecRegistry codecRegistry = CodecRegistries.fromRegistries(\r\n        MongoClientSettings.getDefaultCodecRegistry(),\r\n        CodecRegistries.fromProviders(new CustomValueCodecProvider()),\r\n        CodecRegistries.fromProviders(PojoCodecProvider.builder().automatic(true).build())\r\n    );\r\n\r\n    var connectionString = new ConnectionString(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoClient mongoClient = MongoClients.create(\r\n        MongoClientSettings.builder()\r\n            .codecRegistry(codecRegistry)\r\n            .applyConnectionString(connectionString)\r\n            .build()\r\n    );\r\n\r\n    // Mongodb 데이터베이스 접속, 컬렉션 조회\r\n    MongoDatabase database = mongoClient.getDatabase(\"helloworld\");\r\n    MongoCollection<Person> collection = database.getCollection(\"person\", Person.class);\r\n\r\n    // 도큐먼트 조회\r\n    collection.find().first()\r\n            .subscribe(newSubscriber(1));\r\n  }\r\n\r\n  public static Subscriber<Person> newSubscriber(int requestSize){\r\n    return new Subscriber<Person>() {\r\n      @Override\r\n      public void onSubscribe(Subscription subscription) {\r\n        subscription.request(requestSize);\r\n      }\r\n\r\n      @Override\r\n      public void onNext(Person item) {\r\n        log.info(\"item _id = \" + item.getId());\r\n        log.info(\"item name = \" + item.getName());\r\n        log.info(\"item salary = \" + item.getSalary());\r\n      }\r\n\r\n      @Override\r\n      public void onError(Throwable throwable) {\r\n        throwable.printStackTrace();\r\n      }\r\n\r\n      @Override\r\n      public void onComplete() {\r\n        System.out.println(\"complete\");\r\n      }\r\n    };\r\n  }\r\n}","출력결과#출력결과":"// ... \r\n\r\n13:37:13.545 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item _id = 6606279491b652a088e56be5\r\n13:37:13.546 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item name = 홍길동\r\n13:37:13.546 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item salary = 10000000000\r\ncomplete\r\n\r\n// ..."}},"/spring-data-mongodb-reactive/reactive-mongo-operation":{"title":"Reactive Mongo Operation","data":{"reactivemongooperation#ReactiveMongoOperation":"MongoReactiveMongoTemplate 은 ReactiveMongoOperation 을 implements 합니다. ReactiveMongoOperation 에는 다양한 operation 들을 지원하며 굉장히 유용한 쿼리 함수들이 지원됩니다.ReactiveMongoOperation 은 ReactiveFluentMongoOperation 이라는 interface 를 상속(extends) 하고 있는데, 이 ReactiveFluentMongoOperation 은 아래와 같이 굉장히 다양한 종류의 Operation 들을 extends 하고 있습니다.\nReactiveAggregationOperation\nReactiveChangeStreamOperation\nReactiveFindOperation\nReactiveInsertOperation\nReactiveMapReduceOperation\nReactiveRemoveOperation\nReactiveUpdateOperation\nReactiveMongoOperations 는 이 ReactiveFluentMongoOperation interface 에서 제공하는 다양한 연산 쿼리들을 이용해서 다양한 쿼리를 수행하는 단축형의 메서드 들을 제공합니다. 그중 일부의 코드를 발췌해 요약해보면 아래와 같습니다.\n출처 : ReactiveMongoOperations.java\npackage org.springframework.data.mongodb.core;\r\n// ...\r\n\r\npublic interface ReactiveMongoOperations extends ReactiveFluentMongoOperations {\r\n    <T> Flux<T> findAll(Class<T> entityClass);\r\n\t<T> Flux<T> findAll(Class<T> entityClass, String collectionName);\r\n\t\r\n    <T> Mono<T> findOne(Query query, Class<T> entityClass);\r\n\t<T> Mono<T> findOne(Query query, Class<T> entityClass, String collectionName);\r\n\t\r\n    Mono<Boolean> exists(Query query, String collectionName);\r\n\tMono<Boolean> exists(Query query, Class<?> entityClass);\r\n\tMono<Boolean> exists(Query query, @Nullable Class<?> entityClass, String collectionName);\r\n\t\r\n    <T> Flux<T> find(Query query, Class<T> entityClass);\r\n\t<T> Flux<T> find(Query query, Class<T> entityClass, String collectionName);\r\n\t\r\n    <T> Mono<Window<T>> scroll(Query query, Class<T> entityType);\r\n\t<T> Mono<Window<T>> scroll(Query query, Class<T> entityType, String collectionName);\r\n\t\r\n    <T> Mono<T> findById(Object id, Class<T> entityClass);\r\n\t<T> Mono<T> findById(Object id, Class<T> entityClass, String collectionName);\r\n\t\r\n    default <T> Flux<T> findDistinct(String field, Class<?> entityClass, Class<T> resultClass) {\r\n\t\treturn findDistinct(new Query(), field, entityClass, resultClass);\r\n\t}\r\n    \r\n    \r\n    <O> Flux<O> aggregate(TypedAggregation<?> aggregation, String collectionName, Class<O> outputType);\r\n    <O> Flux<O> aggregate(TypedAggregation<?> aggregation, Class<O> outputType);\r\n\t<O> Flux<O> aggregate(Aggregation aggregation, Class<?> inputType, Class<O> outputType);\r\n\t<O> Flux<O> aggregate(Aggregation aggregation, String collectionName, Class<O> outputType);\r\n    \r\n    \r\n\t<T> Mono<T> findAndModify(Query query, UpdateDefinition update, Class<T> entityClass);\r\n\t<T> Mono<T> findAndModify(Query query, UpdateDefinition update, Class<T> entityClass, String collectionName);\r\n\t<T> Mono<T> findAndModify(Query query, UpdateDefinition update, FindAndModifyOptions options, Class<T> entityClass);\r\n\t<T> Mono<T> findAndModify(Query query, UpdateDefinition update, FindAndModifyOptions options, Class<T> entityClass,\r\n\t\t\tString collectionName);\r\n\r\n    // ...\r\n    \r\n\t<S, T> Mono<T> findAndReplace(Query query, S replacement, FindAndReplaceOptions options, Class<S> entityType,\r\n\t\t\tString collectionName, Class<T> resultType);\r\n    \r\n    // ...\r\n    \r\n\t<T> Mono<T> findAndRemove(Query query, Class<T> entityClass);\r\n\t<T> Mono<T> findAndRemove(Query query, Class<T> entityClass, String collectionName);\r\n    \r\n\tMono<Long> count(Query query, Class<?> entityClass);\r\n\tMono<Long> count(Query query, String collectionName);\r\n\tMono<Long> count(Query query, @Nullable Class<?> entityClass, String collectionName);\r\n\r\n    \r\n\tMono<Long> estimatedCount(String collectionName);\r\n    // ...\r\n}","reactivefluentmongooperations#ReactiveFluentMongoOperations":"ReactiveFluentMongoOperation 은 아래와 같이 굉장히 다양한 종류의 Operation 들을 extends 하고 있습니다.\nReactiveAggregationOperation\nReactiveChangeStreamOperation\nReactiveFindOperation\nReactiveInsertOperation\nReactiveMapReduceOperation\nReactiveRemoveOperation\nReactiveUpdateOperation","reactiveinsertoperation#ReactiveInsertOperation":"TODO : 다른 작업 완료 후 작업 예정","reactivefindoperation#ReactiveFindOperation":"TODO : 다른 작업 완료 후 작업 예정","reactiveupdateoperation#ReactiveUpdateOperation":"TODO : 다른 작업 완료 후 작업 예정","reactiveremoveoperation#ReactiveRemoveOperation":"TODO : 다른 작업 완료 후 작업 예정","reactiveaggregationoperation#ReactiveAggregationOperation":"TODO : 다른 작업 완료 후 작업 예정","reactivechangestreamoperation#ReactiveChangeStreamOperation":"TODO : 다른 작업 완료 후 작업 예정"}},"/spring-data-mongodb-reactive/reactive-mongo-repository":{"title":"Reactive Mongo Repository","data":{"reactivemongorepository#ReactiveMongoRepository":"MongoDB의 쿼리를 작성할 때 spring data mongodb 의 repository 를 기반으로 쿼리를 하려고 할 때 흔히 ReactiveMongoRepository 타입의 interface 에 대해 repository 코드를 작성합니다. 이 ReactiveMongoRepository 는 SimpleReactiveMongoRepository 라는 클래스가 구체타입으로 등록됩니다.이 SimpleReactiveMongoRepository 클래스를 중심으로 상속관계를 그림으로 표현해보면 아래와 같습니다.\nReactiveMongoRepository<T,ID>\nReactiveQueryByExampleExecutor<T>\nReactiveCrudRepository<T,ID>\nReactiveSortingRepository<T,ID>\nRepository<T,ID>\n참고 : SimpleReactiveMongoRepository","component-scan#Component Scan":"MongoDB와 R2DBC 를 함께 사용하는 경우 아래와 같은 방식으로 설정을 해줍니다.\n@EnableR2dbcRepositories(\r\n    basePackages = {\"...\"}\r\n)\r\n@EnableReactiveMongoRepositories(\r\n    basePackages = \"io.chagchagchag.example.example_mongo.repository\",\r\n    reactiveMongoTemplateRef = \"reactiveMongoTemplate\"\r\n)\r\n@Configuration\r\npublic class ReactiveMongoConfig {\r\n    // ...\r\n}\n이렇게 명시적으로 @EnableReactiveMongoRepositories 를 지정하는 이유는 서버 애플리케이션 개발자가 선언한 Repository 들을 스프링이 컴포넌트 스캔을 할 때 스프링 컨테이너 입장에서는 이 것들을 일일이 MongoDB인지 R2DBC 인지 구별해낼 수 있는 방법이 명확하지 않습니다. 이런 이유로 인해 위와 같이 MongoDB Repository 는 위의 패키지 들에 있다고 명시해줄 수 있는 @EnableReactiveMongoRepositories 를 통해 컴포넌트 스캔을 수행할 패키지 경로를 명시해줍니다.이런 이유 외에도 멀티 모듈 기반으로 프로젝트를 구성할 때, 어떤 모듈에서 다른 모듈에 속한 Data 모듈을 읽어와야 하는데, 이런 경우에 위와같이 @Enable***Repositories 애노테이션을 통해 컴포넌트 스캔할 리포지터리들을 명시하도록 선언하고 정의합니다.","simplereactivemongorepository#SimpleReactiveMongoRepository":"SimpleReactiveMongoRepository 는 ReactiveMongoRepository 를 implements 하고 있는 클래스입니다.\n참고 : SimpleReactiveMongoRepository.java\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\tprivate @Nullable CrudMethodMetadata crudMethodMetadata;\r\n\tprivate final MongoEntityInformation<T, ID> entityInformation;\r\n\tprivate final ReactiveMongoOperations mongoOperations;\r\n    \r\n    // ...\r\n    \r\n}\n위의 코드를 보면 멤버 필드로 ReactiveMongoOperations 를 바인딩하고 있습니다. 즉, ReactiveMongoOperations 를 기반으로 복잡한 쿼리들을 고수준으로 래핑해서 제공하고 있다는 사실을 알 수 있습니다.","save-연산-insert-update-연산#save 연산 (insert, update 연산)":"참고 : SimpleReactiveMongoRepository.java\nSimpleReactiveMongoRepository.java 내에서 save(), saveAll() 의 구현은 아래와 같습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\tprivate @Nullable CrudMethodMetadata crudMethodMetadata;\r\n\tprivate final MongoEntityInformation<T, ID> entityInformation;\r\n\tprivate final ReactiveMongoOperations mongoOperations;\r\n    \r\n    // ...\r\n    \r\n    @Override\r\n\tpublic <S extends T> Mono<S> save(S entity) {\r\n\r\n\t\tAssert.notNull(entity, \"Entity must not be null\");\r\n\r\n\t\tif (entityInformation.isNew(entity)) {\r\n\t\t\treturn mongoOperations.insert(entity, entityInformation.getCollectionName());\r\n\t\t}\r\n\r\n\t\treturn mongoOperations.save(entity, entityInformation.getCollectionName());\r\n\t}\r\n\r\n\t@Override\r\n\tpublic <S extends T> Flux<S> saveAll(Iterable<S> entities) {\r\n\r\n\t\tAssert.notNull(entities, \"The given Iterable of entities must not be null\");\r\n\r\n\t\tStreamable<S> source = Streamable.of(entities);\r\n\r\n\t\treturn source.stream().allMatch(entityInformation::isNew) ? //\r\n\t\t\t\tmongoOperations.insert(source.stream().collect(Collectors.toList()), entityInformation.getCollectionName()) : //\r\n\t\t\t\tFlux.fromIterable(entities).flatMap(this::save);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic <S extends T> Flux<S> saveAll(Publisher<S> entityStream) {\r\n\r\n\t\tAssert.notNull(entityStream, \"The given Publisher of entities must not be null\");\r\n\r\n\t\treturn Flux.from(entityStream).flatMapSequential(entity -> entityInformation.isNew(entity) ? //\r\n\t\t\t\tmongoOperations.insert(entity, entityInformation.getCollectionName()) : //\r\n\t\t\t\tmongoOperations.save(entity, entityInformation.getCollectionName()));\r\n\t}\r\n    \r\n}","save#save()":"package org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n    // ...\r\n    \r\n    @Override\r\n\tpublic <S extends T> Mono<S> save(S entity) {\r\n\r\n\t\tAssert.notNull(entity, \"Entity must not be null\");\r\n\r\n\t\tif (entityInformation.isNew(entity)) {\r\n\t\t\treturn mongoOperations.insert(entity, entityInformation.getCollectionName());\r\n\t\t}\r\n\r\n\t\treturn mongoOperations.save(entity, entityInformation.getCollectionName());\r\n\t}\r\n    \r\n    // ...\r\n    \r\n}\n새로운 Entity 일 경우 INSERT 수행, 새로운 Entity 가 아닐 경우 UPDATE 수행 (_id 필드가 null 이면 new 를 수행)\nJPA 를 스터디 할 때 흔히 Persistable 을 통해 변경감지하는 로직을 공부한 분들이 많으실 겁니다.\nSpring Data Mongodb Reactive 에서도 isNew 인지를 검사한 후 새로운 entity 라는 판단이 들면 (주로 _id 가 null 인지로 판별) insert 를 수행합니다.\nDatabase 에서 해당 key 를 읽어온 후 새로운 entity 인지를 체크하는 로직을 통해 isNew() 를 판정하게끔 하려면, 별도로 isNew() 함수를 Entity(@Document 가 적용된 클래스)에 Override 하셔야 합니다. isNew() 는 Persistable 인터페이스의 명세 중 하나입니다. 이렇게 IO 작업을 isNew() 에 적용할지 고민하는 경우에는 차라리 가급적 Upsert 쿼리를 따로 작성하시길 권장 드립니다.","saveall#saveAll()":"Spring Data MongoDB Reactive 의 saveAll() 연산이 R2DBC 와 다른 점은 @Transactional 이 붙어있지 않다는 점입니다. 따라서 여러 개의 데이터를 saveAll() 로 처리 시에 UncheckedException 이 발생되어 롤백되어야 하는 상황일 경우 UncheckedException 이 발생하기 직전까지 save() 했던 데이터는 유지되므로 트랜잭션의 원자성을 확보하기는 어렵습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t// ...\r\n    \r\n\t@Override\r\n\tpublic <S extends T> Flux<S> saveAll(Iterable<S> entities) {\r\n\r\n\t\tAssert.notNull(entities, \"The given Iterable of entities must not be null\");\r\n\r\n\t\tStreamable<S> source = Streamable.of(entities);\r\n\r\n\t\treturn source.stream().allMatch(entityInformation::isNew) ? //\r\n\t\t\t\tmongoOperations.insert(source.stream().collect(Collectors.toList()), entityInformation.getCollectionName()) : //\r\n\t\t\t\tFlux.fromIterable(entities).flatMap(this::save);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic <S extends T> Flux<S> saveAll(Publisher<S> entityStream) {\r\n\r\n\t\tAssert.notNull(entityStream, \"The given Publisher of entities must not be null\");\r\n\r\n\t\treturn Flux.from(entityStream).flatMapSequential(entity -> entityInformation.isNew(entity) ? //\r\n\t\t\t\tmongoOperations.insert(entity, entityInformation.getCollectionName()) : //\r\n\t\t\t\tmongoOperations.save(entity, entityInformation.getCollectionName()));\r\n\t}\r\n    \r\n}\nList 같은 Collection, Flux 같은 Publisher 처럼 여러개의 데이터 또는 여러 데이터의 흐름에 대해 아래의 연산을 수행합니다.\n모든 데이터가 isNew() == true 일 경우 :  MongoOperations 를 이용해서 insert 를 수행합니다.\n이 외의 경우 : 각각의 데이터에 대해 개별적으로 save() 를 수행합니다.","조회-연산-find-연산#조회 연산 (find 연산)":"참고 : SimpleReactiveMongoRepository.java\nSimpleReactiveMongoRepository.java 내에서 findById(), existsById(), findAll(), count() 의 구현은 아래와 같습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t// ...\r\n    \r\n\t@Override\r\n\tpublic Mono<T> findById(ID id) {\r\n\r\n\t\tAssert.notNull(id, \"The given id must not be null\");\r\n\r\n\t\tQuery query = getIdQuery(id);\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.findOne(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t}\r\n    \r\n    // 같은 이름, 비슷한 용도의 메소드 오버로딩 메서드 들은 생략 ...\r\n    \r\n\t@Override\r\n\tpublic Mono<Boolean> existsById(ID id) {\r\n\r\n\t\tAssert.notNull(id, \"The given id must not be null\");\r\n\r\n\t\tQuery query = getIdQuery(id);\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.exists(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t}\r\n\r\n\t// 같은 이름, 비슷한 용도의 메소드 오버로딩 메서드 들은 생략 ...\r\n\r\n\t@Override\r\n\tpublic Flux<T> findAll() {\r\n\t\treturn findAll(new Query());\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Flux<T> findAllById(Iterable<ID> ids) {\r\n\r\n\t\tAssert.notNull(ids, \"The given Iterable of Id's must not be null\");\r\n\r\n\t\treturn findAll(getIdQuery(ids));\r\n\t}\r\n\r\n\t// 같은 이름, 비슷한 용도의 메소드 오버로딩 메서드 들은 생략 ...\r\n\r\n\t@Override\r\n\tpublic Mono<Long> count() {\r\n\r\n\t\tQuery query = new Query();\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.count(query, entityInformation.getCollectionName());\r\n\t}\r\n    \r\n}","findbyid#findById()":"findById() 메서드의 내부입니다. 특별한 점은 없고, MongoOperations 객체로 저수준의 Query 가 findById() 에 맞도록 구성되어 있다는 사실을 알 수 있습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t\r\n    // ...\r\n    \r\n\t@Override\r\n\tpublic Mono<T> findById(ID id) {\r\n\r\n\t\tAssert.notNull(id, \"The given id must not be null\");\r\n\r\n\t\tQuery query = getIdQuery(id);\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.findOne(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t}\r\n    \r\n    // ...\r\n    \r\n    private Query getIdQuery(Object id) {\r\n\t\treturn new Query(getIdCriteria(id));\r\n\t}\r\n    \r\n}","existsbyid#existsById()":"existsById() 메서드의 내부입니다. 특별한 점은 없고, MongoOperations 객체로 저수준의 Query 가 existsById() 에 맞도록 구성되어 있다는 사실을 알 수 있습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t\r\n    // ...\r\n    \r\n\t@Override\r\n\tpublic Mono<Boolean> existsById(ID id) {\r\n\r\n\t\tAssert.notNull(id, \"The given id must not be null\");\r\n\r\n\t\tQuery query = getIdQuery(id);\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.exists(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Mono<Boolean> existsById(Publisher<ID> publisher) {\r\n\r\n\t\tAssert.notNull(publisher, \"The given id must not be null\");\r\n\t\tOptional<ReadPreference> readPreference = getReadPreference();\r\n\r\n\t\treturn Mono.from(publisher).flatMap(id -> {\r\n\t\t\tQuery query = getIdQuery(id);\r\n\t\t\treadPreference.ifPresent(query::withReadPreference);\r\n\t\t\treturn mongoOperations.exists(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t\t});\r\n\t}\r\n    \r\n    private Query getIdQuery(Object id) {\r\n\t\treturn new Query(getIdCriteria(id));\r\n\t}\r\n    \r\n}","findall#findAll()":"findAll() 메서드의 내부입니다. 특별한 점은 없고, MongoOperations 객체로 저수준의 Query 가 findAll() 에 맞도록 구성되어 있다는 사실을 알 수 있습니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t\r\n    // ...\r\n    \r\n\t@Override\r\n\tpublic Flux<T> findAll() {\r\n\t\treturn findAll(new Query());\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Flux<T> findAllById(Iterable<ID> ids) {\r\n\r\n\t\tAssert.notNull(ids, \"The given Iterable of Id's must not be null\");\r\n\r\n\t\treturn findAll(getIdQuery(ids));\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Flux<T> findAllById(Publisher<ID> ids) {\r\n\r\n\t\tAssert.notNull(ids, \"The given Publisher of Id's must not be null\");\r\n\r\n\t\tOptional<ReadPreference> readPreference = getReadPreference();\r\n\t\treturn Flux.from(ids).buffer().flatMapSequential(listOfIds -> {\r\n\t\t\tQuery query = getIdQuery(listOfIds);\r\n\t\t\treadPreference.ifPresent(query::withReadPreference);\r\n\t\t\treturn mongoOperations.find(query, entityInformation.getJavaType(), entityInformation.getCollectionName());\r\n\t\t});\r\n\t}\r\n    \r\n    // ...\r\n    \r\n    private Query getIdQuery(Iterable<? extends ID> ids) {\r\n\t\treturn new Query(where(entityInformation.getIdAttribute()).in(toCollection(ids)));\r\n\t}\r\n    \r\n}","count#count()":"MongoOperations 객체를 이용해서 Count 쿼리를 수행하고 있다는 사실을 확인 가능합니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t\r\n    // ...\r\n    \r\n\t@Override\r\n\tpublic Mono<Long> count() {\r\n\r\n\t\tQuery query = new Query();\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.count(query, entityInformation.getCollectionName());\r\n\t}\r\n    \r\n    // ...\r\n    \r\n}","삭제-연산-delete-연산#삭제 연산 (delete 연산)":"delete 관련된 연산은 종류가 많습니다. 그중 deleteById(), deleteAllById() 를 살펴보면 아래와 같습니다. 주의할 점은 deleteAllById() 에 @Transactional 이 적용되어 있지 않다는 점을 주의해야 합니다.\npackage org.springframework.data.mongodb.repository.support;\r\n\r\n// ...\r\n\r\npublic class SimpleReactiveMongoRepository<T, ID extends Serializable> implements ReactiveMongoRepository<T, ID> {\r\n\t\r\n    // ...\r\n    \r\n\t@Override\r\n\tpublic Mono<Void> deleteById(ID id) {\r\n\r\n\t\tAssert.notNull(id, \"The given id must not be null\");\r\n\r\n\t\treturn deleteById(id, getReadPreference());\r\n\t}\r\n    \r\n    // ...\r\n    \r\n    @Override\r\n\tpublic Mono<Void> deleteAllById(Iterable<? extends ID> ids) {\r\n\r\n\t\tAssert.notNull(ids, \"The given Iterable of Id's must not be null\");\r\n\r\n\t\tQuery query = getIdQuery(ids);\r\n\t\tgetReadPreference().ifPresent(query::withReadPreference);\r\n\t\treturn mongoOperations.remove(query, entityInformation.getJavaType(), entityInformation.getCollectionName()).then();\r\n\t}\r\n    \r\n}"}},"/spring-data-mongodb-reactive/transactional-transactional-operator":{"title":"Transactional Transactional Operator","data":{"transactional-transactionaloperator#Transactional, TransactionalOperator":"Spring Data MongoDB Reactive 에서 Transactional 기반의 연산을 하는 방식은 아래와 같이 두가지 입니다.\n@Transactional 애노테이션을 사용하는 방식\nTransactionalOperator 를 사용하는 방식\ntransactional() 메서드 사용\nexecute() 메서드 사용\n트랜잭션을 제대로 처음부터 공부해보신 분들이라면, 우리가 @Transactional 을 통해서 작성한 비즈니스 로직은 스프링 트랜잭션 코드 내에서 람다 형태로 콜백처럼 넘겨진다는 사실을 알고 계실 듯 합니다. 이 개념을 설명하려면 굉장히 많은 스토리를 들어서 설명해야 해서 동작 원리에 대해서 설명하는 것은 이번 문서에서는 건너뜁니다.이렇게 람다 형태로 비즈니스 로직을 스프링 트랜잭션 계층에 넘겨주면 스프링 트랜잭션은 이 람다 형태의 비즈니스 로직을 실행 전에 트랜잭션을 열고, 실행을 마친 후 트랜잭션을 닫는 동작을 내부적으로 수행해줍니다. 트랜잭션을 열고 닫는 일종의 보일러플레이트 코드를 체계화 한 것이라고 볼 수 있습니다. 사람이 직접 이런 코드를 작성한다면, 실수가 생길 수 있기 때문에 스프링의 트랜잭션 기능은 이런 휴먼에러를 방지할 수 있도록 친절한 코드를 가지고 있는 편입니다.이번문서에서는 @Transactional 을 이용한 전통적인 선언적인 방식의 트랜잭션 수행방식과, transactional() 메서드 또는 execute() 를 이용한 함수형 트랜잭션 수행방식을 살펴봅니다.","document-객체-생성-코드#Document 객체 생성 코드":"객체 생성을 테스트하기 때문에 아래와 같이 Document 객체를 구성하고, 생성자를 준비해두었습니다. 현재 시점에서 @PersistenceCreator 는 Spring Data MongoDB Reactive 의 버전에 따라서 상이하게 동작하기에 가급적이면 @PersistenceCreator 를 사용하기보다는 비즈니스 로직에 맞는 팩토리 메서드 또는 팩토리 메서드를 모아둔 컴포넌트를 자체적으로 정의하는 것을 추천드립니다.","bookdocumentjava#BookDocument.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.AccessLevel;\r\nimport lombok.Getter;\r\nimport lombok.NoArgsConstructor;\r\nimport org.bson.types.ObjectId;\r\nimport org.springframework.data.mongodb.core.mapping.Document;\r\nimport org.springframework.data.mongodb.core.mapping.Field;\r\nimport org.springframework.data.mongodb.core.mapping.FieldType;\r\n\r\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\r\n@Getter\r\n@Document(collection = \"book\")\r\npublic class BookDocument {\r\n  private ObjectId id;\r\n  private String name;\r\n  @Field(targetType = FieldType.DECIMAL128)\r\n  private BigDecimal price;\r\n  private LocalDateTime publishedAt;\r\n  private SaleStatus saleStatus;\r\n  \r\n  public BookDocument(\r\n    ObjectId id,\r\n    String name,\r\n    BigDecimal price,\r\n    LocalDateTime publishedAt,\r\n    SaleStatus saleStatus\r\n  ){\r\n    this.id = id;\r\n    this.name = name;\r\n    this.price = price;\r\n    this.publishedAt = publishedAt;\r\n    this.saleStatus = saleStatus;\r\n  }\r\n}","bookdocumentfactoryjava#BookDocumentFactory.java":"이해하기 쉬운 코드이기 때문에 설명은 건너뛰도록 하겠습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport org.bson.types.ObjectId;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class BookDocumentFactory {\r\n  public BookDocument of(ObjectId objectId, String name, BigDecimal price, LocalDateTime publishedAt, SaleStatus saleStatus){\r\n    return new BookDocument(\r\n        objectId, name, price, publishedAt, saleStatus\r\n    );\r\n  }\r\n\r\n  public BookDocument newBookDocument(\r\n      String name, BigDecimal price, LocalDateTime publishedAt\r\n  ){\r\n    return of(\r\n        null, name, price, publishedAt, SaleStatus.WAITING_FOR_SALE\r\n    );\r\n  }\r\n\r\n  public BookDocument withSaleStatus(\r\n      BookDocument bookDocument, SaleStatus saleStatus\r\n  ){\r\n    return of(\r\n        bookDocument.getId(), bookDocument.getName(), bookDocument.getPrice(), bookDocument.getPublishedAt(), saleStatus\r\n    );\r\n  }\r\n}","repository#Repository":"BookDocumentTransactionRepository 라는 이름의 Repository 를 생성해두었습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport org.bson.types.ObjectId;\r\nimport org.springframework.data.mongodb.repository.ReactiveMongoRepository;\r\n\r\npublic interface BookDocumentTransactionRepository extends ReactiveMongoRepository<BookDocument, ObjectId> {\r\n}","transactional-애노테이션-방식의-트랜잭션-연산#@Transactional 애노테이션 방식의 트랜잭션 연산":"","bookdocumentservicejava#BookDocumentService.java":"Repository 의 메서드를 호출하는 연산은 아래와 같습니다. 간단한 코드이기에 설명은 생략합니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookDocumentService {\r\n  private final BookDocumentFactory documentFactory;\r\n  private final BookDocumentTransactionRepository bookDocumentTransactionRepository;\r\n\r\n  @Transactional\r\n  public Flux<BookDocument> insertNewBook(String name, BigDecimal price){\r\n    BookDocument book = documentFactory.newBookDocument(\r\n        name, price, LocalDateTime.now()\r\n    );\r\n\r\n    return bookDocumentTransactionRepository.insert(book)\r\n        .flatMap(bookDocument -> {\r\n          BookDocument forSale = documentFactory.withSaleStatus(bookDocument, SaleStatus.FOR_SALE);\r\n          return bookDocumentTransactionRepository.save(forSale);\r\n        })\r\n        .thenMany(bookDocumentTransactionRepository.findAll());\r\n  }\r\n\r\n}","테스트-코드#테스트 코드":"원래 제대로 작성하려면, 트랜잭션 코드 내에서 Unchecked Exception 이 일어나는 상황을 가정하고 일일이 테스트해야 하는데, 이번 문서의 목적이 비즈니스 로직 작성이 목적이 아니기에 세부적인 구현은 생략하고 단순한 동작테스트만 잘 되는지를 테스트 합니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.transactional;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentTransactionalTest {\r\n  private static Logger log = LoggerFactory.getLogger(BookDocumentTransactionalTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentService sut;\r\n\r\n  @DisplayName(\"TEST_새로운_책을_트랜잭셔널_애노테이션을_이용해_저장_및_수정\")\r\n  @Test\r\n  public void TEST_새로운_책을_트랜잭셔널_애노테이션을_이용해_저장_및_수정(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"before save\");\r\n    List<BookDocument> result = sut.insertNewBook(\"맛도리 여행\", BigDecimal.valueOf(3000))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"after save, result = {}\", result);\r\n  }\r\n}\n출력결과\n2024-04-01T11:28:56.126+09:00  INFO 497796 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : before save\r\n2024-04-01T11:28:56.633+09:00  INFO 497796 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : after save, result = [io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@1835b783, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@456b140f, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@2459333a, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@1e6bd367, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@2bd7f686, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@3601549f]\r\n\r\nProcess finished with exit code 0","transactionaloperator-1--transactional-사용방식#TransactionalOperator (1) : transactional() 사용방식":"설명은 건너뛰도록 하겠습니다.Service\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.transaction.reactive.TransactionalOperator;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookDocumentService {\r\n  private final BookDocumentFactory documentFactory;\r\n  private final BookDocumentTransactionRepository bookDocumentTransactionRepository;\r\n  private final TransactionalOperator transactionalOperator;\r\n    \r\n  // ...\r\n\r\n  public Flux<BookDocument> insertNewBookTransactional(String name, BigDecimal price){\r\n    BookDocument book = documentFactory.newBookDocument(\r\n        name, price, LocalDateTime.now()\r\n    );\r\n\r\n    Flux<BookDocument> flux = bookDocumentTransactionRepository.insert(book)\r\n        .flatMap(bookDocument -> {\r\n          BookDocument forSale = documentFactory.withSaleStatus(bookDocument, SaleStatus.FOR_SALE);\r\n          return bookDocumentTransactionRepository.save(forSale);\r\n        })\r\n        .thenMany(bookDocumentTransactionRepository.findAll());\r\n\r\n    return transactionalOperator.transactional(flux);\r\n  }\r\n  \r\n  // ...\r\n  \r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.transactional;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentTransactionalTest {\r\n  private static Logger log = LoggerFactory.getLogger(BookDocumentTransactionalTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentService sut;\r\n    \r\n  // ...\r\n  \r\n  @DisplayName(\"새로운_책을_트랜잭셔널_메서드를_이용해서_저장_및_수정\")\r\n  @Test\r\n  public void TEST_새로운_책을_트랜잭셔널_메서드를_이용해서_저장_및_수정(){\r\n    // given\r\n    \r\n    // when\r\n    \r\n    // then\r\n    log.info(\"before save\");\r\n    List<BookDocument> result = sut.insertNewBookTransactional(\"맛도리 여행\", BigDecimal.valueOf(3000))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"after save, result = {}\", result);\r\n  }\r\n  \r\n}\n출력결과\n2024-04-01T11:48:03.934+09:00  INFO 613188 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : before save\r\n2024-04-01T11:48:04.335+09:00  INFO 613188 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : after save, result = [io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@7affee54, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@96075c0, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@2337bf27, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@4679554d, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@43719e98, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@49353d43]\r\n\r\nProcess finished with exit code 0","transactionaloperator-2--execute-사용방식#TransactionalOperator (2) : execute() 사용방식":"Service\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.transaction.reactive.TransactionalOperator;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookDocumentService {\r\n  private final BookDocumentFactory documentFactory;\r\n  private final BookDocumentTransactionRepository bookDocumentTransactionRepository;\r\n  private final TransactionalOperator transactionalOperator;\r\n\r\n  // ...\r\n  \r\n  public Flux<BookDocument> insertNewBookExecute(String name, BigDecimal price){\r\n    BookDocument book = documentFactory.newBookDocument(\r\n        name, price, LocalDateTime.now()\r\n    );\r\n\r\n    Flux<BookDocument> flux = bookDocumentTransactionRepository.insert(book)\r\n        .flatMap(bookDocument -> {\r\n          BookDocument forSale = documentFactory.withSaleStatus(bookDocument, SaleStatus.FOR_SALE);\r\n          return bookDocumentTransactionRepository.save(forSale);\r\n        })\r\n        .thenMany(bookDocumentTransactionRepository.findAll());\r\n\r\n    return transactionalOperator.execute(status -> flux);\r\n  }\r\n\r\n}\n테스트\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.transactional;\r\n\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocumentService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookDocumentTransactionalTest {\r\n  private static Logger log = LoggerFactory.getLogger(BookDocumentTransactionalTest.class);\r\n\r\n  @Autowired\r\n  private BookDocumentService sut;\r\n\r\n  // ...\r\n\r\n  @DisplayName(\"새로운_책을_execute_메서드를_이용해서_저장_및_수정\")\r\n  @Test\r\n  public void TEST_새로운_책을_execute_메서드를_이용해서_저장_및_수정(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"before save\");\r\n    List<BookDocument> result = sut.insertNewBookExecute(\"맛도리 여행\", BigDecimal.valueOf(3000))\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"after save, result = {}\", result);\r\n  }\r\n}\n출력결과\n2024-04-01T11:50:29.258+09:00  INFO 627264 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : before save\r\n2024-04-01T11:50:29.653+09:00  INFO 627264 --- [main] .e.m.e.b.t.BookDocumentTransactionalTest : after save, result = [io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@1835b783, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@456b140f, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@2459333a, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@1e6bd367, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@2bd7f686, io.chagchagchag.example_mongo.mongodb_reactive_example.examples.book.BookDocument@3601549f]\r\n\r\nProcess finished with exit code 0"}},"/spring-data-r2dbc/entity-mysql-type-mapping":{"title":"Entity Mysql Type Mapping","data":{"entity-mysql-타입-매핑#Entity, MySQL 타입 매핑":"","참고자료#참고자료":"docs.spring.io\nhttps://docs.spring.io/spring-data/relational/reference/r2dbc/mapping.html\nasyncer-io/r2dbc-mysql\ngithub/asyncer-io/r2dbc-mysql\nGetting Started\nData Type Mapping","entity-매핑-애노테이션#Entity 매핑 애노테이션":"@Id : primary key 로 사용되는 필드에 지정합니다. auto-increment 가 지원되는 데이터베이스일 경우 DB에 데이터를 새로 저장한 후 생성된 기본키가 id 로 세팅됩니다.\n@Table : entity 클래스에 적용하는 애노테이션입니다. Table 명을 별도로 지정할 수 있습니다.\n@Transient : @Transient 가 붙은 필드는 mapping 에서 제외됩니다.\n@Column : entity 의 property 에 적용하는 애노테이션입니다. @Column 이 붙은 필드는 convention 에 의존한 데이터 매핑이 아닌 @Column 애노테이션에 명시한 규칙이 적용됩니다.\n@Version : Optimistic Lock 을 적용하고자 할 때 사용합니다. Entity 가 Update 될 때마다 자동으로 update 됩니다.\n@PersistenceConstructor : 특정 생성자(Constructor)에 대해 객체 생성시 사용되게끔 지정합니다. constructor 의 argument 이름에 따라서 매핑됩니다.\n개인적으로는 실무에서 내부 인하우스 툴이 아닌 상용서비스에 사용할 것이면, @PersistenceConstructor 기반의 모호한 객체 생성 코드는 Entity 클래스에서는 가급적 사용하지 않는 것이 낫다고 생각합니다. Entity 클래스에는 AllArgsConstructor 만 남겨두고, 별도의 팩토리 메서드를 통해서만 엔티티 생성의 생성자를 호출하고 엔티티 객체 생성에 관여하도록 하는 것이 안전한 방법입니다.팩토리 메서드를 모아둔 별도의 클래스에서 엔티티 객체를 생성하도록 해두면, Entity 측의 코드와 비즈니스 로직간의 변경에 대한 의존성이 떨어지기에 팩토리 메서드를 명확히 분류해서 따로 두시는 것을 추천드립니다.","mysql-type-과-java-type-매핑#MySQL Type 과 Java Type 매핑":"참고 : asyncer-io/r2dbc-mysql\ngithub/asyncer-io/r2dbc-mysql\nGetting Started\nData Type Mapping\n아래의 내용은 Data Type Mapping 에 제시된 데이터 매핑을 발췌해온 내용입니다.","tinyint-unsigned-1-byte#TINYINT UNSIGNED (1 Byte)":"Default: Short\nOthers: Integer, Long, BigInteger, Float, Double, BigDecimal\nSpecials: Boolean if it is TINYINT(1) UNSIGNED","tinyint-signed-1-byte#TINYINT SIGNED (1 Byte)":"Default: Byte\nOthers: Short, Integer, Long, BigInteger, Float, Double, BigDecimal\nSpecials: Boolean if it is TINYINT(1) SIGNED","smallint-unsigned-2-byte#SMALLINT UNSIGNED (2 Byte)":"Default: Integer\nOthers: Long, BigInteger, Float, Double, BigDecimal","smallint-signed-2-byte#SMALLINT SIGNED (2 Byte)":"Default: Short\nOthers: Integer, Long, BigInteger, Float, Double, BigDecimal","mediumint-signedunsigned-3-byte#MEDIUMINT SIGNED/UNSIGNED (3 Byte)":"Default: Integer\nOthers: Long, BigInteger, Float, Double, BigDecimal","int-unsigned-4-byte#INT UNSIGNED (4 Byte)":"Default: Long\nOthers: BigInteger, Float, Double, BigDecimal","int-signed-4-byte#INT SIGNED (4 Byte)":"Default: Integer\nOthers: Long, BigInteger, Float, Double, BigDecimal","bigint-unsigned-8-byte#BIGINT UNSIGNED (8 Byte)":"Default: BigInteger\nOthers: Long, Float, Double, BigDecimal","bigint-signed-8-byte#BIGINT SIGNED (8 Byte)":"Default: Long\nOthers: BigInteger, Float, Double, BigDecimal","float-signedunsigned-4-byte#FLOAT SIGNED/UNSIGNED (4 Byte)":"Default: Float\nOthers: Double, BigDecimal","double-signedunsigned-8-byte#DOUBLE SIGNED/UNSIGNED (8 Byte)":"Default: Double\nOthers: Float, BigDecimal","decimal-signedunsigned#DECIMAL SIGNED/UNSIGNED":"Default: BigDecimal\nOthers: Float, Double","boolean#BOOLEAN":"It is an alias of TINYINT(1) SIGNED in MySQL.","bit#BIT":"Default: ByteBuffer\nOthers: BitSet, byte[]\nSpecials: Boolean if it is BIT(1)","datetime#DATETIME":"Default: LocalDateTime\nOthers: ZonedDateTime, OffsetDateTime, Instant","timestamp#TIMESTAMP":"Default: ZonedDateTime\nOthers: LocalDateTime, OffsetDateTime, Instant","date#DATE":"Default: LocalDate","time#TIME":"Default: LocalTime\nOthers: Duration, OffsetTime","year#YEAR":"Default: Short\nOthers: Integer, Long, BigInteger, Year, Float, Double, BigDecimal","varchar--nvarchar--char--nchar#VARCHAR / NVARCHAR / CHAR / NCHAR":"Default: String","varbinary#VARBINARY":"Default: ByteBuffer\nOthers: byte[]","enum#ENUM":"Default: String\nOthers: enum class","set#SET":"Default: String[]\nOthers: String\nSpecials: Set, require getting it with a ParameterizedType, T should be String or an enum class","blob--longblob--mediumblob--tinyblob#BLOB / LONGBLOB / MEDIUMBLOB / TINYBLOB":"Default: ByteBuffer\nOthers: Blob, byte[]","text--longtext--mediumtext--tinytext--json#TEXT / LONGTEXT / MEDIUMTEXT / TINYTEXT / JSON":"Default: String\nOthers: Clob\nThe JSON in some distributions is an alias for TEXT.","geometry#GEOMETRY":"Default: byte[]\nOthers: Blob"}},"/spring-data-mongodb-reactive/spring-data-object-mapping-and-creation":{"title":"Spring Data Object Mapping and Creation","data":{"spring-data-reactive-의-객채생성-방식과-매핑방식#Spring Data Reactive 의 객채생성 방식과 매핑방식":"","intro#intro":"아래의 ReactiveMongoTemplate 을 Bean 으로 설정하는 코드를 보면, MongoConverter 와 ReactiveMongoDatabaseFactory 를 주입받아서 ReactiveMongoTemplate 객체를 생성한다는 사실을 알 수 있습니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\n\r\n@Configuration\r\npublic class MongoReactiveConfiguration {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n\r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory dbFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(dbFactory);\r\n  }\r\n\r\n  @Bean(name = \"bookReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory bookReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    // 이렇게 할 수도 있지만, 하나의 프로젝트에서 여러 몽고 database 를 사용할 수 있으므로 비활성화\r\n//    String database = mongoProperties.getMongoClientDatabase();\r\n    final String database = \"book\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n\r\n  @Bean(name = \"bookReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate bookReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory bookReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(bookReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n}\n이번 문서에서는 위의 코드에서 처럼 ReactiveMongoTemplate 객체를 만들기 위해 필요한 MongoConverter 를 알아봅니다. MongoConverter 는 객체를 BSON → Java 객체, Java 객체 → BSON 으로 변환해주는 역할을 수행합니다.ReactiveMongoTemplate 객체는 생성자가 여러 종류이며, 생성자에 항상 반드시 MongoConverter 객체가 필요한 것은 아닙니다. 위의 코드는 예제를 위해 MongoConverter 를 주입받아서 생성하는 예제를 추가했습니다.","mongoconverter-mappingmongoconverter#MongoConverter, MappingMongoConverter":"MongoConverter 는 interface 이며 아래와 같이 선언되어 있습니다.\npackage org.springframework.data.mongodb.core.convert;\r\npublic interface MongoConverter extends EntityConverter<MongoPersistentEntity<?>, \r\n\t\t\t\t\t\t\t\t\t\tMongoPersistentProperty, Object, Bson>, \r\n\t\t\t\t\t\t\t\t\t\tMongoWriter<Object>,\r\n\t\t\t\t\t\t\t\t\t\tEntityReader<Object, Bson>, CodecRegistryProvider {\r\n\t// ... \r\n}\nMappingMongoConverter 는 대표적인 MongoConverter 타입의 구현체입니다.\npackage org.springframework.data.mongodb.core.convert;\r\n\r\n// ..\r\n\r\npublic class MappingMongoConverter extends AbstractMongoConverter\r\n\t\timplements ApplicationContextAware, EnvironmentCapable {\r\n    // ...\r\n}","mappingmongoconverter-의-매핑과정#MappingMongoConverter 의 매핑과정":"","customconverter#CustomConverter":"위의 그림에서 살펴봤듯, Spring Data Mongodb 는 Document 에 해당하는 객체를 생성시에 제일 먼저 CustomConverter 가 있는지를 살피고 CustomConverter 가 존재하면 이 CustomConverter 를 적용합니다.Converter 는 Read, Write 용도로 2개를 만들어두어야 합니다.아래는 그 예제입니다.","readingconverter#ReadingConverter":"@ReadingConverter\r\npublic class PersonDocumentReadingConverter implements Converter<Document, PersonDocument> {\r\n    @Override\r\n    public PersonDocument convert(Document source){\r\n        ObjectId id = source.getObjectId(\"_id\");\r\n        String name = source.getString(\"name\");\r\n        Integer age = source.getInteger(\"age\");\r\n        return new PersonDocument(id, name, age);\r\n    }\r\n}","writingconverter#WritingConverter":"@WritingConverter\r\npublic class PersonDocumentWritingConverter implements Converter<PersonDocument, Document> {\r\n    @Override\r\n    public Document convert(PersonDocument source){\r\n        Document document = new Document();\r\n        document.put(\"_id\", source.getId());\r\n        document.put(\"name\", source.getName());\r\n        document.put(\"age\", source.getAge());\r\n        return document;\r\n    }\r\n}","customconverter-등록-1#CustomConverter 등록 (1)":"위에서 생성한 ReadingConverter, WritingConverter 는 아래와 같이 등록 가능합니다.\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.core.convert.converter.Converter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\nimport org.springframework.data.mongodb.repository.config.EnableMongoRepositories;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Configuration\r\n@EnableMongoRepositories\r\npublic class MongoConfig {\r\n\r\n    @Bean\r\n    public MongoCustomConversions mongoCustomConversions() {\r\n        List<Converter<?, ?>> converters = new ArrayList<>();\r\n        converters.add(new PersonDocumentReadingConverter());\r\n        converters.add(new PersonDocumentWritingConverter());\r\n        return new MongoCustomConversions(converters);\r\n    }\r\n}","customconverter-등록-2#CustomConverter 등록 (2)":"또는 아래와 같이 등록하는 것도 가능합니다.\n@Configuration\r\npublic class ReactiveMongoConfig extends AbstractMongoClientConfiguration{\r\n    @Override\r\n    protected String getDatabaseName(){\r\n        return \"helloworld\";\r\n    }\r\n    \r\n    @Override\r\n    protected void configureConverters(\r\n        MongoCustomConversions.MongoConverterConfigurationAdapter adapter\r\n    ){\r\n        adapter.registerConverter(new PersonDocumentReadingConverter());\r\n        adapter.registerConverter(new PersonDocumentWritingConverter());\r\n    }\r\n}","spring-data-object-mapping#Spring Data Object Mapping":"실제로는 아주 특수한 데이터 파싱이 필요한 것이 아닌 한, 사용자가 직접 CustomConverter 를 등록하지 않아도 되는 경우가 대부분입니다. 사용자 정의 CustomConverter 가 존재하지 않을 경우에는 Spring Data 에서 ObjectMapping 을 하게됩니다. 먼저 Object Creation 을 하기 위해 코딩컨벤션에 맞는 생성자가 맞는지를 찾고, 존재한다면 생성자를 통해 객체를 생성합니다. 만약 코딩컨벤션에 맞는 생성자가 존재하지 않는다면, Property Population 을 진행하는데, with- 접두어가 붙은 빌더 메서드를 사용해서 불변성이 유지된 객체를 생성할 수 있습니다.\nObject Creation\n코딩 컨벤션에 맞는 생성자가 있는지를 찾고, 존재한다면 코딩컨벤션에 맞는 생성자를 선택 후 객체를 생성\nProperty Population\nwith- 접두어가 붙은 빌더 메서드를 사용해서 불변성이 유지된 객체를 생성","object-creation#Object Creation":"일반적인 코딩 컨벤션에 맞는 생성자를 찾아서 객체를 생성하는 절차입니다.\n@PersistenceCreator 애노테이션을 갖는 static factory 메서드가 정확히 하나 존재할 경우 이 팩토리 메서드를 사용합니다.\n@PersistenceCreator 애노테이션을 갖는 constructor 가 있다면 이 constructor 를 사용합니다.\n인자가 없는 constructor 가 있을 경우 이 constructor 를 사용합니다.\nconstructor 가 하나만 존재한다면, 이 constructor 를 채택해서 사용합니다.","property-population#Property Population":"Spring Data MongoDB Reactive에서는 with 접두어를 가진 빌더 메서드를 사용하여 객체를 생성할 수 있습니다. with 접두어를 가진 메서드는 불변성을 유지하고 객체를 간단하게 생성하는 데에 사용됩니다.r2dbc 에서는 prorperty 가 mutable 해야만 proeprty 의 population 이 가능하지만, Spring Data Mongodb Reactive 에서는 with 메서드를 통해 불변 필드에도 객체생성이 가능 합니다.\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.mongodb.core.mapping.Document;\r\n\r\n@Document\r\npublic class Product {\r\n    \r\n    @Id\r\n    private String id;\r\n    \r\n    private String name;\r\n    private String description;\r\n\r\n    // 생성자는 private으로 선언하여 외부에서 직접 객체를 생성하지 못하도록 합니다.\r\n    private Product() {}\r\n\r\n    // with 메서드를 사용하여 객체를 생성하고 필드 값을 설정합니다.\r\n    // name, description 을 인자로 지정하고 with 구문과 함께 사용했다는 사실에 주목해주세요.\r\n    public static Product withNameAndDescription(String name, String description) {\r\n        Product product = new Product();\r\n        product.name = name;\r\n        product.description = description;\r\n        return product;\r\n    }\r\n\r\n    // Getter 메서드들은 필요에 따라 정의합니다.\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n}","spring-data-mongodb-reactive-에서의-암묵적인-매핑-규칙#Spring Data MongoDB Reactive 에서의 암묵적인 매핑 규칙":"_id 필드가 없으면 내부적으로 리플렉션을 통해 _id 필드를생성\nid 필드에 @Id 가 안붙어있어도 필드명이 id 이면서 ObjectId 타입일 경우 _id 필드로 인식\n인자가 없는 기본생성자는 무조건 하나 있어야 합니다.\nSpring Data MongoDB Reactive 에서는 기본생성자를 private 접근 레벨로 정의하는 것이 허용됩니다.\n만약 여러 인자를 받는 생성자를 정의하고 기본생성자가 없으면 에러가 나기 때문에 이 경우에는 반드시 기본생성자를 생성하셔야 합니다.\nSpring Data MongoDB Reactive 에서는 enum 의 변환이 편리하고 실용적입니다.  Java → MongoDB 로의 교환시에는 enum 타입이 String 으로 변환되어 인식되며, MongoDB → Java 로의 교환시에는 String 이 Enum 으로 암묵적인 변환이 됩니다.\nSpring Data MongoDB Reactive 에서 BigDecimal 을 사용할 경우 별도로 BigDecimal → Decimal128, Decimal128 → BigDecimal 로 Converting 을 하는 Converter 를 별도로 작성해주셔야 합니다. 문서 하단 부의 BigDecimal ↔ Decmal128 Converter 섹션을 참고해주세요.","권장되는-방식#권장되는 방식":"Spring Data R2DBC, Spring Data MongoDB Reactive 모두 @PersistenceCreator 등과 같은 애노테이션을 사용하는 방식이 지원되지만, 이 기능이 버전마다 상이하기 때문에, Entity 또는 Document 객체를 생성하는 코드는 가급적 팩토리 메서드 또는 팩토리 메서드 들을 모아둔 컴포넌트에 별도로 정의해서 사용하시기 바랍니다.실무에서도 가급적이면 Entity 객체 생성하는 생성자 코드를 하드 코딩으로 접근하는 것은 위험합니다. 가급적 Entity 또는 Document 객체 생성시에는 Entity 내에는 AllArgsConstructor 하나만 두고, *Factory.java 라는 엔티티 객체 생성용도의 컴포넌트를 별도로 정의해서 사용하시기 바랍니다. 이렇게 하는 이유는 생성자 코드를 하드코딩으로 할 경우 비즈니스 변경로직 발생시 여기저기 우후죽순으로 퍼져있는 하드코딩된 생성자 코드를 일괄 수정할 방법이 없으며, 테스트에 취약하기 때문입니다. 팩토리 역할의 컴포넌트를 생성하면 객체 생성 코드에 대한 테스트 코드 역시 분리되기에 엔티티 코드에 비즈니스 내용이 간섭을 하지 않으며, 변경사항에 유연하게 대응이 가능하며, 메서드나 객체 명을 따로 지정해 용도별로 분리가 가능합니다.**\"객체 생성을 하드코딩\"**하는 로직들은 가급적이면 피하는 것이 좋습니다.","bigdecimal--decmal128-converter#BigDecimal ↔ Decmal128 Converter":"","bigdecimaltodecimal128converterjava#BigDecimalToDecimal128Converter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n \r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n \r\npublic class BigDecimalToDecimal128Converter implements Converter<BigDecimal, Decimal128> {\r\n  @Override\r\n  public Decimal128 convert(BigDecimal source) {\r\n    return source == null ? null : new Decimal128(source);\r\n  }\r\n}","decimal128tobigdecimalconverterjava#Decimal128ToBigDecimalConverter.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n \r\nimport java.math.BigDecimal;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.core.convert.converter.Converter;\r\n \r\npublic class Decimal128ToBigDecimalConverter implements Converter<Decimal128, BigDecimal> {\r\n  @Override\r\n  public BigDecimal convert(Decimal128 source) {\r\n    return source == null ? null : source.bigDecimalValue();\r\n  }\r\n}","mongoreactiveconfiguration#MongoReactiveConfiguration":"Converter 들을 등록하는 코드는 아래 코드에서 MongoCustomConversions mongoCustomConversions(){} 메서드를 참고해주시기 바랍니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples.config;\r\n \r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport java.math.BigDecimal;\r\nimport java.util.Arrays;\r\nimport org.bson.json.StrictJsonWriter;\r\nimport org.bson.types.Decimal128;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.boot.autoconfigure.mongo.MongoProperties;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.data.mongodb.ReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.ReactiveMongoTransactionManager;\r\nimport org.springframework.data.mongodb.core.ReactiveMongoTemplate;\r\nimport org.springframework.data.mongodb.core.SimpleReactiveMongoDatabaseFactory;\r\nimport org.springframework.data.mongodb.core.convert.MongoConverter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\n \r\n@Configuration\r\npublic class MongoReactiveConfiguration {\r\n  @Value(\"${spring.data.mongodb.uri}\")\r\n  private String mongoUri;\r\n \r\n  @Bean\r\n  public MongoClient reactiveMongoClient(){\r\n    return MongoClients.create(mongoUri);\r\n  }\r\n \r\n  @Bean\r\n  public ReactiveMongoTransactionManager transactionManager(\r\n      ReactiveMongoDatabaseFactory dbFactory\r\n  ){\r\n    return new ReactiveMongoTransactionManager(dbFactory);\r\n  }\r\n \r\n  @Bean(name = \"helloworldReactiveMongoDatabaseFactory\")\r\n  public SimpleReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory(\r\n      MongoProperties mongoProperties,\r\n      MongoClient mongoClient\r\n  ){\r\n    // 이렇게 할 수도 있지만, 하나의 프로젝트에서 여러 몽고 database 를 사용할 수 있으므로 비활성화\r\n//    String database = mongoProperties.getMongoClientDatabase();\r\n    final String database = \"helloworld\";\r\n    return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n  }\r\n \r\n  @Bean(name = \"helloworldReactiveMongoTemplate\")\r\n  public ReactiveMongoTemplate helloworldReactiveMongoTemplate(\r\n      ReactiveMongoDatabaseFactory helloworldReactiveMongoDatabaseFactory,\r\n      MongoConverter mongoConverter\r\n  ){\r\n    return new ReactiveMongoTemplate(helloworldReactiveMongoDatabaseFactory, mongoConverter);\r\n  }\r\n \r\n  // 여기를 참고해주세요.\r\n  @Bean\r\n  public MongoCustomConversions mongoCustomConversions(){\r\n    return new MongoCustomConversions(\r\n        Arrays.asList(\r\n            new BigDecimalToDecimal128Converter(),\r\n            new Decimal128ToBigDecimalConverter()\r\n        )\r\n    );\r\n  }\r\n \r\n}"}},"/spring-data-r2dbc/jdbc-jpa-vs-r2dbc":{"title":"Jdbc Jpa Vs R2dbc","data":{"jdbc-jpa-와의-차이점#JDBC, JPA 와의 차이점":"","jdbc-기반의-jpa#JDBC 기반의 JPA":"JDBC, JPA 는 블로킹 기반의 동기(Synchrnoization) 방식의 I/O 연산을 수행합니다. 데이터베이스에 접근해서 커넥션을 획득하고, CRUD 를 수행하기 위해서는 TCP 통신을 수행해야 하는데, JPA 는 JDBC 를 기반으로 이루어져있고 JDBC 는 TCP 통신을 블로킹 기반의 동기(Synchronization)방식으로 수행합니다.JDBC 는 굉장히 오래된 라이브러리입니다. AIO와 같은 Java 1.8 이후의 TCP 소켓 통신 스펙(비동기 논블로킹 네트워킹)이 적용되기에는 무리가 있는 라이브러리입니다. \n참고 : 블로킹, 논블로킹, 동기, 비동기에 대한 개념은 아래 문서를 참고해주세요.\n동기 vs 비동기\n블로킹 vs 논블로킹\n현재 가장 안정적인 Java LTS 버전은 Java 17 입니다. 그리고 Java 21 이 새로운 LTS 로 떠올랐습니다. JDK1.5 이전부터 작성되었을 JDBC 라이브러리는 더 이상 모던한 애플리케이션에 적합하지 않을지도 모릅니다. 네트워킹을 위한 비동기 논블로킹 TCP 통신 역시 JAVA 8 이후에 도입된 점을 보면, 블로킹 기반의 동기연산을 하는 네트워크 통신을 하는 JDBC는 굉장히 오래되었으며, 최신 모바일 환경에 대응하기에 어려움이 많은 데이터 접근 레이어가 아니지 않나 싶습니다.\nJPA 의 더티체킹JPA 에서 흔히 이야기하는 Write Behind, 변경감지 개념은 r2dbc 환경에서 큰 장점이 되지 못합니다. Write Behind 를 한다는 이야기는 엔티티 캐시를 내부에 보관하고 있는다는 의미이고 다른말로 이야기하면 Mutable 하다는 이야기입니다.JPA 에서는 객체의 스냅샷 등을 통해 변경감지를 하는 등의 연산을 통해 엔티티의 변경을 감지하지만, R2DBC 로 넘어오면서 개별 데이터의 흐름을 Immutable 하게 처리하는 R2dbc 에서는 JPA 의 변경감지 기능이 더 이상 필요가 없어졌습니다. 다중 트랜잭션, 분산 트랜잭션 환경을 겪어본다면 더티체킹 개념보다는 이벤트의 트랜잭셔널함에 더 집중을 하게 됩니다.따라서 Jpa 의 더티체킹이 R2dbc 에서 지원이 안된다는 점에 실망하지 않으셔도 될 것 같습니다.","r2dbc#R2DBC":"참고 : R2DBC (Reactive Relational Database Connectivity)\n이미지 출처 : https://r2dbc.io/\nJDBC 는 데이터베이스와 통신을 하는 데에 있어서 동기적이고 블로킹 기반의 통신을 하기 때문에 대규모의 트래픽을 처리하기에 어려움이 많습니다. 반면 R2DBC 는 비동기 논블로킹 네트워크 통신 기반으로 동작하기 때문에 데이터베이스 IO 작업 수행시 애플리케이션의 응답성을 향상시키고, 동시성을 증가시키며, 리액티브 스트림 기반의 연산을 수행하기 때문에 데이터베이스의 변경 사항을 실시간으로 감지하고 처리할 수 있다는 것 역시 장점입니다.R2DBC 는 여러 기업과 개발자 커뮤니티에 의해 공동으로 개발되고 유지보수 되어온 오픈소스 프로젝트이며, R2DBC의 주요 컨트리뷰터는 Pivotal 의 개발자들이 대 다수입니다.https://r2dbc.io 에서는 아래와 같은 다양한 정보들을 제공하고 있기 때문에 가급적이면 꼭 방문해서 세부적인 내용들을 읽어보시기 바랍니다. 요즘 구글 크롬의 번역기 성능도 좋으니 꼭 번역기를 이용해서 한번씩은 읽어보시길 추천드립니다."}},"/spring-data-r2dbc":{"title":"Spring Data R2DBC","data":{"참고자료#참고자료":"docs.spring.io\nSpring Data R2DBC\nMapping\nR2DBC Repositories\nQuery Methods\nr2dbc Official\nr2dbc.io\nr2dbc drivers, SPI\nr2dbc spi\ngithub :  R2DBC SPI\ngithub.com/asyncer-io/r2dbc-mysql\ngithub.com/asyncer-io/r2dbc-mysql\nR2DBC MySQL wiki\nData Type Mapping\nSpring Data R2DBC Source\nSpring Data R2DBC : 현재는 관리되지 않으며 Spring Data Relational 으로 Merge 되어있습니다.\nSpring Data Relational : spring-data-jdbc, spring-data-jdbc-distribution, spring-data-relational, spring-data-r2dbc 가 모두 통합되어 있습니다.","목차#목차":""}},"/spring-data-r2dbc/mysql-features":{"title":"Mysql Features","data":{"mysql-특징#MySQL 특징":"자세한 내용은 docs-mysql-essential을 참고해주시기 바랍니다."}},"/spring-data-r2dbc/example-mysql-docker-container":{"title":"Example Mysql Docker Container","data":{"예제-용도의-mysql-docker-container#예제 용도의 MySQL Docker Container":"이번 문서 작업에서 사용하는 예제에서 사용하는 MySQL 도커 컨테이너를 정의한 docker-compose 는 아래와 같습니다.\nversion: '3.7'\r\nservices:\r\n  example-mysql:\r\n    image: mysql:5.7.39-debian\r\n    restart: always\r\n    #    command: --lower_case_table_names=1\r\n    container_name: example-mysql\r\n    hostname: example-mysql\r\n    ports:\r\n      - \"23306:3306\"\r\n    environment:\r\n      - MYSQL_USER=user\r\n      - MYSQL_USER_HOST=%\r\n      - MYSQL_PASSWORD=test1357\r\n      - MYSQL_DATABASE=example\r\n      - MYSQL_ROOT_HOST=%\r\n      - MYSQL_ROOT_PASSWORD=test1357\r\n      - TZ=UTC\r\n    command:\r\n      - --character-set-server=utf8mb4\r\n      - --collation-server=utf8mb4_unicode_ci\r\n    volumes:\r\n      - ./init/:/docker-entrypoint-initdb.d/\n구동은 아래와 같이 실행해주세요\ndocker-compose up -d\n종료는 아래와 같이 실행해주세요.\ndocker-compose down\n또는 Docker Desktop 에서 Stop & Delete 를 누르셔도 됩니다."}},"/spring-data-r2dbc/r2dbc-repository":{"title":"R2dbc Repository","data":{"r2dbcrepository#R2dbcRepository":"JPA 에서 흔히 사용하던 Repository 와 유사하게 R2dbc 에서도 Repository 기반의 Data 접근 계층의 코드를 작성하는 것이 가능합니다.ReactiveMongoRepository 문서 에서 살펴봤던 상속 계층도에서 R2dbcRepository 와 SimpleR2dbcRepository 만 다르고 계층도가 비슷합니다.참고\nSimpleR2dbcRepository<T,ID>\nReactiveCrudRepository<T,ID>\nReactiveQueryByExampleExecutor<T>\nReactiveSortingRepository<T,ID>\nRepository<T,ID>","component-scan#Component Scan":"여러 종류의 Repository 를 사용할 경우가 있는데, 각각의 종류 별로 아래와 같이 리포지터리를 스캔할 수 있도록 설정해줍니다. 아래에서는 ReactiveMongoRepository 와 R2dbc의 컴포넌트 스캔 패키지를 각각 별도로 지정해주었습니다. 실제로 R2dbc, Reactive Mongo 를 함께 쓰는 경우가 많을 수 있기에 아래와 같이 스캔 대상을 명확히 지정해주는 것이 좋습니다.\n@EnableReactiveMongoRepositories(\r\n    // ...\r\n)\r\n@EnableR2dbcRepositories(\r\n    basePackages = {\"io.chagchagchag.example.r2dbc_example\"}\r\n)\r\n@SpringBootApplication\r\npublic class R2dbcExampleApplication {\r\n\r\n\tpublic static void main(String[] args) {\r\n\t\tSpringApplication.run(R2dbcExampleApplication.class, args);\r\n\t}\r\n\r\n}\n멀티 모듈 기반으로 프로젝트를 새로 구성 시에 컴포넌트를 스캔할 수 없다는 에러가 나오기도 하는데, 위와 같이 @Enable***Repositories 를 명시하지 않아서 나는 에러인 경우가 자주 있습니다. 이 경우에는 위의 코드 처럼 반드시 @Enable***Repositories 를 추가해서 리포지터리를 스캔 대상에 추가해두었는지를 확인해주시면 됩니다.","simplereactiver2dbcrepository#SimpleReactiveR2dbcRepository":"","save-연산-insert-update-연산#save 연산 (insert, update 연산)":"","조회-연산-find-연산#조회 연산 (find 연산)":"","삭제-연산-delete-연산#삭제 연산 (delete 연산)":""}},"/spring-data-r2dbc/query-methods":{"title":"Query Methods","data":{"query-methods#Query Methods":"Repository 에서 지원하는 Query Method, @Query 에 대해서 알아봅니다. 비교적 간단한 쿼리는 Query Method 를 사용해서 구현이 가능하지만, 메서드의 이름이 길어진다는 단점과, 유연한 쿼리 작성은 쉽지 않다는 단점이 있습니다. 복잡하고 정교한 쿼리 작성이 필요하다면 QueryMethod 보다는 @Query 를 사용하거나  R2dbcEntityTemplate, R2dbcOperations 를 이용해서 SQL 을 풍부하게 활용하시길 추천드립니다.","참고#참고":"","mysql-구동-환경#mysql 구동 환경":"보통 테스트 코드 작성시 testcontainers 를 사용하는 편이지만, 이번 예제 문서에서는 예제의 단순함을 위해 testcontainers 대신 mysql docker 이미지를 로컬에 컨테이너로 구동하는 환경을 사용합니다.mysql docker-compose 파일은 아래와 같습니다.\nversion: '3.7'\r\nservices:\r\n  example-mysql:\r\n    image: mysql:5.7.39-debian\r\n    restart: always\r\n    #    command: --lower_case_table_names=1\r\n    container_name: example-mysql\r\n    hostname: example-mysql\r\n    ports:\r\n      - \"23306:3306\"\r\n    environment:\r\n      - MYSQL_USER=user\r\n      - MYSQL_USER_HOST=%\r\n      - MYSQL_PASSWORD=test1357\r\n      - MYSQL_DATABASE=example\r\n      - MYSQL_ROOT_HOST=%\r\n      - MYSQL_ROOT_PASSWORD=test1357\r\n      - TZ=UTC\r\n    command:\r\n      - --character-set-server=utf8mb4\r\n      - --collation-server=utf8mb4_unicode_ci\r\n    volumes:\r\n      - ./init/:/docker-entrypoint-initdb.d/","r2dbcmysqlconfig#R2dbcMySqlConfig":"package io.chagchagchag.example.r2dbc_example.config;\r\n\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionConfiguration;\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionFactory;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.r2dbc.connection.R2dbcTransactionManager;\r\nimport org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer;\r\nimport org.springframework.r2dbc.connection.init.ResourceDatabasePopulator;\r\nimport org.springframework.transaction.ReactiveTransactionManager;\r\n\r\n@Configuration\r\npublic class R2dbcMySqlConfig {\r\n\r\n  @Bean\r\n  public MySqlConnectionFactory mySqlConnectionFactory(){\r\n    MySqlConnectionConfiguration config = MySqlConnectionConfiguration.builder()\r\n        .host(\"localhost\")\r\n        .port(23306)\r\n        .username(\"user\").password(\"test1357\")\r\n        .database(\"example\")\r\n        .build();\r\n\r\n    return MySqlConnectionFactory.from(config);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveTransactionManager transactionManager(MySqlConnectionFactory connectionFactory){\r\n    return new R2dbcTransactionManager(connectionFactory);\r\n  }\r\n\r\n  @Bean\r\n  public ConnectionFactoryInitializer initializer(MySqlConnectionFactory connectionFactory){\r\n    ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();\r\n    initializer.setConnectionFactory(connectionFactory);\r\n    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\r\n    initializer.setDatabasePopulator(populator);\r\n    return initializer;\r\n  }\r\n\r\n}","예제-데이터#예제 데이터":"","author-테이블#author 테이블":"예제 용도의 간단한 작가 데이터를 담는 테이블입니다.\nCREATE TABLE IF NOT EXISTS example.book\r\n(\r\n    id           bigint auto_increment\r\n        primary key,\r\n    name         varchar(30) not null\r\n) default character set utf8 collate utf8_general_ci;\n샘플 데이터\nINSERT INTO example.author(name)\r\nVALUES\r\n    ('찰스'),\r\n    ('1박2일 편집부'),\r\n    ('생로병사 편집부'),\r\n    ('EBS'),\r\n    ('내셔널지오그래픽');","book-테이블#book 테이블":"예제 용도의 간단한 책 데이터를 담는 테이블입니다.정규화를 제대로 한다면 sale_status , price, published_at  컬럼은 각각 별도의 테이블에서 관리하게끔 정규화를 하는 것이 맞습니다. 다만, 아래 테이블은 짧은 문서 내에서 다양한 쿼리를 수행해보기 위한 것이 목적이기에 정규화가 이루어져있지 않더라도 조금이나마 양해를 부탁드립니다.\ncreate table example.book\r\n(\r\n    id           bigint auto_increment\r\n        primary key,\r\n    name         varchar(30) not null,\r\n    price        bigint      null,\r\n    published_at datetime    null,\r\n    sale_status  varchar(20) not null\r\n) default character set utf8 collate utf8_general_ci;\n샘플 데이터\nINSERT INTO example.book(\r\n    name, price, published_at, sale_status\r\n) VALUES\r\n('바람과 함께 사라지다', 11000, '1950-01-01 00:00:00', 'SOLD_OUT'),\r\n('바람과 함께 사라지다', 12000, '1950-01-02 00:00:00', 'SOLD_OUT'),\r\n('바람과 함께 사라지다', 13000, '1950-01-03 00:00:00', 'FOR_SALE'),\r\n('바람과 함께 사라지다', 14000, '1950-01-04 00:00:00', 'FOR_SALE'),\r\n('바람과 함께 사라지다', 15000, '1950-01-05 00:00:00', 'FOR_SALE')\r\n;","find-연산들#find 연산들":"간단한 몇몇 예제를 확인해봅니다.","eg-1--가격이-가장-높은-책을-조회#e.g. 1 : 가격이 가장 높은 책을 조회":"Repository 코드\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookFindRepository extends ReactiveSortingRepository<Book, Long> {\r\n  Mono<Book> findFirstByNameOrderByPriceDesc(String name);\r\n}\nTest\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\n// ...\r\n\r\n@SpringBootTest\r\npublic class BookFindRepositoryExampleTest {\r\n  private Logger log = LoggerFactory.getLogger(BookFindRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookFindRepository bookFindRepository;\r\n\r\n  @DisplayName(\"QUERY_METHOD__가격이_가장_높은_책을_조회\")\r\n  @Test\r\n  public void TEST_QUERY_METHOD__가격이_가장_높은_책을_조회(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    Book book = bookFindRepository\r\n        .findFirstByNameOrderByPriceDesc(\"바람과 함께 사라지다\")\r\n        .block();\r\n\r\n    log.info(\"book.name = {}\", book.getName());\r\n    log.info(\"book.name = {}\", book.getPrice());\r\n    log.info(\"book.name = {}\", book.getSaleStatus());\r\n  }\r\n\r\n}\n출력결과\n2024-04-02T12:18:17.540+09:00  INFO [main] i.c.e.r.b.BookFindRepositoryExampleTest  : book.name = 바람과 함께 사라지다\r\n2024-04-02T12:18:17.542+09:00  INFO [main] i.c.e.r.b.BookFindRepositoryExampleTest  : book.name = 15000\r\n2024-04-02T12:18:17.542+09:00  INFO [main] i.c.e.r.b.BookFindRepositoryExampleTest  : book.name = FOR_SALE","eg-2-객체-프로젝션-테스트#e.g. 2: 객체 프로젝션 테스트":"Repository 코드\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookFindRepository extends ReactiveSortingRepository<Book, Long> {\r\n  // ...\r\n  Mono<BookName> findFirstByNameOrderByPublishedAtDesc(String name);\r\n}\nTest\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookFindRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookName;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookFindRepositoryExampleTest {\r\n  private Logger log = LoggerFactory.getLogger(BookFindRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookFindRepository bookFindRepository;\r\n  \r\n  // ...\r\n    \r\n  @DisplayName(\"QUERY_METHOD__가장_최근에_출간된_책의_이름을_조회\")\r\n  @Test\r\n  public void TEST_QUERY_METHOD__가장_최근에_출간된_책의_이름을_조회(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    BookName book = bookFindRepository\r\n        .findFirstByNameOrderByPublishedAtDesc(\"바람과 함께 사라지다\")\r\n        .block();\r\n\r\n    log.info(\"book.name = {}\", book.name());\r\n  }\r\n\r\n\r\n}\n출력결과\n2024-04-02T12:33:03.460+09:00  INFO [main] i.c.e.r.b.BookFindRepositoryExampleTest  : book.name = 바람과 함께 사라지다\r\n\r\nProcess finished with exit code 0","delete-연산들#delete 연산들":"","eg-1--salestatus-가-hold-이면서-가격이-11000-원-이상인-책을-삭제#e.g. 1 : SaleStatus 가 HOLD 이면서, 가격이 11000 원 이상인 책을 삭제":"Repository\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDeleteRepository extends ReactiveCrudRepository<Book, Long> {\r\n  Mono<Long> deleteBySaleStatusAndPriceGreaterThan(SaleStatus saleStatus, BigDecimal price);\r\n}\r\nTest\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookDeleteRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookDeleteRepositoryExampleTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDeleteRepositoryExampleTest.class);\r\n  \r\n  @Autowired\r\n  private BookDeleteRepository bookDeleteRepository;\r\n  \r\n  @DisplayName(\"QUERY_METHOD__SALE_STATUS_가_HOLD_이면서_11000원_이상인_책을_삭제\")\r\n  @Test\r\n  public void TEST_QUERY_METHOD__SALE_STATUS_가_HOLD_이면서_11000원_이상인_책을_삭제(){\r\n    // given\r\n    \r\n    // when\r\n    \r\n    // then\r\n    Long count = bookDeleteRepository\r\n        .deleteBySaleStatusAndPriceGreaterThan(SaleStatus.HOLD, BigDecimal.valueOf(11000))\r\n        .block();\r\n\r\n    log.info(\"count = {}\", count);\r\n  }\r\n  \r\n}\n출력결과\n2024-04-02T12:46:01.004+09:00  INFO [main] .c.e.r.b.BookDeleteRepositoryExampleTest : count = 1","eg-2--salestatus-가-hold-인-모든-책을-삭제#e.g. 2 : SaleStatus 가 HOLD 인 모든 책을 삭제":"Repository\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport java.math.BigDecimal;\r\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\r\nimport reactor.core.publisher.Mono;\r\n\r\npublic interface BookDeleteRepository extends ReactiveCrudRepository<Book, Long> {\r\n  // ...\r\n  Mono<Long> deleteBySaleStatus(SaleStatus saleStatus);\r\n}\r\nTest\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookDeleteRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookDeleteRepositoryExampleTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookDeleteRepositoryExampleTest.class);\r\n  \r\n  @Autowired\r\n  private BookDeleteRepository bookDeleteRepository;\r\n  \r\n  // ...\r\n  \r\n  @DisplayName(\"QUERY_METHOD__SALE_STATUS_가_HOLD_인_모든_책을_삭제\")\r\n  @Test\r\n  public void TEST_QUERY_METHOD__SALE_STATUS_가_HOLD_인_모든_책을_삭제(){\r\n    // given\r\n\r\n    // when\r\n    Long count = bookDeleteRepository\r\n        .deleteBySaleStatus(SaleStatus.HOLD)\r\n        .block();\r\n\r\n    // then\r\n    log.info(\"count = {}\", count);\r\n  }\r\n\r\n  \r\n}\n출력결과\n2024-04-02T12:51:09.573+09:00  INFO [main] .c.e.r.b.BookDeleteRepositoryExampleTest : count = 1\r\n\r\nProcess finished with exit code 0","query#@Query":"SQL 을 Java 문자열로 변환하는 것은 dpriver.com/pp/sqlformat.htm 에서 Database = MySQL, Output = Java 로 세팅 후 Convert 버튼을 클릭하면 간편하게 변환이 가능합니다.","eg-1-간단한-inner-join-예제#e.g. 1: 간단한 inner join 예제":"예제로는 간단한 inner join 쿼리 하나를 살펴보겠습니다.Repository\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport org.springframework.data.r2dbc.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.data.repository.reactive.ReactiveSortingRepository;\r\nimport reactor.core.publisher.Flux;\r\n\r\npublic interface BookQueryRepository extends ReactiveSortingRepository<Book, Long> {\r\n  @Query(\r\n      \"SELECT b.*, a.name as author_name \"\r\n    + \"FROM book b \"\r\n    + \"INNER JOIN author a \"\r\n    + \"    ON b.author_id = a.id \"\r\n    + \"WHERE b.sale_status = :saleStatus\"\r\n  )\r\n  Flux<BookAuthor> findBookBySaleStatusQuery(@Param(\"saleStatus\") SaleStatus saleStatus);\r\n}\nBookName.javaJoin 결과를 담을 객체입니다. record 로 선언된 클래스입니다.\npackage io.chagchagchag.example.r2dbc_example.repository;\r\n\r\npublic record BookName(\r\n    String name\r\n) {\r\n}\nTest\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookAuthor;\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookQueryRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.SaleStatus;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookQueryRepositoryExampleTest {\r\n  private final static Logger log = LoggerFactory.getLogger(BookQueryRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookQueryRepository bookQueryRepository;\r\n\r\n  @DisplayName(\"QUERY_METHOD__FOR_SALE_상태의_책을_조회\")\r\n  @Test\r\n  public void TEST_QUERY_METHOD__FOR_SALE_상태의_책을_조회(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    List<BookAuthor> bookAuthors = bookQueryRepository\r\n        .findBookBySaleStatusQuery(SaleStatus.FOR_SALE)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    bookAuthors.forEach(bookAuthor -> {\r\n      log.info(\"bookAuthor = \"+ bookAuthor);\r\n    });\r\n  }\r\n\r\n\r\n}\n출력결과\n2024-04-02T14:11:12.979+09:00  INFO [main] i.c.e.r.b.BookQueryRepositoryExampleTest : bookAuthor = BookAuthor[id=3, name=바람과 함께 사라지다, price=13000, publishedAt=1950-01-03T00:00, saleStatus=FOR_SALE, authorName=생로병사 편집부]\r\n2024-04-02T14:11:12.979+09:00  INFO [main] i.c.e.r.b.BookQueryRepositoryExampleTest : bookAuthor = BookAuthor[id=4, name=바람과 함께 사라지다, price=14000, publishedAt=1950-01-04T00:00, saleStatus=FOR_SALE, authorName=EBS]\r\n2024-04-02T14:11:12.979+09:00  INFO [main] i.c.e.r.b.BookQueryRepositoryExampleTest : bookAuthor = BookAuthor[id=5, name=바람과 함께 사라지다, price=15000, publishedAt=1950-01-05T00:00, saleStatus=FOR_SALE, authorName=내셔널지오그래픽]\r\n\r\nProcess finished with exit code 0"}},"/spring-data-r2dbc/r2dbc-drivers-r2dbc-spi":{"title":"R2dbc Drivers R2dbc Spi","data":{"r2dbc-드라이버-r2dbc-spi-connection-설정#R2DBC 드라이버, R2DBC SPI, Connection 설정":"","참고자료#참고자료":"r2dbc.io\nr2dbc.io/drivers\nr2dbc-spi\ngithub.com/r2dbc-spi\nasyncer-io/r2dbc-mysql\ngithub/asyncer-io/r2dbc-mysql\nGetting Started","dbms-별-r2dbc-지원-여부#DBMS 별 R2DBC 지원 여부":"참고 : r2dbc.io/drivers\n사용하려는 데이터베이스에 R2DBC가 지원되는지 여부는 r2dbc.io/drivers 에서도 확인 가능하며, Driver Implementations 절에 있는 내용을 정리해보면 아래와 같습니다.h2\nr2dbc-h2 - native driver implemented for H2 as a test database.\nkotlin 기반의 MySQL, PostgreSQL Database Driver\njasync-sql - R2DBC wrapper for Java & Kotlin Async Database Driver for MySQL and PostgreSQL (written in Kotlin).\nmysql, mariadb\nr2dbc-mysql - native driver implemented for MySQL (previously mirromutth/r2dbc-mysql).\nr2dbc-mariadb - native driver implemented for MariaDB.\nPostgreSQL\nr2dbc-postgresql - native driver implemented for PostgreSQL.\nOracle\noracle-r2dbc - native driver implemented for Oracle.\nMSSQL\nr2dbc-mssql - native driver implemented for Microsoft SQL Server.\netc\nclickhouse-r2dbc - R2DBC wrapper of async Java client for ClickHouse.\ncloud-spanner-r2dbc - driver for Google Cloud Spanner.\n이번 문서에서 알아볼 것은 r2dbc-mysql 입니다.","r2dbc-mysql#r2dbc-mysql":"참고 : r2dbc-mysql\nr2dbc-mysql 은 r2dbc-spi 와 Reactor Netty 기반으로 이루어진 라이브러리입니다.r2dbc-spi(Service Provider Interface) 라는 것은 하나의 interface 이며, r2dbc-mysql 의 실제 구현은 r2dbc-spi 를 Reactor Netty 기반으로 구현한 구현체로 이루어져 있습니다. Reactor Netty Client 기반으로 네트워킹을 수행하기 때문에 데이터베이스 IO 작업 수행시 애플리케이션의 응답성을 향상시키고, 동시성을 증가시키며, 리액티브 스트림 기반의 연산을 수행하기 때문에 데이터베이스의 변경 사항을 실시간으로 감지하고 처리할 수 있다는 것이 장점입니다.","r2dbc-spi#R2DBC SPI":"참고 : github.com/r2dbc-spi\nR2DBC SPI 에서 SPI 는 Service Provider Interface 라는 용어의 약자입니다.우리가 잘 알고 있는 JDBC 역시 JDBC SPI 가 존재하며, DBMS 별로 JDBC SPI 를 구현한 구현체를 통해서 Database 에 접근해서 작업을 수행합니다. R2DBC SPI 에는 크게 아래와 같은 주요 타입들이 있습니다.\nConnection 관련 : Connection, ConnectionFactory\nException 관련 : R2dbcException, R2dbcTimeoutException, R2dbcBadGrammarException, R2dbcDataIntegrityViolationException 등\nResult 값 관련 : Result, Row, RowMetadata\nStatement 관련 : Statement","r2dbc-mysql-connection-설정#r2dbc-mysql Connection 설정":"r2dbc-mysql 의 MySqlConnectionFactory, MySqlConnection, MySqlStatement, MySqlConnectionFactoryMetadata 는 위와 같은 방식으로 구성되어 있습니다.\nMySqlConnectionFactory : MySqlConnectionFactoryMetadata 객체를 필드로 가지고 있으며, MySqlConnection 객체를 생성합니다.\nMySqlConnection : MySqlConnectionFactory 에서 MySqlConnection 객체를 생성하며, MySqlConnection 을 이용하면 MySqlStatement 객체를 생성하는 것이 가능합니다.","mysqlconnectionfactory#MySqlConnectionFactory":"r2dbc-mysql 의 MySqlConnectionFactory 클래스는 아래와 같이 구성되어 있습니다.\ncreate(), getMetadata(), from(), getMySqlConnection(...) 등의 메서드가 있음을 확인 가능합니다.\n// ...\r\n\r\npublic final class MySqlConnectionFactory implements ConnectionFactory {\r\n\r\n    private final Mono<? extends MySqlConnection> client;\r\n\r\n    private MySqlConnectionFactory(Mono<? extends MySqlConnection> client) {\r\n        this.client = client;\r\n    }\r\n\r\n    @Override\r\n    public Mono<? extends MySqlConnection> create() {\r\n        return client;\r\n    }\r\n\r\n    @Override\r\n    public ConnectionFactoryMetadata getMetadata() {\r\n        return MySqlConnectionFactoryMetadata.INSTANCE;\r\n    }\r\n    \r\n    public static MySqlConnectionFactory from(MySqlConnectionConfiguration configuration) {\r\n        // ...\r\n    }\r\n\r\n    \r\n    private static Mono<MySqlConnection> getMySqlConnection(\r\n        final MySqlConnectionConfiguration configuration,\r\n        final MySqlSslConfiguration ssl,\r\n        final LazyQueryCache queryCache,\r\n        final SocketAddress address,\r\n        final String user,\r\n        @Nullable final CharSequence password\r\n    ) {\r\n        return Mono.fromSupplier(() -> {\r\n            // ...\r\n        }).flatMap(context -> Client.connect(\r\n            // ...\r\n        )).flatMap(client -> {\r\n            // ...\r\n        });\r\n    }\r\n\r\n    @Nullable\r\n    private static ZoneId retrieveZoneId(String timeZone) {\r\n        // ...\r\n    }\r\n\r\n    private static final class LazyQueryCache implements Supplier<QueryCache> {\r\n        // ...\r\n    }\r\n}\nMySqlConnectionFactory 의 from() 메서드는 MySqlConnectionConfiguration  객체를 인자로 받아서 MySqlConnectionFactory 객체를 생성하는 것을 확인 가능합니다.","mysqlconnectionconfiguration#MySqlConnectionConfiguration":"r2dbc-mysql 의 MySqlConnectionConfiguration 은 아래와 같이 여러가지 Database 의 메타데이터를 세팅할 수 있도록 builder 패턴으로 구현되어 있습니다.\npackage io.asyncer.r2dbc.mysql;\r\n\r\n// ...\r\n\r\n/**\r\n * A configuration of MySQL connection.\r\n */\r\npublic final class MySqlConnectionConfiguration {\r\n    private static final int DEFAULT_PORT = 3306;\r\n    private final boolean isHost;\r\n    private final String domain;\r\n    private final int port;\r\n    private final MySqlSslConfiguration ssl;\r\n    private final boolean tcpKeepAlive;\r\n    private final boolean tcpNoDelay;\r\n    @Nullable\r\n    private final Duration connectTimeout;\r\n    private final boolean preserveInstants;\r\n    \r\n    // ...\r\n\r\n    /**\r\n     * Creates a builder of the configuration. All options are default.\r\n     *\r\n     * @return the builder.\r\n     */\r\n    public static Builder builder() {\r\n        return new Builder();\r\n    }\r\n    \r\n    // ...\r\n\r\n    /**\r\n     * A builder for {@link MySqlConnectionConfiguration} creation.\r\n     */\r\n    public static final class Builder {\r\n        // ...\r\n        \r\n        public MySqlConnectionConfiguration build() {\r\n            // ...\r\n        }\r\n\r\n        public Builder database(@Nullable String database) {\r\n            this.database = database;\r\n            return this;\r\n        }\r\n        \r\n        // ...\r\n\r\n        public Builder host(String host) {\r\n            this.domain = requireNonNull(host, \"host must not be null\");\r\n            this.isHost = true;\r\n            return this;\r\n        }\r\n\r\n        public Builder password(@Nullable CharSequence password) {\r\n            this.password = password;\r\n            return this;\r\n        }\r\n\r\n        public Builder port(int port) {\r\n            require(port >= 0 && port <= 0xFFFF, \"port must be between 0 and 65535\");\r\n\r\n            this.port = port;\r\n            return this;\r\n        }\r\n\r\n        public Builder connectTimeout(@Nullable Duration connectTimeout) {\r\n            this.connectTimeout = connectTimeout;\r\n            return this;\r\n        }\r\n\r\n        public Builder user(String user) {\r\n            this.user = requireNonNull(user, \"user must not be null\");\r\n            return this;\r\n        }\r\n        \r\n        // ...\r\n        \r\n        private Builder() { }\r\n    }\r\n}","mysqlconnectionfactory-설정#MySqlConnectionFactory 설정":"위에서 살펴본 MySqlConnectionFactory , MySqlConnectionConfiguration 클래스를 이용해서 설정 코드를 작성해보면 아래와 같습니다.\npackage io.chagchagchag.example.r2dbc_example.config;\r\n\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionConfiguration;\r\nimport io.asyncer.r2dbc.mysql.MySqlConnectionFactory;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.r2dbc.connection.R2dbcTransactionManager;\r\nimport org.springframework.r2dbc.connection.init.ConnectionFactoryInitializer;\r\nimport org.springframework.r2dbc.connection.init.ResourceDatabasePopulator;\r\nimport org.springframework.transaction.ReactiveTransactionManager;\r\n\r\n@Configuration\r\npublic class R2dbcMySqlConfig {\r\n\r\n  @Bean\r\n  public MySqlConnectionFactory mySqlConnectionFactory(){\r\n    MySqlConnectionConfiguration config = MySqlConnectionConfiguration.builder()\r\n        .host(\"localhost\")\r\n        .port(23306)\r\n        .username(\"user\").password(\"test1357\")\r\n        .database(\"example\")\r\n        .build();\r\n\r\n    return MySqlConnectionFactory.from(config);\r\n  }\r\n\r\n  @Bean\r\n  public ReactiveTransactionManager transactionManager(MySqlConnectionFactory connectionFactory){\r\n    return new R2dbcTransactionManager(connectionFactory);\r\n  }\r\n\r\n  @Bean\r\n  public ConnectionFactoryInitializer initializer(MySqlConnectionFactory connectionFactory){\r\n    ConnectionFactoryInitializer initializer = new ConnectionFactoryInitializer();\r\n    initializer.setConnectionFactory(connectionFactory);\r\n    ResourceDatabasePopulator populator = new ResourceDatabasePopulator();\r\n    initializer.setDatabasePopulator(populator);\r\n    return initializer;\r\n  }\r\n\r\n}"}},"/spring-data-r2dbc/simple-r2dbc-code":{"title":"Simple R2dbc Code","data":{"r2dbc-기반-raw-레벨-코드-transaction#R2DBC 기반 Raw 레벨 코드, Transaction":""}},"/spring-data-r2dbc/transactional-transactional-operator":{"title":"Transactional Transactional Operator","data":{"transactional-transactionaloperator#@Transactional, TransactionalOperator":"Spring Data R2dbc 에서 Transactional 기반의 연산을 하는 방식은 아래와 같이 두가지 방식이 있습니다.\n@Transactional 애노테이션을 사용하는 방식\nTransactionalOperator 를 사용하는 방식\ntransactional() 메서드 사용\nexecute() 메서드 사용","mysql#mysql":"mysql 은 아래의 도커 환경을 사용했습니다.\nversion: '3.7'\r\nservices:\r\n  example-mysql:\r\n    image: mysql:5.7.39-debian\r\n    restart: always\r\n    #    command: --lower_case_table_names=1\r\n    container_name: example-mysql\r\n    hostname: example-mysql\r\n    ports:\r\n      - \"23306:3306\"\r\n    environment:\r\n      - MYSQL_USER=user\r\n      - MYSQL_USER_HOST=%\r\n      - MYSQL_PASSWORD=test1357\r\n      - MYSQL_DATABASE=example\r\n      - MYSQL_ROOT_HOST=%\r\n      - MYSQL_ROOT_PASSWORD=test1357\r\n      - TZ=UTC\r\n    command:\r\n      - --character-set-server=utf8mb4\r\n      - --collation-server=utf8mb4_unicode_ci\r\n    volumes:\r\n      - ./init/:/docker-entrypoint-initdb.d/\n샘플 스키마 및 데이터 INSERT\nCREATE TABLE IF NOT EXISTS example.book\r\n(\r\n    id           bigint auto_increment\r\n        primary key,\r\n    name         varchar(30) not null\r\n) default character set utf8 collate utf8_general_ci;\r\n\r\nINSERT INTO example.author(name)\r\nVALUES\r\n    ('찰스'),\r\n    ('1박2일 편집부'),\r\n    ('생로병사 편집부'),\r\n    ('EBS'),\r\n    ('내셔널지오그래픽');\r\n\r\n\r\nCREATE TABLE IF NOT EXISTS example.book\r\n(\r\n    id           bigint auto_increment\r\n        primary key,\r\n    name         varchar(30) not null,\r\n    price        bigint      null,\r\n    published_at datetime    null,\r\n    sale_status  varchar(20) not null,\r\n    author_id    bigint      not null\r\n) default character set utf8 collate utf8_general_ci;\r\n\r\nINSERT INTO example.book(\r\n    name, price, published_at, sale_status, author_id\r\n) VALUES\r\n('바람과 함께 사라지다', 11000, '1950-01-01 00:00:00', 'HOLD', 1),\r\n('바람과 함께 사라지다', 12000, '1950-01-02 00:00:00', 'HOLD', 2),\r\n('바람과 함께 사라지다', 13000, '1950-01-03 00:00:00', 'FOR_SALE', 3),\r\n('바람과 함께 사라지다', 14000, '1950-01-04 00:00:00', 'FOR_SALE', 4),\r\n('바람과 함께 사라지다', 15000, '1950-01-05 00:00:00', 'FOR_SALE', 5)\r\n;","applicationyml#application.yml":"로그 내에서 TRACE 레벨로 transaction 이 시작하고 종료됨을 확인하기 위해서 src/test/resources/application.yml 에 아래의 내용을 추가해줍니다.\nlogging:\r\n  level:\r\n    org.springframework.transaction.reactive: TRACE\r\n    org.springframework.transaction.interceptor: TRACE\r\n    org.springframework.transaction.ReactiveTransactionManager: TRACE\r\n    org.springframework.transaction.reactive.TransactionalOperator: TRACE\r\n    org.springframework.transaction.reactive.TransactionalOperatorImpl: TRACE\r\n    org.springframework.transaction.reactive.TransactionSynchronizationManager: TRACE\r\n    org.springframework.transaction.reactive.TransactionCallback: TRACE\r\n    org.springframework.transaction.reactive.TransactionContextManager: TRACE\r\n    io.asyncer.r2dbc.mysql.QUERY: trace\r\n    io.asyncer.r2dbc.mysql.MySqlConnection: trace\r\n#    io.asyncer.r2dbc.mysql.client: trace\r\n    org.springframework.r2dbc.connection.R2dbcTransactionManager: TRACE","book-bookfactory#Book, BookFactory":"엔티티는 Book.java 라고 하는 클래스이며, 이 엔티티 객체를 생성하는 것은 BookFactory 라는 클래스에서 담당합니다.","bookjava#Book.java":"package io.chagchagchag.example.r2dbc_example.repository.entity;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.type.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.AccessLevel;\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Getter;\r\nimport lombok.NoArgsConstructor;\r\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.relational.core.mapping.Table;\r\n\r\n@Table\r\n@Getter\r\n@NoArgsConstructor(access = AccessLevel.PRIVATE)\r\n@AllArgsConstructor\r\npublic class Book {\r\n  @Id\r\n  private Long id;\r\n  private String name;\r\n  private BigDecimal price;\r\n//  @Column(\"published_at\") // snake case 와 camel case 가 정확히 일치하면 생략 가능\r\n  private LocalDateTime publishedAt;\r\n//  @Column(\"sale_status\") // snake case 와 camel case 가 정확히 일치하면 생략 가능\r\n  private SaleStatus saleStatus;\r\n}","bookfactory#BookFactory":"package io.chagchagchag.example.r2dbc_example.repository.factory;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.type.SaleStatus;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport org.springframework.stereotype.Component;\r\n\r\n@Component\r\npublic class BookFactory {\r\n  public Book of(Long id, String name, BigDecimal price, LocalDateTime publishedAt, SaleStatus saleStatus){\r\n    return new Book(id, name, price, publishedAt, saleStatus);\r\n  }\r\n\r\n  public Book newBook(String name, BigDecimal price, LocalDateTime publishedAt){\r\n    return of(null, name, price, publishedAt, SaleStatus.WAITING_FOR_SALE);\r\n  }\r\n\r\n  public Book withSaleStatus(Book book, SaleStatus saleStatus){\r\n    return of(book.getId(), book.getName(), book.getPrice(), book.getPublishedAt(), book.getSaleStatus());\r\n  }\r\n}","repository#Repository":"package io.chagchagchag.example.r2dbc_example.repository;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport org.springframework.data.repository.reactive.ReactiveCrudRepository;\r\n\r\npublic interface BookSaveRepository extends ReactiveCrudRepository<Book, Long> {\r\n}","transactional-방식의-트랜잭션#@Transactional 방식의 트랜잭션":"","bookservicejava#BookService.java":"package io.chagchagchag.example.r2dbc_example.service;\r\n\r\nimport static io.chagchagchag.example.r2dbc_example.repository.type.SaleStatus.FOR_SALE;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookSaveRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.factory.BookFactory;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookService {\r\n  private final BookSaveRepository bookSaveRepository;\r\n  private final BookFactory bookFactory;\r\n\r\n  @Transactional\r\n  public Flux<Book> insertNewBook(String name, BigDecimal price, Long authorId){\r\n    Book newBook = bookFactory.newBook(name, price, LocalDateTime.now(), authorId);\r\n    return bookSaveRepository.save(newBook)\r\n        .flatMap(book -> {\r\n          Book forSale = bookFactory.withSaleStatus(book, FOR_SALE);\r\n          return bookSaveRepository.save(forSale);\r\n        })\r\n        .thenMany(bookSaveRepository.findAll());\r\n  }\r\n\r\n}","테스트-코드#테스트 코드":"package io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.service.BookService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookSaveRepositoryExampleTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookSaveRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookService bookService;\r\n\r\n\r\n  @DisplayName(\"TRANSACTIONAL_ANNOTATION__SAVE_NEW_BOOK\")\r\n  @Test\r\n  public void TEST_TRANSACTIONAL_ANNOTATION__SAVE_NEW_BOOK(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"save start >>> \");\r\n    List<Book> result = bookService\r\n        .insertNewBook(\"생각이 너무 많은 어른들을 위한 심리학\", BigDecimal.valueOf(2000), 1L)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"save end <<< \");\r\n\r\n\r\n    log.info(\"after result >>> \");\r\n    result.forEach(book -> {\r\n      log.info(\"book.name = {}, book.price ={}, book.saleStatus = {}, book.authorId = {}\",\r\n        book.getName(), book.getPrice(), book.getSaleStatus(), book.getAuthorId()\r\n      );\r\n    });\r\n  }\r\n}","출력결과#출력결과":"출력결과를 보면 Transaction 이 정상적으로 수행됨을 확인 가능합니다.","transactionaloperator-1--transactional#TransactionalOperator (1) : transactional()":"이번에는 TransactionalOperator 의 transactional() 메서드를 이용해서 트랜잭션을 처리하는 코드입니다.","bookservicejava-1#BookService.java":"package io.chagchagchag.example.r2dbc_example.service;\r\n\r\nimport static io.chagchagchag.example.r2dbc_example.repository.type.SaleStatus.FOR_SALE;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookSaveRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.factory.BookFactory;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.transaction.reactive.TransactionalOperator;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookService {\r\n  private final BookSaveRepository bookSaveRepository;\r\n  private final BookFactory bookFactory;\r\n  private final TransactionalOperator transactionalOperator;\r\n\r\n  // ...\r\n  \r\n  public Flux<Book> insertNewBookTransactionalOperator1(String name, BigDecimal price, Long authorId){\r\n    Book newBook = bookFactory.newBook(name, price, LocalDateTime.now(), authorId);\r\n    Flux<Book> flux = bookSaveRepository.save(newBook)\r\n        .flatMap(book -> {\r\n          Book forSale = bookFactory.withSaleStatus(book, FOR_SALE);\r\n          return bookSaveRepository.save(forSale);\r\n        })\r\n        .thenMany(bookSaveRepository.findAll());\r\n    return transactionalOperator.transactional(flux);\r\n  }\r\n  \r\n  // ...\r\n}","테스트-코드-1#테스트 코드":"package io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.service.BookService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookSaveRepositoryExampleTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookSaveRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookService bookService;\r\n  \r\n  // ...\r\n\r\n  @DisplayName(\"TEST_트랜잭셔널_오퍼레이터의_transactional_메서드로_트랜잭션_수행\")\r\n  @Test\r\n  public void TEST_트랜잭셔널_오퍼레이터의_transactional_메서드로_트랜잭션_수행(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"save start >>> \");\r\n    List<Book> result = bookService\r\n        .insertNewBookTransactionalOperator1(\"ETS 토익 정기시험 기출문제집\", BigDecimal.valueOf(2000), 1L)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"save end <<< \");\r\n\r\n\r\n    log.info(\"after result >>> \");\r\n    result.forEach(book -> {\r\n      log.info(\"book.name = {}, book.price ={}, book.saleStatus = {}, book.authorId = {}\",\r\n          book.getName(), book.getPrice(), book.getSaleStatus(), book.getAuthorId()\r\n      );\r\n    });\r\n  }\r\n\r\n}","출력결과-1#출력결과":"","transactionaloperator-2--execute#TransactionalOperator (2) : execute()":"","bookservicejava-2#BookService.java":"package io.chagchagchag.example.r2dbc_example.service;\r\n\r\nimport static io.chagchagchag.example.r2dbc_example.repository.type.SaleStatus.FOR_SALE;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.BookSaveRepository;\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.factory.BookFactory;\r\nimport java.math.BigDecimal;\r\nimport java.time.LocalDateTime;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.transaction.annotation.Transactional;\r\nimport org.springframework.transaction.reactive.TransactionalOperator;\r\nimport reactor.core.publisher.Flux;\r\n\r\n@Slf4j\r\n@RequiredArgsConstructor\r\n@Service\r\npublic class BookService {\r\n  private final BookSaveRepository bookSaveRepository;\r\n  private final BookFactory bookFactory;\r\n  private final TransactionalOperator transactionalOperator;\r\n    \r\n  // ...\r\n\r\n  public Flux<Book> insertNewBookTransactionalOperator2(String name, BigDecimal price, Long authorId){\r\n    Book newBook = bookFactory.newBook(name, price, LocalDateTime.now(), authorId);\r\n    Flux<Book> flux = bookSaveRepository.save(newBook)\r\n        .flatMap(book -> {\r\n          Book forSale = bookFactory.withSaleStatus(book, FOR_SALE);\r\n          return bookSaveRepository.save(forSale);\r\n        })\r\n        .thenMany(bookSaveRepository.findAll());\r\n    return transactionalOperator.execute(status -> flux);\r\n  }\r\n\r\n}","테스트-코드-2#테스트 코드":"package io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.service.BookService;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\n\r\n@SpringBootTest\r\npublic class BookSaveRepositoryExampleTest {\r\n  private final Logger log = LoggerFactory.getLogger(BookSaveRepositoryExampleTest.class);\r\n\r\n  @Autowired\r\n  private BookService bookService;\r\n  \r\n  // ...\r\n\r\n  @DisplayName(\"TEST_트랜잭셔널_오퍼레이터의_execute_메서드로_트랜잭션_수행\")\r\n  @Test\r\n  public void TEST_트랜잭셔널_오퍼레이터의_execute_메서드로_트랜잭션_수행(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    log.info(\"save start >>> \");\r\n    List<Book> result = bookService\r\n        .insertNewBookTransactionalOperator2(\"퓨처 셀프\", BigDecimal.valueOf(2000), 1L)\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n    log.info(\"save end <<< \");\r\n\r\n\r\n    log.info(\"after result >>> \");\r\n    result.forEach(book -> {\r\n      log.info(\"book.name = {}, book.price ={}, book.saleStatus = {}, book.authorId = {}\",\r\n          book.getName(), book.getPrice(), book.getSaleStatus(), book.getAuthorId()\r\n      );\r\n    });\r\n  }\r\n}","출력결과-2#출력결과":""}},"/spring-data-r2dbc/r2dbc-entity-template-r2dbc-entity-operations":{"title":"R2dbc Entity Template R2dbc Entity Operations","data":{"r2dbcentitytemplate-r2dbcentityoperations--fluentr2dbcoperations#R2dbcEntityTemplate, R2dbcEntityOperations,  FluentR2dbcOperations":"R2dbcEntityTemplate 은 R2dbcEntityOperations 를 implements 하고 있으며, R2dbcEntityOperation 은 기본적으로 필요한 SQL query 들을 메서드로 제공합니다. 그리고 R2dbcEntityOperation 은 FluentR2dbcOperations 를 extends 하고 있는데 이 FluentR2dbcOperations 를 사용하면 QueryDSL 을 사용하는 것처럼 체이닝을 통한 쿼리 수행이 가능합니다.예제코드는 https://github.com/chagchagchag/example-spring-data-r2dbc-mysql 에서 확인가능합니다.","참고#참고":"A Quick Look at R2DBC With Spring Data","fluentr2dbcoperations#FluentR2dbcOperations":"R2dbcEntityTemplate 은 R2dbcEntityOperations interface 를 implements 합니다. 그리고 R2dbcEntityOperations 는 FluentR2dbcOperations 를 extends 하고 있습니다. FluentR2dbcOperations 는 ReactiveInsertOperation, ReactiveUpdateOperation, ReactiveSelectOperation, ReactiveDeleteOperation 등의 interface 를 통해 풍부한 연산들을 제공합니다.\nReactiveInsertOperation : Database 의 insert 쿼리에 해당되는 R2dbc 메서드 들을 제공\nReactiveSelectOperation : Database 의 select 쿼리에 해당되는 R2dbc 메서드 들을 제공\nReactiveUpdateOperation : Database 의 update 쿼리에 해당하는 R2dbc 메서드 들을 제공\nReactiveDeleteOperation : Database 의 delete 쿼리에 해당하는 R2dbc 메서드 들을 제공","insert--reactiveinsertoperation#insert : (ReactiveInsertOperation)":"Insert 쿼리는 아래와 같은 방식으로 체이닝을 거칠수 있습니다.\ninsert → into → using\ninsert → using","into-쿼리#into 쿼리":"into 메서드 내에는 Query 를 실행해야 할 타겟 테이블 명을 전달합니다. String, SqlIdentifer 형태로 전달 가능하며, into가 제공되지 않을 경우 insert() 메서드 내부 정의에 따라 domainType 의 class 명 또는 @Table 애노테이션을 통해서 table 이름이 적용됩니다.","using-쿼리#using 쿼리":"insert 쿼리에서 사용할 Entity 를 using 절에 전달합니다. 전달받은 Entity 는 OutboundRow 로 변환되며, 변환된 OutboundRow 를 통해 쿼리가 실행됩니다.","내부-정의#내부 정의":"ReactiveInsertOperation 의 소스코드를 보면 아래와 같이 되어 있습니다. ReactiveInsertOperation 의 진입점은 insert() 메서드로 진입 가능하며, ReactiveInsertOperation interface 내에서는 TerminatingInsert, InsertWithTable 타입을 통해서 각자 체이닝이 가능하도록 되어 있습니다.","eg-단순한-책-데이터-1건-insert#e.g. 단순한 책 데이터 1건 insert":"아래는 R2dbcTemplate 을 Bean 으로 설정하는 코드입니다. 자세한 예제는 example-spring-data-r2dbc-mysql 을 참고해주세요.\n@Bean\r\npublic R2dbcEntityTemplate r2dbcEntityTemplate(\r\n  MySqlConnectionFactory connectionFactory\r\n){\r\nreturn new R2dbcEntityTemplate(connectionFactory);\r\n}\n간단한 Insert 쿼리를 수행하는 코드입니다. 테스트 코드는 아니고 단순 실행문입니다.\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\n\r\n@SpringBootTest\r\npublic class BookR2dbcOperationsInsertTest {\r\n  private static final Logger log = LoggerFactory.getLogger(BookR2dbcOperationsInsertTest.class);\r\n\r\n  @Autowired\r\n  private R2dbcEntityTemplate r2dbcEntityTemplate;\r\n\r\n  @DisplayName(\"INSERT_책_데이터_1개_insert\")\r\n  @Test\r\n  public void TEST_INSERT_책_데이터_1개_insert(){\r\n    // given\r\n    \r\n    // when\r\n    \r\n    // then\r\n    Book newBook = BookFixtures.newRandomBook(\"글루코스 혁명\", 1L);\r\n\r\n    Book inserted = r2dbcEntityTemplate.insert(Book.class)\r\n        .into(\"book\")\r\n        .using(newBook)\r\n        .block();\r\n\r\n    log.info(\"book.name = {}, book.price = {} \", inserted.getName(), inserted.getPrice());\r\n  }\r\n  \r\n}","select--reactiveselectoperation#select : (ReactiveSelectOperation)":"Select 쿼리는 아래와 같은 방식으로 체이닝을 거칠 수 있습니다.\nselect → from → as → matching → 실행\nselect → from → matching → 실행\nselect → as → matching → 실행\nselect → matching → 실행\nselect → 실행","from-쿼리#from 쿼리":"from() 메서드에는 query 를 실행할 타겟 테이블의 이름을 전달해줘야 합니다. String, SqlIdentifer 형태로 전달 가능하며, from() 메서드가 제공되지 않을 경우 select() 메서드 내부 정의에 따라 domainType 의 class 명 또는 @Table 애노테이션을 통해서 table 이름이 적용됩니다.","as-쿼리#as 쿼리":"Entity 의 모든 필드를 매핑하는 것이 아닌 특정 필드만 mapping 하려고 할 때 사용합니다. 흔히 이야기하는 프로젝션(Projection)을 하고자 할 때 사용합니다. Entity 의 일부 필드만 담고 있는 서브 클래스를 넘겨서 projection 이 가능합니다.","matching-쿼리#matching 쿼리":"Select 쿼리의 where 문에 해당합니다. Query 객체를 전달해서 Query 의 where 에 해당하는 조건식을 설정합니다.","termination-쿼리#termination 쿼리":"count, exists, first, one, all 등과 같은 연산을 수행하는 쿼리입니다.\ncount() : 조회하려는 데이터 row 의 개수를 반환합니다\nexists() : 조건에 맞는 데이터 row 가 존재하는지 여부를 체크해서 반환합니다.\nfirst() : 조건에 맞는 첫번째 row 를 반환합니다.\none() : 조건에 맞는 하나의 row 를 반환합니다. 하나 이상의 row 가 매칭될 경우 Exception 이 발생합니다.\nall() : 조건에 맞는 모든 row 를 반환합니다.","내부-정의-1#내부 정의":"ReactiveSelectOperation 의 소스코드를 보면 아래와 같이 되어 있습니다. ReactiveSelectOperation 의 진입점은 select() 메서드로 진입 가능하며, ReactiveSelectOperation interface 내에서는 TerminatingSelect, SelectWithQuery, SelectWithProjection, SelectWithTable 타입을 통해서 각자 체이닝이 가능하도록 되어 있습니다.","eg-간단한-select#e.g. 간단한 select":"아래는 R2dbcTemplate 을 Bean 으로 설정하는 코드입니다. 자세한 예제는 example-spring-data-r2dbc-mysql 을 참고해주세요.\n@Bean\r\npublic R2dbcEntityTemplate r2dbcEntityTemplate(\r\n  MySqlConnectionFactory connectionFactory\r\n){\r\nreturn new R2dbcEntityTemplate(connectionFactory);\r\n}\n간단한 Select 쿼리를 수행하는 코드입니다. 테스트 코드는 아니고 단순 실행문입니다.\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport io.chagchagchag.example.r2dbc_example.repository.valueobject.BookName;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\nimport org.springframework.data.relational.core.query.Criteria;\r\nimport org.springframework.data.relational.core.query.Query;\r\n\r\n@SpringBootTest\r\npublic class BookR2dbcOperationsSelectTest {\r\n  private static final Logger log = LoggerFactory.getLogger(BookR2dbcOperationsSelectTest.class);\r\n\r\n  @Autowired\r\n  private R2dbcEntityTemplate r2dbcEntityTemplate;\r\n\r\n  @DisplayName(\"SELECT_단순한_SELECT_쿼리\")\r\n  @Test\r\n  public void TEST_SELECT_단순한_SELECT_쿼리(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    Criteria equalsBookName = Criteria.where(\"name\").is(\"글루코스 혁명\");\r\n    Criteria priceGt = Criteria.where(\"price\").greaterThan(1000);\r\n    Criteria whereCriteria = equalsBookName.and(priceGt);\r\n\r\n    Query where = Query.query(whereCriteria).limit(10);\r\n\r\n    List<BookName> selected = r2dbcEntityTemplate.select(Book.class)\r\n        .from(\"book\")\r\n        .as(BookName.class)\r\n        .matching(where)\r\n        .all()\r\n        .toStream()\r\n        .collect(Collectors.toList());\r\n\r\n    selected.forEach(bookName -> {\r\n      log.info(\"book.name = \" + bookName);\r\n    });\r\n  }\r\n}","update--reactiveupdateoperation#update : (ReactiveUpdateOperation)":"Update 쿼리는 아래와 같은 방식으로 체이닝을 거칠 수 있습니다.\nupdate → inTable → matching → apply\nupdate → inTable → apply\nupdate → matching → apply\nupdate → apply","intable-쿼리#inTable 쿼리":"inTable() 메서드에는 query 를 실행할 타겟 테이블의 이름을 전달해줘야 합니다. String, SqlIdentifer 형태로 전달 가능하며, inTable() 메서드가 제공되지 않을 경우 update() 메서드 내부 정의에 따라 domainType 의 class 명 또는 @Table 애노테이션을 통해서 table 이름이 적용됩니다.","matching-쿼리-1#matching 쿼리":"Update 쿼리의 where 문에 해당합니다. Query 객체를 전달해서 Query 의 where 에 해당하는 조건식을 설정합니다. matching 을 생략할 경우 테이블 내의 모든 로우에 대한 update 를 하겠다는 의미가 됩니다.","apply-쿼리#apply 쿼리":"apply() 메서드는 실제 update 작업을 수행하는 메서드입니다. insert() 와는 다르게 Entity 전체를 전달하는 것이 아니라 Update 객체를 인자값으로 전달합니다. Update 객체는 내부에 Map 타입의 필드가 있는데 이 Map 은 <SqlIdentifier : Value> 형식의 데이터를 처리합니다.리턴 값으로 쿼리의 수행 결과로 영향을 받는 row 의 수를 리턴합니다.","내부-정의-2#내부 정의":"ReactiveUpdateOperation 의 소스코드를 보면 아래와 같이 되어 있습니다. ReactiveUpdateOperation 의 진입점은 update() 메서드로 진입 가능하며, ReactiveUpdateOperation interface 내에서는 TerminatingUpdate, UpdateWithQuery, UpdateWithTable 타입을 통해서 각자 체이닝이 가능하도록 되어 있습니다.","eg-간단한-책-데이터-update#e.g. 간단한 책 데이터 update":"아래는 R2dbcTemplate 을 Bean 으로 설정하는 코드입니다. 자세한 예제는 example-spring-data-r2dbc-mysql 을 참고해주세요.\n@Bean\r\npublic R2dbcEntityTemplate r2dbcEntityTemplate(\r\n  MySqlConnectionFactory connectionFactory\r\n){\r\nreturn new R2dbcEntityTemplate(connectionFactory);\r\n}\n간단한 Update 쿼리를 수행하는 코드입니다. 테스트 코드는 아니고 단순 실행문입니다.\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport java.math.BigDecimal;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\nimport org.springframework.data.relational.core.query.Criteria;\r\nimport org.springframework.data.relational.core.query.Query;\r\nimport org.springframework.data.relational.core.query.Update;\r\n\r\n@SpringBootTest\r\npublic class BookR2dbcOperationsUpdateTest {\r\n  private static final Logger log = LoggerFactory.getLogger(BookR2dbcOperationsUpdateTest.class);\r\n\r\n  @Autowired\r\n  private R2dbcEntityTemplate r2dbcEntityTemplate;\r\n\r\n  @DisplayName(\"간단한_UPDATE_QUERY\")\r\n  @Test\r\n  public void TEST_간단한_UPDATE_QUERY(){\r\n    // given\r\n\r\n    // when\r\n\r\n    // then\r\n    Criteria equalsBookName = Criteria.where(\"name\").is(\"맛도리여행\");\r\n    Criteria priceGt = Criteria.where(\"price\").greaterThanOrEquals(BigDecimal.valueOf(1000));\r\n    Criteria where = equalsBookName.and(priceGt);\r\n\r\n    Update update = Update.update(\"price\", BigDecimal.valueOf(10000));\r\n\r\n    r2dbcEntityTemplate.update(Book.class)\r\n        .inTable(\"book\")\r\n        .matching(Query.query(where))\r\n        .apply(update)\r\n        .doOnNext(affected -> log.info(\"affected row count = {}\", affected))\r\n        .block();\r\n  }\r\n\r\n}","delete--reactivedeleteoperation#delete : (ReactiveDeleteOperation)":"Delete 쿼리는 아래와 같은 방식으로 체이닝을 거칠 수 있습니다.\ndelete → from → matching → all\ndelete → from → all\ndelete → matching → all\ndelete → all","from-쿼리-1#from 쿼리":"from() 메서드에는 query 를 실행할 타겟 테이블의 이름을 전달해줘야 합니다. String, SqlIdentifer 형태로 전달 가능하며, from() 메서드가 제공되지 않을 경우 delete() 메서드 내부 정의에 따라 domainType 의 class 명 또는 @Table 애노테이션을 통해서 table 이름이 적용됩니다.","matching-쿼리-2#matching 쿼리":"Delete 쿼리의 where 문에 해당합니다. Query 객체를 전달해서 Query 의 where 에 해당하는 조건식을 설정합니다. matching 을 생략할 경우 테이블 내의 모든 로우에 대한 delete 를 하겠다는 의미가 됩니다.","all-쿼리#all 쿼리":"all() 메서드는 실제 delete 작업을 수행하는 메서드입니다.리턴 값으로 delete 쿼리의 수행 결과로 영향을 받는 row 의 수를 리턴합니다.","내부-정의-3#내부 정의":"ReactiveUpdateOperation 의 소스코드를 보면 아래와 같이 되어 있습니다. ReactiveUpdateOperation 의 진입점은 update() 메서드로 진입 가능하며, ReactiveUpdateOperation interface 내에서는 TerminatingUpdate, UpdateWithQuery, UpdateWithTable 타입을 통해서 각자 체이닝이 가능하도록 되어 있습니다.","eg-간단한-책-데이터-delete#e.g. 간단한 책 데이터 delete":"아래는 R2dbcTemplate 을 Bean 으로 설정하는 코드입니다. 자세한 예제는 example-spring-data-r2dbc-mysql 을 참고해주세요.\n@Bean\r\npublic R2dbcEntityTemplate r2dbcEntityTemplate(\r\n  MySqlConnectionFactory connectionFactory\r\n){\r\nreturn new R2dbcEntityTemplate(connectionFactory);\r\n}\n간단한 Delete 쿼리를 수행하는 코드입니다. 테스트 코드는 아니고 단순 실행문입니다.\npackage io.chagchagchag.example.r2dbc_example.book;\r\n\r\nimport io.chagchagchag.example.r2dbc_example.repository.entity.Book;\r\nimport java.math.BigDecimal;\r\nimport org.junit.jupiter.api.DisplayName;\r\nimport org.junit.jupiter.api.Test;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.boot.test.context.SpringBootTest;\r\nimport org.springframework.data.r2dbc.core.R2dbcEntityTemplate;\r\nimport org.springframework.data.relational.core.query.Criteria;\r\nimport org.springframework.data.relational.core.query.Query;\r\n\r\n@SpringBootTest\r\npublic class BookR2dbcOperationsDeleteTest {\r\n  private static final Logger log = LoggerFactory.getLogger(BookR2dbcOperationsDeleteTest.class);\r\n  \r\n  @Autowired\r\n  private R2dbcEntityTemplate r2dbcEntityTemplate;\r\n  \r\n  @DisplayName(\"간단한_DELETE_QUERY\")\r\n  @Test\r\n  public void TEST_간단한_DELETE_QUERY(){\r\n    // given\r\n\r\n    // when\r\n    \r\n    // then\r\n    Criteria equalsBookName = Criteria.where(\"name\").is(\"맛도리여행\");\r\n    Criteria priceGt = Criteria.where(\"price\").greaterThanOrEquals(BigDecimal.valueOf(1000));\r\n    Criteria where = equalsBookName.and(priceGt);\r\n\r\n    r2dbcEntityTemplate.delete(Book.class)\r\n        .from(\"book\")\r\n        .matching(Query.query(where))\r\n        .all()\r\n        .doOnNext(affected -> log.info(\"deleted row count = {}\", affected))\r\n        .block();\r\n  }\r\n  \r\n}","r2dbcentityoperations#R2dbcEntityOperations":"R2dbcEntityOperations 는 위에서 살펴본 FluentR2dbcOperations 에서 제공하는 insert, select, update, delete 연산에 대한 Operation 들 외에도 다양한 종류의 쿼리를 수행할 수 있도록 다양한 메서드 들을 제공하고 있습니다.\ncount (Query, Class<?> entityClass)\ndelete (Query, Class<?> entityClass), delete (T)\nexists (Query, Class<?> entityClass)\ninsert (T)\nselect (Query, Class<?> entityClass)\nselectOne (Query, Class<?> entityClass)\nupdate (Query, Class<?> entityClass), update (T)\nquery (PreparedOperation<?> operation, Class<?> entityClass, Class <T> resultType) 및 다양한 오버로딩 된 query(...) 메서드 들"}},"/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{}},"/spring-data-redis-reactive/known-cache-strategies":{"title":"Known Cache Strategies","data":{"많이-알려진-캐시-전략들#많이 알려진 캐시 전략들":"Cache Aside\nfeat. Spring Cache Manager\nWrite Back\nfeat. 작업 대기열\nWirte Through\n캐싱과 IO 작업을 함께 처리"}},"/spring-data-redis-reactive/luttuce-examples":{"title":"Luttuce Examples","data":{"luttuce-기반-예제-코드들#luttuce 기반 예제 코드들":""}},"/spring-data-redis-reactive/reactive-operations":{"title":"Reactive Operations","data":{"reactiveoperations#ReactiveOperations":""}},"/spring-data-redis-reactive/redis-connector":{"title":"Redis Connector","data":{"redis-connector-lettuce-jedis#Redis Connector (Lettuce, Jedis)":""}},"/spring-data-redis-reactive/redis-data-structures":{"title":"Redis Data Structures","data":{"레디스-자료구조들#레디스 자료구조들":"String\nLIST\nSET\nSorted Set\nSortedSet\r\n정렬된 Set 자료구조입니다.\r\n잘 알려진 MergeSort 나 개선된 QuickSort 등을 통해 내부적으로 정렬을 수행하는데 보통 O(Nlog(M)) 또는 O(log(N)) 이 소요되는 경우가 많습니다.\r\n예를 들면, 주식 종목 검색이나 주식 종목 초성검색을 구현할 때 Sorted Set을 사용합니다.\r\n혹시라도 주식 종목검색, 초성검색 예제가 궁금하다면 여기를 참고하시면 될 것 같습니다.List, Set\r\nList 의 LPUSH, LPOP, RPUSH, RPOP 을 적절하게 활용해서 작업 대기열을 구성할 수도 있습니다. 요청의 고유값을 식별하기 위해서는 Set 에 요청 ID 를 기록해두는 방식을 사용합니다.\r\n최근 트렌드는 가급적 작업 대기열 등은 Kafka,Kafka Streams 또는 RabbitMQ를 사용하는 추세입니다. 하지만 팀내 인력상황, 마감기한 및 여러가지 운영 요소로 인해 큰 비용이 필요하지 않을 경우 간단하게 레디스 기반으로 작업 대기열을 구성하는 경우도 많습니다.\r\n이 경우, Redis 서버가 다운될 경우 작업 대기열의 데이터들 모두 유실될 수 있다는 점에 착안해서 예외 처리등을 명확히 해둬야 합니다.\nString\r\n특정 값을 저장하는 용도로 사용합니다. 단순 문자열을 저장할 수도 있겠지만 구분자(DELIMITER)를 기반으로 여러가지 요청 식별자를 조합해서 어떤 요청이 있었는지를 기반으로 조회가 가능하도록 저장하는 경우도 많습니다.","string-자료구조#String 자료구조":"단순한 문자열 데이터 형식\r\n주요 연산으로는 set, get 이 있습니다.\r\nset, get 은 시간복잡도가 각각 O(1) 입니다.","eg-set#e.g. set":"set coupon:1 \"Apple 50% Discount Event\"\r\nOK","eg-get#e.g. get":"get coupon:1\r\n\"Apple 50% Discount Event\"\n이렇게 생성한 자료구조는 del 명령어로 삭제 가능합니다.","list-자료구조#List 자료구조":"리스트와 같은 선형자료 구조\r\nLPUSH 로 리스트의 제일 왼쪽(head)에 데이터를 추가할 수도 있고 RPUSH 로 리스트의 제일 오른쪽(tail)에 데이터를 추가할 수 있습니다.","lrange#LRANGE":"redis.io/commands - LRANGE\nLIST 내의 지정된 범위에 해당하는 요소들을 반환합니다.\n시간복잡도 O(S+N) 에 해당하는 연산입니다.\nS는 시작 Offset 의 Head/Tail 로부터의 거리 (distance)를 의미합니다.\nN은 지정된 Range 내에 속한 요소들의 개수를 의미합니다.\nLRANGE key start stop","lpush#LPUSH":"redis.io/commands - LPUSH\n리스트의 제일 왼쪽(head)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLPUSH key element [element ...]","rpush#RPUSH":"redis.io/commands - RPUSH\n리스트의 제일 오른쪽(tail)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nRPUSH key element [element ...]","lpop#LPOP":"redis.io/commands - LPOP\n리스트의 첫 번째 요소(Head)를 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nLPOP key [count]\n리스트의 첫 번째로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 제일 처음 요소로부터 3개의 요소를 POP 하게 됩니다.","rpop#RPOP":"redis.io/commands - RPOP\n리스트의 제일 마지막 요소(Tail)을 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nRPOP key [count]\n리스트의 마지막으로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 맨끝에서 3개의 요소를 POP 하게 됩니다.","llen#LLEN":"redis.io/commands - LLEN\n현재 리스트의 사이즈를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLLEN key","lpos#LPOS":"redis.io/commands - LPOS\n리스트 내에서 일치하는 요소를 찾는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다. 만약 MAXLEN 을 명시해서 호출하면 상수 시간 내에 수행됩니다.\nLPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]","set-자료구조#SET 자료구조":"어느 언어에서든 제공되는 Set 개념에 해당하는 자료구조입니다.","smembers#SMEMBERS":"redis.io/commands - SMEMBERS\nkey 에 해당하는 Set 에 저장된 모든 요소들을 반환합니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nSMEMBERS key","sadd#SADD":"redis.io/commands - SADD\nkey 에 해당하는 Set 에 요소를 추가합니다. 이때 요소 하나만 지정할 수도 있고 요소 여러개를 지정해서 여러개의 요소를 한번에 추가할 수 도 있습니다.\n요소 하나를 추가할 때는 시간복잡도 O(1) 에 해당하는 연산입니다. 만약 요소 K 개를 하나의 명령어로 추가할 경우에는 O(K) 의 시간복잡도를 가집니다.\nSADD key member [member ...]","sismember#SISMEMBER":"redis.io/commands - SISMEMBER\nkey 에 해당하는 Set 에 member 에 해당하는 요소가 존재하는지 검사합니다. 존재한다면 1을, 존재하지 않는다면 0 을 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSISMEMBER key member","scard#SCARD":"redis.io/commands - SCARD\nkey 에 해당하는 Set의 사이즈(Cardinality, 요소의 갯수)를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSCARD key","srem#SREM":"redis.io/commands - SREM\nkey 에 해당하는 Set 내에서 인자값으로 전달받은 member를 삭제하는 연산입니다. 지우고자 하는 요소가 여러개라면 지루려는 요소들을 모두 인자값으로 전달해주면 됩니다.\n지워야하는 요소수가 K개일 경우 시간복잡도 O(K) 가 소요되는 연산입니다.\nSREM key member [member ...]","sorted-set#Sorted Set":"스코어를 기반으로 순서를 지정해서 정렬된 상태로 저장하는 문자열 컬렉션입니다.\r\nSet 자료구조이므로 중복을 허용하지 않습니다.","zrange#ZRANGE":"redis.io/commands - ZRANGE\nkey 에 해당하는 SortedSet 에서 cli 에 명시한 Range 에 해당하는 요소들을 리턴하는 연산입니다.\nO(log(N)+M) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미하며, M 은 반환된 요소 수를 의미합니다.\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]\r\n[WITHSCORES]","zadd#ZADD":"redis.io/commands - ZADD\nkey 에 해당하는 SortedSet 에 score 와 함께 요소들을 저장합니다. score 를 기반으로 정렬되며, score가 같은 요소는 문자열 정렬을 통해 오름차순 정렬되어 저장됩니다.\nO(log(N)) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미합니다.\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member\r\n...]\ne.g. redis> ZADD myzset 1 \"one\"\ne.g. redis> ZADD myzset 2 \"two\" 3 \"three\"","zcard#ZCARD":"redis.io/commands - ZCARD\nkey 에 해당하는 SortedSet 의 사이즈(Cardinality, 요소의 개수)를 리턴합니다.\nO(1) 의 시간복잡도가 소요됩니다.\nZCARD key","zpopmin#ZPOPMIN":"redis.io/commands - ZPOPMIN\nkey 에 해당하는 SortedSet 에서 score 가 가장 낮은 순으로 요소들 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMIN key [count]","zpopmax#ZPOPMAX":"redis.io/commands - ZPOPMAX\nkey 에 해당하는 SortedSet 에서 score 가 가장 높은 요소들을 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMAX key [count]"}},"/spring-data-r2dbc/spring-data-object-mapping-and-creation":{"title":"Spring Data Object Mapping and Creation","data":{"spring-data-reactive-의-객체생성-방식과-필드-매핑방식#Spring Data Reactive 의 객체생성 방식과 필드 매핑방식":""}},"/spring-data-redis-reactive/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{"spring-data-redis-reactive#Spring Data Redis Reactive":""}},"/spring-data-redis-reactive/redis-replication-sentinel-cluster":{"title":"Redis Replication Sentinel Cluster","data":{"redis-replicationsentinel-cluster#Redis Replication,Sentinel, Cluster":"Redis 를 Single Instance 로 구성할때, Redis Replication 으로 구성할 때, Redis Sentinel 구조로 구성할 때, Cluster 구조로 구성할 때 각각에 대한 장점과 특징을 알아봅니다.이 내용을 알아보는 이유는 Redis Connector (Lettuce, Jedis) 중에 Cluster 를 온전히 지원하지 않는 경우가 있기 때문입니다.","redis-single-instance#Redis Single Instance":"Redis 를 1기로 운영할 때의 모습입니다. 이 경우 1기만 존재하는 Redis 서버가 장애가 생겼을 경우 다른 Client 들의 접속이 불가능하게 됩니다.","redis-replication#Redis Replication":"master 와 replication 으로 구성된 Redis 환경입니다. master 에 데이터가 업데이트 되었을 때 master 는 변경사항을 replica 들에 반영하는 Sync 작업을 수행합니다. 각각의 Replica 는 읽기 전용 노드이며, 하나의 노드에 문제가 생기면 다른 Replica 노드에 데이터가 복제되어 있기 때문에 데이터가 유실되지 않습니다.하지만 master 에 문제가 생겼을 경우 개발자가 직접 Replica 중 하나를 master 로 변경해주는 작업을 수행해줘야 합니다.","redis-sentinel#Redis Sentinel":"Redis Replication 의 구조에서 sentinel 의 개념이 추가된 구조입니다. master 에 문제가 생겼을 때는 Replica 각각이 투표를 통해서 master 를 선출하게 됩니다. 만약 장애가 났었던 이전의 master 가 복구가 완료되면 Replica 로 master 를 바라보게 됩니다.sentinel 구조로 전환하면 Automatic Failover, 고가용성이 제공된다는 점에서 장점을 갖게 됩니다.","redis-cluster#Redis Cluster":"Redis Sentinel 들이 모여서 하나의 클러스터를 이루는 것을 의미합니다. 클러스터 구조에서는 데이터를 자동으로 파티셔닝이 가능하며, 고가용성 (High Availability) 을 가지며, Automatic Failover 가 모두 제공된다는 점에서 장점을 가집니다."}}}