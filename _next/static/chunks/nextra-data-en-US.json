{"/spring-data-mongodb-reactive":{"title":"Spring Data Mongodb Reactive","data":{"spring-data-mongodb-reactive#Spring Data MongoDB Reactive":""}},"/":{"title":"Introduction","data":{"":"Spring Data Reactive 문서보관소입니다."}},"/spring-data-mongodb-reactive/mongodb-features":{"title":"Mongodb Features","data":{"mongodb-features#MongoDB Features":"","mongo-db#Mongo DB":"MongoDB 는 오픈소스 NoSQL 데이터베이스입니다. 2007 년 10gen 이라는 회사에서 Paas 로 MongoDB 개발을 시작했고, 2009 년에 오픈소스 모델로 전환해서 사용지원, 기타 서비스를 제공하는 방식을 따르게 되었습니다. 2013년에는 10gen 이라는 회사 명이 MongoDB Inc. 로 변경되었으며 현재 전 세계에서 대중적으로 알려진 NoSQL 데이터베이스가 되었습니다.스키마가 정의되어 있지 않아도 데이터 저장을 유연하게 할 수 있습니다. 또한 다양한 종류의 index를 지원하고, 4.0 부터 multi docoument transaction 을 지원하기에 트랜잭션의 ACID 가 보장됩니다.몽고DB를 운영할 때 레플리카셋과 샤드 클러스터를 적용하면 데이터를 여러 노드에 분산해서 저장하고 처리하는 것이 가능해지며, 장애에 내성이 강한 데이터베이스로 전환이 가능합니다.","mongodb-bson#MongoDB BSON":"Binary 형식의 JSON 데이터를 BSON 이라고 부릅니다. MongoDB는 데이터를 BSON 형식으로 저장합니다.BSON 은 JSON 보다 인코딩/디코딩이 빠르고, 다양한 데이터 타입들이 BSON 에 지원됩니다.\ndocument id : ObjectId\n바이너리 데이터 : BinData\n날짜 : Date, ISODate\n정규표현식","mongodb-bson-인코딩#MongoDB BSON 인코딩":"BSON 은 필드의 순서에 따라서 인코딩이 달라지며, 첫줄은 document 의 크기를 의미합니다.","mongodb-document-collection-database#MongoDB Document, Collection, Database":"","mongodb-트랜잭션#MongoDB 트랜잭션":""}},"/spring-data-mongodb-reactive/mongodb-tools":{"title":"Mongodb Tools","data":{"mongodb-설치시-필요한-도구들-및-설치관련-내용들-정리#MongoDB 설치시 필요한 도구들 및 설치관련 내용들 정리":"","mongodb-클라우드-인스턴스#MongoDB 클라우드 인스턴스":"문서 작성을 위한 용도로 사용하는 MongoDB는 Atlas MongoDB 를 사용했습니다. 개발PC가 점점 노후화 되어서 팬 소음도 너무 크고 가끔은 컴퓨터가 터질것 같아 선택하게 되었습니다. 데이터베이스 등급은 무료 인스턴스를 선택했습니다.","mongodb-docker#MongoDB docker":"로컬에서만 실행하시거나, testcontainers 를 사용중이시라면, docker-compose 파일을 만들어두고 이것을 읽어들이는게 제일 편하고 빠릅니다. 이런 이유로 이번 문서에서는 docker-compose 파일도 추가해둡니다.","single-broker#single broker":"브로커 1기만 갖춰진 docker-compose 파일입니다.\nversion: '3.8'\r\nservices:\r\n  mongo:\r\n    image: mongo:6.0.5\r\n    ports:\r\n      - 27017:27017\r\n    environment:\r\n      MONGO_INITDB_DATABASE: foobar\r\n      MONGO_INITDB_ROOT_USERNAME: root\r\n      MONGO_INITDB_ROOT_PASSWORD: 1111","multi-broker#multi broker":"","mongodb-compass#MongoDB compass":"Mongodb Compass\nwindows :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-win32-x64.msi\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/\nmacos :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-darwin-arm64.dmg\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/","mongodb-data-explorer#MongoDB Data Explorer":"설치한 Atlas 인스턴스는 Compass 로도 접속할 수 있겠지만, 브라우저에서 사용가능한 Mongodb Data Explorer 로도 접속가능합니다.\nhttps://cloud.mongodb.com","mongoose#mongoose":"몽구스를 이용한 스키마 모델링 방법도 있습니다.설치\nyarn add mongooose\nMongoose 사용법에 대해서는 시간이 되는대로 정리하겠습니다.","mongodb-shell#MongoDB Shell":"","설치--환경변수-등록#설치 & 환경변수 등록":"windows\nhttps://downloads.mongodb.com/compass/mongosh-2.0.0-x64.msi 다운로드 & 설치\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nmacos\nbrew isntall mongosh\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nbrew install 이 아닌 Manually Install 을 원하신다면 Install Mongosh → Procedure → macOS 를 선택해주세요. 그리고 사용가능한 바이너리를 확인하시려면  Install from .zip File. 을 확인해주세요.\nMS윈도우즈 사용자의 경우 다운로드 받은 mongosh 파일을 Path 에 추가시킨 후 터미널에서 접근 가능합니다. MacOS 사용자의 경우에도 brew 로 설치하기보다는 별도로 다운로드 받은 디렉터리를 추가하고 싶다면 별도로 바이너리를 다운받으신후 Path 에 추가해주시면 됩니다.제 경우에는 MacOS 를 사용할 때에는 ~/username/workspace/bin 같은 디렉터리에 바이너리를 모아두었었는데, Manually Install 방식이 친절하게 제공되면 Manually Install 로 설치 후에 필요 없어지면 관련 디렉터리를 지워버리는 방식으로 가능하면 이 방식으로 설치를 했습니다. 가끔은 불편하더라도 나중에 관리가 깔끔하게 되려면 오히려 이런 방식이 더 편한 것 같습니다.","database-선택-접근#Database 선택, 접근":"### 데이터베이스 선택\r\nuse [데이터베이스명]\r\n\r\n### 현재 사용중인 데이터베이스 확인\r\ndb\r\n\r\n### 서버 내의 데이터베이스 리스트\r\n### 최소 한개의 Document 를 가진 DB만 출력됩니다.\r\nshow dbs\r\n\r\n### 컬렉션에 Document insert\r\ndb.[컬렉션명].insertOne({k:v, ...})\r\n\r\n### db 내에 도큐먼트 조회\r\ndb.[데이터베이스명].find()"}},"/spring-data-r2dbc":{"title":"Spring Data R2DBC","data":{}},"/spring-data-r2dbc/spring-data-r2dbc":{"title":"Spring Data R2dbc","data":{"spring-data-r2dbc#Spring Data R2DBC":""}},"/spring-data-redis-reactive/known-cache-strategies":{"title":"Known Cache Strategies","data":{"많이-알려진-캐시-전략들#많이 알려진 캐시 전략들":"Cache Aside\nfeat. Spring Cache Manager\nWrite Back\nfeat. 작업 대기열\nWirte Through\n캐싱과 IO 작업을 함께 처리"}},"/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{}},"/spring-data-redis-reactive/redis-data-structures":{"title":"Redis Data Structures","data":{"레디스-자료구조들#레디스 자료구조들":"String\nLIST\nSET\nSorted Set\nSortedSet\r\n정렬된 Set 자료구조입니다.\r\n잘 알려진 MergeSort 나 개선된 QuickSort 등을 통해 내부적으로 정렬을 수행하는데 보통 O(Nlog(M)) 또는 O(log(N)) 이 소요되는 경우가 많습니다.\r\n예를 들면, 주식 종목 검색이나 주식 종목 초성검색을 구현할 때 Sorted Set을 사용합니다.\r\n혹시라도 주식 종목검색, 초성검색 예제가 궁금하다면 여기를 참고하시면 될 것 같습니다.List, Set\r\nList 의 LPUSH, LPOP, RPUSH, RPOP 을 적절하게 활용해서 작업 대기열을 구성할 수도 있습니다. 요청의 고유값을 식별하기 위해서는 Set 에 요청 ID 를 기록해두는 방식을 사용합니다.\r\n최근 트렌드는 가급적 작업 대기열 등은 Kafka,Kafka Streams 또는 RabbitMQ를 사용하는 추세입니다. 하지만 팀내 인력상황, 마감기한 및 여러가지 운영 요소로 인해 큰 비용이 필요하지 않을 경우 간단하게 레디스 기반으로 작업 대기열을 구성하는 경우도 많습니다.\r\n이 경우, Redis 서버가 다운될 경우 작업 대기열의 데이터들 모두 유실될 수 있다는 점에 착안해서 예외 처리등을 명확히 해둬야 합니다.\nString\r\n특정 값을 저장하는 용도로 사용합니다. 단순 문자열을 저장할 수도 있겠지만 구분자(DELIMITER)를 기반으로 여러가지 요청 식별자를 조합해서 어떤 요청이 있었는지를 기반으로 조회가 가능하도록 저장하는 경우도 많습니다.","string-자료구조#String 자료구조":"단순한 문자열 데이터 형식\r\n주요 연산으로는 set, get 이 있습니다.\r\nset, get 은 시간복잡도가 각각 O(1) 입니다.","eg-set#e.g. set":"set coupon:1 \"Apple 50% Discount Event\"\r\nOK","eg-get#e.g. get":"get coupon:1\r\n\"Apple 50% Discount Event\"\n이렇게 생성한 자료구조는 del 명령어로 삭제 가능합니다.","list-자료구조#List 자료구조":"리스트와 같은 선형자료 구조\r\nLPUSH 로 리스트의 제일 왼쪽(head)에 데이터를 추가할 수도 있고 RPUSH 로 리스트의 제일 오른쪽(tail)에 데이터를 추가할 수 있습니다.","lrange#LRANGE":"redis.io/commands - LRANGE\nLIST 내의 지정된 범위에 해당하는 요소들을 반환합니다.\n시간복잡도 O(S+N) 에 해당하는 연산입니다.\nS는 시작 Offset 의 Head/Tail 로부터의 거리 (distance)를 의미합니다.\nN은 지정된 Range 내에 속한 요소들의 개수를 의미합니다.\nLRANGE key start stop","lpush#LPUSH":"redis.io/commands - LPUSH\n리스트의 제일 왼쪽(head)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLPUSH key element [element ...]","rpush#RPUSH":"redis.io/commands - RPUSH\n리스트의 제일 오른쪽(tail)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nRPUSH key element [element ...]","lpop#LPOP":"redis.io/commands - LPOP\n리스트의 첫 번째 요소(Head)를 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nLPOP key [count]\n리스트의 첫 번째로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 제일 처음 요소로부터 3개의 요소를 POP 하게 됩니다.","rpop#RPOP":"redis.io/commands - RPOP\n리스트의 제일 마지막 요소(Tail)을 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nRPOP key [count]\n리스트의 마지막으로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 맨끝에서 3개의 요소를 POP 하게 됩니다.","llen#LLEN":"redis.io/commands - LLEN\n현재 리스트의 사이즈를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLLEN key","lpos#LPOS":"redis.io/commands - LPOS\n리스트 내에서 일치하는 요소를 찾는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다. 만약 MAXLEN 을 명시해서 호출하면 상수 시간 내에 수행됩니다.\nLPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]","set-자료구조#SET 자료구조":"어느 언어에서든 제공되는 Set 개념에 해당하는 자료구조입니다.","smembers#SMEMBERS":"redis.io/commands - SMEMBERS\nkey 에 해당하는 Set 에 저장된 모든 요소들을 반환합니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nSMEMBERS key","sadd#SADD":"redis.io/commands - SADD\nkey 에 해당하는 Set 에 요소를 추가합니다. 이때 요소 하나만 지정할 수도 있고 요소 여러개를 지정해서 여러개의 요소를 한번에 추가할 수 도 있습니다.\n요소 하나를 추가할 때는 시간복잡도 O(1) 에 해당하는 연산입니다. 만약 요소 K 개를 하나의 명령어로 추가할 경우에는 O(K) 의 시간복잡도를 가집니다.\nSADD key member [member ...]","sismember#SISMEMBER":"redis.io/commands - SISMEMBER\nkey 에 해당하는 Set 에 member 에 해당하는 요소가 존재하는지 검사합니다. 존재한다면 1을, 존재하지 않는다면 0 을 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSISMEMBER key member","scard#SCARD":"redis.io/commands - SCARD\nkey 에 해당하는 Set의 사이즈(Cardinality, 요소의 갯수)를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSCARD key","srem#SREM":"redis.io/commands - SREM\nkey 에 해당하는 Set 내에서 인자값으로 전달받은 member를 삭제하는 연산입니다. 지우고자 하는 요소가 여러개라면 지루려는 요소들을 모두 인자값으로 전달해주면 됩니다.\n지워야하는 요소수가 K개일 경우 시간복잡도 O(K) 가 소요되는 연산입니다.\nSREM key member [member ...]","sorted-set#Sorted Set":"스코어를 기반으로 순서를 지정해서 정렬된 상태로 저장하는 문자열 컬렉션입니다.\r\nSet 자료구조이므로 중복을 허용하지 않습니다.","zrange#ZRANGE":"redis.io/commands - ZRANGE\nkey 에 해당하는 SortedSet 에서 cli 에 명시한 Range 에 해당하는 요소들을 리턴하는 연산입니다.\nO(log(N)+M) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미하며, M 은 반환된 요소 수를 의미합니다.\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]\r\n[WITHSCORES]","zadd#ZADD":"redis.io/commands - ZADD\nkey 에 해당하는 SortedSet 에 score 와 함께 요소들을 저장합니다. score 를 기반으로 정렬되며, score가 같은 요소는 문자열 정렬을 통해 오름차순 정렬되어 저장됩니다.\nO(log(N)) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미합니다.\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member\r\n...]\ne.g. redis> ZADD myzset 1 \"one\"\ne.g. redis> ZADD myzset 2 \"two\" 3 \"three\"","zcard#ZCARD":"redis.io/commands - ZCARD\nkey 에 해당하는 SortedSet 의 사이즈(Cardinality, 요소의 개수)를 리턴합니다.\nO(1) 의 시간복잡도가 소요됩니다.\nZCARD key","zpopmin#ZPOPMIN":"redis.io/commands - ZPOPMIN\nkey 에 해당하는 SortedSet 에서 score 가 가장 낮은 순으로 요소들 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMIN key [count]","zpopmax#ZPOPMAX":"redis.io/commands - ZPOPMAX\nkey 에 해당하는 SortedSet 에서 score 가 가장 높은 요소들을 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMAX key [count]"}},"/spring-data-redis-reactive/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{"spring-data-redis-reactive#Spring Data Redis Reactive":""}},"/spring-data-r2dbc/mysql-features":{"title":"Mysql Features","data":{"mysql-특징#MySQL 특징":"자세한 내용은 docs-mysql-essential을 참고해주시기 바랍니다."}}}