{"/":{"title":"Introduction","data":{"":"Spring Data Reactive 문서보관소입니다.\n예제 Github Repository\nMongoDB : example-spring-data-mongo-reactive"}},"/spring-data-mongodb-reactive":{"title":"Spring Data Mongodb Reactive","data":{"spring-data-mongodb-reactive#Spring Data MongoDB Reactive":""}},"/spring-data-mongodb-reactive/document-bson-bson-codec":{"title":"Document Bson Bson Codec","data":{"document-bson-bson-codec#Document, BSON, BSON Codec":"","참고자료#참고자료":"mongodb.com/docs/manual/reference/bson-types/\nMongoDB Docs - BSON Types\nmongodb.github.io/mongo-java-driver\nCodecProvider\nQuick Start Pojo\norg.bson.Document","document#Document":"BSON 에서 제공하는 타입에는 Document 라는 타입이 있습니다. 아래와 같이 MongoCollection 에 query 를 통해 조회한 결과는 org.bson.Document 로 변환됩니다.\n이  org.bson.Document 타입은 bson library 에 속하는 타입입니다.\npackage org.bson;\r\n\r\n// ...\r\npublic class Document implements Map<String, Object>, Serializable, Bson {\r\n    private static final Codec<Document> DEFAULT_CODEC =\r\n            withUuidRepresentation(fromProviders(asList(new ValueCodecProvider(),\r\n                    new CollectionCodecProvider(), new IterableCodecProvider(),\r\n                    new BsonValueCodecProvider(), new DocumentCodecProvider(), new MapCodecProvider())), UuidRepresentation.STANDARD)\r\n                    .get(Document.class);\r\n    // ...\r\n    \r\n}","bson#BSON":"참고 : MongoDB Docs - BSON Types\n아래 내용은 MongoDB Docs - BSON Types 의 내용 중 Java 자료형과, Bson 라이브러리에 존재하는 타입들에 대해서만 정리한 내용입니다. (DBPointer, Undefined 등의 타입들은 제외했습니다.)\nBSON Type\tNumber\tJava Type\tDouble\t1\tDouble, Float\tString\t2\tCharacter, String, Enum\tObject\t3\t\tArray\t4\t\tBinary Data\t5\tBinary (bson 라이브러리 지원 타입), byte[]\tObjectId\t7\tObjectId (bson 라이브러리 지원 타입)\tBoolean\t8\tBoolean, AtomicBoolean\tDate\t9\tDate, Instant, LocalDate, LocalDateTime, LocalTime\tNull\t10\t\tRegular Expression\t11\tPattern\tJavaScript\t13\tCode (bson 라이브러리 지원 타입)\t32-bit integer\t16\tInteger, Byte, Short, AtomicInteger\tTimestamp\t17\t\t64-bit integer\t18\tLong, AtomicLong\tDecimal128\t19\tDecimal128 (bson 라이브러리 지원 타입), BigDecimal\tMin Key\t-1\tMinKey (bson 라이브러리 지원 타입)\tMax Key\t127\tMaxKey (bson 라이브러리 지원 타입)","bson-codec#BSON Codec":"예를 들면, MongoDB 로부터 Date 타입으로 전달되는 값을 LocalDate 또는 LocalDateTime 으로 변환해야 할 때가 있습니다. 또는 LocalDate, LocalDateTime 타입을 MongoDB driver 의 bson 라이브러리에서 지원하는 타입으로 변환해야 하는 경우가 있습니다.이런 경우에 보통 기본제공되는 Provider 를 확장(extends) 해서 CodecProvider, Codec 을 직접 정의해서 사용합니다. 이번 섹션에서는 mongodb driver 에서 제공하는 bson 라이브러리의 코덱에는 어떤 것들이 있는지 정리해봅니다.","mongoclientsettingsdefault_codec_registry#MongoClientSettings.DEFAULT_CODEC_REGISTRY":"MongoClientSettings 클래스 내에서는 기본적으로 많이 사용되는 Codec 들의 Registry 를 CodecRegistry 타입의 DEFAULT_CODEC_REGISTRY 라는 필드를 통해 제공합니다.Java 타입 관련 코덱 프로바이더들\nValueCodecProvider, IterableCodecProvider, MapCodecProvider, Jsr310CodecProvider, JsonObjectCodecProvider, JsonObjectCodecProvider, EnumCodecProvider, Jep395RecordCodecProvider, KotlinCodecProvider, CollectionCodecProvider\nBson 타입관련 코덱 프로바이더들\nDBRefCodecProvider,  DBObjectCodecProvider, DocumentCodecProvider, CollectionCodecProvider, GeoJsonCodecProvider, GridFSFileCodecProvider, BsonCodecProvider, ExpressionCodecProvider\n@Immutable\r\npublic final class MongoClientSettings {\r\n    private static final CodecRegistry DEFAULT_CODEC_REGISTRY =\r\n            fromProviders(asList(new ValueCodecProvider(),\r\n                    new BsonValueCodecProvider(),\r\n                    new DBRefCodecProvider(),\r\n                    new DBObjectCodecProvider(),\r\n                    new DocumentCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new CollectionCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new IterableCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new MapCodecProvider(new DocumentToDBRefTransformer()),\r\n                    new GeoJsonCodecProvider(),\r\n                    new GridFSFileCodecProvider(),\r\n                    new Jsr310CodecProvider(),\r\n                    new JsonObjectCodecProvider(),\r\n                    new BsonCodecProvider(),\r\n                    new EnumCodecProvider(),\r\n                    new ExpressionCodecProvider(),\r\n                    new Jep395RecordCodecProvider(),\r\n                    new KotlinCodecProvider()));\r\n    // ...\r\n}\n원래는 위의 코드에 List 내에 대입되는 Provider 객체들을 코드에서 선언한 순서대로 설명을 작성하려 했지만, Java 타입과 BSON 타입 설명이 섞이기 시작하면서 어지러워보여서 Java 타입 프로바이더와 BSON 타입 코덱 프로바이더를 따로 나눠서 정리합니다.","java-타입-코덱-프로바이더#Java 타입 코덱 프로바이더":"ValueCodecProvider (Java)\nJava 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Java 에서 제공하는 클래스\nencode : Java 에 존재하는 타입 → BSON 데이터\nIterableCodecProvider (Java)\nIterable 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → List\nencode : List → BSON 데이터\nMapCodecProvider (Java)\nMap 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Map\nencode : Map → BSON 데이터\nJsr310CodecProvider (Java)\nJava 의 Instant, LocalDate, LocalDateTime 등 Date, Time 등의 시간 관련 타입들을 encode/decode 하기 위한 Codec 객체에 대한 프로바이더 입니다.\ndecode : BSON 데이터 → LocalDate, LocalDateTime\nencode : LocalDate, LocalDateTime → BSON 데이터\nEnumCodecProvider (Java)\nEnum 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Enum\nencode : Enum → BSON 데이터\nJep395RecordCodecProvider : (Java)\nJava 의 Record 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Record\nencode : Record → BSON 데이터\nKotlinCodecProvider : (Java, Kotlin)\nKotlin 타입으로 encode/decode 를 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Kotlin\nencode : Kotlin → BSON 데이터\nCollectionCodecProvider\nJava 의 Collection 인터페이스 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\nCollectionCodecProvider 는 interface 이기에, Java 의 Collection 타입 중 Map, Iterable 에 해당하는 것이 없는 등의 경우에 Collection 구현체 → BSON, BSON → Collection 구현체로 변환하는 코드를 직접 작성해야 할 때 사용합니다.\ndecode : BSON 데이터 → Collection 타입 (BSON 라이브러리 내의 타입)\nencode : Collection 타입 (BSON 라이브러리 내의 타입) → BSON 데이터","bson-타입-코덱-프로바이더#BSON 타입 코덱 프로바이더":"주로 mongodb-driver 에서 구현해둔 프로바이더 들입니다. 드라이버 계층에서 mongodb 에서 가져온 bson 데이터를 BSON 라이브러리에서 지원하는 BSON 타입으로 변환하는데에 사용됩니다. 응용 계층 프로그래머가 직접 접근할 일은 드뭅니다.\nJsonObjectCodecProvider\nBSON 라이브러리 내의 JsonObject 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → JsonObject (BSON 라이브러리 내의 타입)\nencode : JsonObject (BSON 라이브러리 내의 타입) → BSON 데이터\nDBRefCodecProvider\nBSON 라이브러리 내의 DBRef 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → DBRef (BSON 라이브러리 내의 타입)\nencode : DBRef (BSON 라이브러리 내의 타입) → BSON 데이터\nDBObjectCodecProvider\nBSON 라이브러리 내의 DBObject 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → DBObject (BSON 라이브러리 내의 타입)\nencode : DBObject (BSON 라이브러리 내의 타입) → BSON 데이터\nDocumentCodecProvider\nBSON 라이브러리 내의 Document 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Document (BSON 라이브러리 내의 타입)\nencode : Document (BSON 라이브러리 내의 타입) → BSON 데이터\nGeoJsonCodecProvider\nBSON 라이브러리 내의 GeoJson 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → GeoJson (BSON 라이브러리 내의 타입)\nencode : GeoJson (BSON 라이브러리 내의 타입) → BSON 데이터\nGridFSFileCodecProvider\nBSON 라이브러리 내의 GridFSFile 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → GridFSFile (BSON 라이브러리 내의 타입)\nencode : GridFSFile (BSON 라이브러리 내의 타입) → BSON 데이터\nBsonCodecProvider\nBSON 라이브러리 내의 Bson 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Bson (BSON 라이브러리 내의 타입)\nencode : Bson (BSON 라이브러리 내의 타입) → BSON 데이터\nExpressionCodecProvider\nBSON 라이브러리 내의 Expression 타입으로 encode/decode 하기 위한 Codec 객체에 대한 프로바이더입니다.\ndecode : BSON 데이터 → Expression (BSON 라이브러리 내의 타입)\nencode : Expression (BSON 라이브러리 내의 타입) → BSON 데이터","예제---valuecodecprovider#예제 - ValueCodecProvider":"이번에 살펴볼 예제는 Mongodb Cloud 내의 helloworld.person 이라는 컬렉션을 획득하고, 도큐먼트를 조회해오는데, 이 도큐먼트의 BSON 데이터를 읽어들여서 Java 의 값으로 변환하는 예제입니다. 그리고 Subscribe 는 reactivestreams 의 Subscriber 를 이용해서 subscribe 하는 예제입니다.예제는 공식 도큐먼트의 Quick Start Pojo 문서를 참고해서 작성한 예제입니다.\n자세한 설명은 생략하도록 하겠습니다.","personjava#Person.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec.valueobject;\r\n\r\nimport java.math.BigDecimal;\r\nimport java.util.Objects;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\nimport org.bson.codecs.pojo.annotations.BsonId;\r\nimport org.bson.codecs.pojo.annotations.BsonProperty;\r\nimport org.bson.types.ObjectId;\r\n\r\n@Getter @Setter\r\npublic class Person {\r\n  @BsonId\r\n  @BsonProperty(value = \"_id\")\r\n  private ObjectId id;\r\n  @BsonProperty(value = \"name\")\r\n  private String name;\r\n  @BsonProperty(value = \"salary\")\r\n  private BigDecimal salary;\r\n\r\n  @Override\r\n  public int hashCode() {\r\n    return Objects.hash(id, name, salary);\r\n  }\r\n\r\n  @Override\r\n  public boolean equals(Object obj) {\r\n    if(this == obj) return true;\r\n    if(obj == null || getClass() != obj.getClass()) return false;\r\n    Person p = (Person) obj;\r\n    return Objects.equals(id, p.getId())\r\n        && Objects.equals(salary, p.getSalary())\r\n        && Objects.equals(name, p.getName());\r\n  }\r\n\r\n  @Override\r\n  public String toString() {\r\n    return \"Person{\" +\r\n        \"id=\" + id +\r\n        \", name='\" + name + '\\'' +\r\n        \", salary=\" + salary +\r\n        '}';\r\n  }\r\n}","customvaluecodecprovider#CustomValueCodecProvider":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec;\r\n\r\nimport java.lang.reflect.Type;\r\nimport java.math.BigDecimal;\r\nimport java.util.List;\r\nimport org.bson.BsonReader;\r\nimport org.bson.BsonWriter;\r\nimport org.bson.codecs.Codec;\r\nimport org.bson.codecs.DecoderContext;\r\nimport org.bson.codecs.EncoderContext;\r\nimport org.bson.codecs.ValueCodecProvider;\r\nimport org.bson.codecs.configuration.CodecRegistry;\r\n\r\npublic class CustomValueCodecProvider extends ValueCodecProvider {\r\n  @Override\r\n  public <T> Codec<T> get(Class<T> clazz, List<Type> typeArguments, CodecRegistry registry) {\r\n    if(clazz == BigDecimal.class){\r\n      return new Codec<T>(){\r\n        @Override\r\n        public void encode(BsonWriter bsonWriter, T value, EncoderContext encoderContext) {\r\n          bsonWriter.writeString(((BigDecimal) value).toString());\r\n        }\r\n\r\n        @Override\r\n        public Class<T> getEncoderClass() {\r\n          return (Class<T>) BigDecimal.class;\r\n        }\r\n\r\n        @Override\r\n        public T decode(BsonReader bsonReader, DecoderContext decoderContext) {\r\n          return (T) new BigDecimal(bsonReader.readString());\r\n        }\r\n      };\r\n    }\r\n    return null;\r\n  }\r\n}","codecexamplejava#CodecExample.java":"package io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec;\r\n\r\nimport com.mongodb.ConnectionString;\r\nimport com.mongodb.MongoClientSettings;\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport com.mongodb.reactivestreams.client.MongoCollection;\r\nimport com.mongodb.reactivestreams.client.MongoDatabase;\r\nimport io.chagchagchag.example_mongo.mongodb_reactive_example.examples.codec.valueobject.Person;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.bson.codecs.configuration.CodecRegistries;\r\nimport org.bson.codecs.configuration.CodecRegistry;\r\nimport org.bson.codecs.pojo.PojoCodecProvider;\r\nimport org.reactivestreams.Subscriber;\r\nimport org.reactivestreams.Subscription;\r\n\r\n@Slf4j\r\npublic class CodecExample {\r\n  public static void main(String[] args) {\r\n    CodecRegistry codecRegistry = CodecRegistries.fromRegistries(\r\n        MongoClientSettings.getDefaultCodecRegistry(),\r\n        CodecRegistries.fromProviders(new CustomValueCodecProvider()),\r\n        CodecRegistries.fromProviders(PojoCodecProvider.builder().automatic(true).build())\r\n    );\r\n\r\n    var connectionString = new ConnectionString(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoClient mongoClient = MongoClients.create(\r\n        MongoClientSettings.builder()\r\n            .codecRegistry(codecRegistry)\r\n            .applyConnectionString(connectionString)\r\n            .build()\r\n    );\r\n\r\n    // Mongodb 데이터베이스 접속, 컬렉션 조회\r\n    MongoDatabase database = mongoClient.getDatabase(\"helloworld\");\r\n    MongoCollection<Person> collection = database.getCollection(\"person\", Person.class);\r\n\r\n    // 도큐먼트 조회\r\n    collection.find().first()\r\n            .subscribe(newSubscriber(1));\r\n  }\r\n\r\n  public static Subscriber<Person> newSubscriber(int requestSize){\r\n    return new Subscriber<Person>() {\r\n      @Override\r\n      public void onSubscribe(Subscription subscription) {\r\n        subscription.request(requestSize);\r\n      }\r\n\r\n      @Override\r\n      public void onNext(Person item) {\r\n        log.info(\"item _id = \" + item.getId());\r\n        log.info(\"item name = \" + item.getName());\r\n        log.info(\"item salary = \" + item.getSalary());\r\n      }\r\n\r\n      @Override\r\n      public void onError(Throwable throwable) {\r\n        throwable.printStackTrace();\r\n      }\r\n\r\n      @Override\r\n      public void onComplete() {\r\n        System.out.println(\"complete\");\r\n      }\r\n    };\r\n  }\r\n}","출력결과#출력결과":"// ... \r\n\r\n13:37:13.545 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item _id = 6606279491b652a088e56be5\r\n13:37:13.546 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item name = 홍길동\r\n13:37:13.546 [async-channel-group-0-handler-executor] INFO io...examples.codec.CodecExample -- item salary = 10000000000\r\ncomplete\r\n\r\n// ..."}},"/spring-data-mongodb-reactive/mongodb-features":{"title":"Mongodb Features","data":{"mongodb-features#MongoDB Features":"","mongo-db#Mongo DB":"MongoDB 는 오픈소스 NoSQL 데이터베이스입니다. 2007 년 10gen 이라는 회사에서 Paas 로 MongoDB 개발을 시작했고, 2009 년에 오픈소스 모델로 전환해서 사용지원, 기타 서비스를 제공하는 방식을 따르게 되었습니다. 2013년에는 10gen 이라는 회사 명이 MongoDB Inc. 로 변경되었으며 현재 전 세계에서 대중적으로 알려진 NoSQL 데이터베이스가 되었습니다.스키마가 정의되어 있지 않아도 데이터 저장을 유연하게 할 수 있습니다. 또한 다양한 종류의 index를 지원하고, 4.0 부터 multi docoument transaction 을 지원하기에 트랜잭션의 ACID 가 보장됩니다.몽고DB를 운영할 때 레플리카셋과 샤드 클러스터를 적용하면 데이터를 여러 노드에 분산해서 저장하고 처리하는 것이 가능해지며, 장애에 내성이 강한 데이터베이스로 전환이 가능합니다.","mongodb-bson#MongoDB BSON":"Binary 형식의 JSON 데이터를 BSON 이라고 부릅니다. MongoDB는 데이터를 BSON 형식으로 저장합니다.BSON 은 JSON 보다 인코딩/디코딩이 빠르고, 다양한 데이터 타입들이 BSON 에 지원됩니다.\ndocument id : ObjectId\n바이너리 데이터 : BinData\n날짜 : Date, ISODate\n정규표현식\nBSON 타입에 대한 자세한 내용은 아래의 링크들에서 자세히 확인 가능합니다.bsonspec.org\nbsonspec.org\nbsonspec.org/implementation.html\nMongodb.com\nWhat is BSON?\nHow is BSON different from JSON?\nAdvantages of BSON\nHow to convert JSON to BSON\nImport and export BSON documents\nBSON Document Example","mongodb-bson-인코딩#MongoDB BSON 인코딩":"BSON 은 필드의 순서에 따라서 인코딩이 달라지며, 첫줄은 document 의 크기를 의미합니다.\nbson converter 는 https://onlinejsontools.com/convert-json-to-bson 을 사용했습니다.","mongodb-document-collection-database#MongoDB Document, Collection, Database":"TODO : 그림 추가","mongodb-트랜잭션#MongoDB 트랜잭션":"4.0 버전 이후부터는 multi-document 트랜잭션 ACID 를 지원하기 시작했습니다.레플리카셋과 샤드클러스터가 적용된 MongoDB 환경에서 트랜잭션 사용 시 쿼리가 브로드캐스트 되는데, 이 경우 성능에 일정 부분은 영향을 줄 수 있다는 점을 감안해야 합니다.RDBMS 에서도 트랜잭션 자체가 길면 데이터 처리의 지연이 발생하며, 이런 부분에 대해서 트랜잭션을 짧게 구성하는 등의 처리를 하기에 트랜잭션에 대해서는 RDBMS, MongoDB 모두 트레이드 오프가 있다는 점을 감안할 수 있을 듯 합니다."}},"/spring-data-mongodb-reactive/entity":{"title":"Entity","data":{"entity#Entity":"MongoDB 내의 컬렉션 내에 존재하는 하나의 Document 에 해당하는 객체를 표현하는 클래스를 Entity 라고 부르며, @Document 애노테이션을 통해 Entity 를 식별합니다. spring data mongodb reactive 에서는 Document 를 Entity 단위로 식별하기 위해서 필요한 데이터베이스관련 세팅들에 대한 metadata 들을 @Id, @Field 등과 같은 애노테이션으로 제공해주고 있습니다.","document#@Document":"클래스 레벨의 애노테이션입니다.Entity 로 식별할 데이터의 단위를 표현한 클래스를  @Document 애노테이션을 붙여서 적용합니다.collection 명을 별도로 지정 가능합니다.","id#@Id":"필드 레벨의 애노테이션입니다._id 필드에 대해 적용하는 애노테이션입니다.Mongodb 의 모든 도큐먼트는 _id 필드가 필요합니다.MappingMongoConverter 는 아래의 방식을 통해 _id 를 식별해서 매핑하거나 자동으로 추가합니다.\n@Id 가 붙어있는 필드가 있을 경우 _id 필드를 매핑\n필드 명이 id 이고 @Field 를 통해서 별도의 이름이 부여되지 않은 경우 이 필드를 _id 필드로 매핑합니다.\nid 필드가 제공되지 않는 경우에는 자동으로 _id 필드가 추가됩니다.","dbref#@DBRef":"필드 레벨의 애노테이션입니다.MongoDB 의 DBRef 형태로 저장해야 하는 필드에 사용하는 애노테이션 입니다.","indexed#@Indexed":"필드 레벨의 애노테이션입니다.이 애노테이션이 표시된 필드에 대해서 인덱스를 생성합니다. 기본적으로는 자동 생성이 비활성화이며, 별도의 설정이 필요합니다.","compoundindex#@CompoundIndex":"클래스 레벨의 애노테이션입니다.여러 필드로 구성된 복합 인덱스를 적용하고자 할 때 사용하는 애노테이션입니다.","textindexed#@TextIndexed":"필드 레벨의 애노테이션입니다.필드에 text index 를 적용합니다.","hashindexed#@HashIndexed":"필드 레벨의 애노테이션입니다.필드에 hash index 를 적용합니다.","persistenceconstructor#@PersistenceConstructor":"생성자에 명시하는 애노테이션입니다.Spring Data Object Mapping 문서에서 자세하게 객체 생성규칙, 필드 주입 원칙 등에 대해 정리합니다.\nTODO : 링크 추가 필요","field#@Field":"필드 레벨의 애노테이션입니다.Entity 로 인식할 클래스 내의 필드에 대해 적용합니다. @Field 가 붙은 필드는 convention 기반이 아닌 Field 에 명시한 name 을 적용해서 인식합니다.","transient#@Transient":"필드 레벨의 애노테이션입니다.Entity 로 인식할 클래스 내의 필드 중 Document 매핑에서 제외할 필드에 대해 @Transient 애노테이션을 적용합니다.","version#@Version":"필드 레벨의 애노테이션입니다.낙관적 락(Optimistic Lock) 을 적용하고자 할 때 사용하는 애노테이션입니다. Entity 가 Update 될 때마다 자동으로 Update 됩니다."}},"/spring-data-mongodb-reactive/reactive-mongo-operation":{"title":"Reactive Mongo Operation","data":{"reactivemongooperation#ReactiveMongoOperation":""}},"/spring-data-mongodb-reactive/mongodb-reactive-streams-driver":{"title":"Mongodb Reactive Streams Driver","data":{"mongodb-reactive-streams-driver#MongoDB Reactive Streams Driver":"","참고자료#참고자료":"Github | mongo-java-driver-reactivestreams\nMongoDB Reactive Streams Java Driver\nMongoDB Reactive Streams Documentation\nmongodb.com/docs/drivers/reactive-streams\nReference Documentation\nSource Code\nAPI Documentation\nTutorials\nmongodb.github.io/mongo-java-driver\n공식 도큐먼테이션 페이지이며, 버전명을 클릭해서 넘어가는 문서 페이지에서 Reactive Streams Driver 에 대한 설명을 모두 다루고 있습니다.\nMongoDB Reactive Streams Driver Documentation\nMongoDB Reactive Streams Driver Quick Start","mongodb-driver#MongoDB Driver":"Java 언어를 사용할 때 지원되는 MongoDB Driver 는 아래와 같이 두 종류가 있습니다.\n참고 : MongoDB Java Drivers\nJava Driver : Synchronous 하게 동작하는 Mongo Driver\nReactive Streams Driver : 비동기 스트림 프로세싱을 지원하는 Reactive Streams API 기반의 Driver","java-driver-synchronous-driver#Java Driver (Synchronous Driver)":"결과값을 확인해야 다음 연산이 이뤄지는 Synchronous API 이며, Blocking 기반의 IO 연산방식의 Driver 입니다. 클라이언트측에서 요청을 했을 때 결과값을 받기 전 까지는 Blocking 이 발생합니다.","reactive-streams-driver#Reactive Streams Driver":"Reactive Streams Driver 는 논블로킹 방식의 비동기 연산으로 동작합니다. Spring Reactive Stack 내에서 사용되며, 높은 성능, 안정성을 제공합니다.","spring-data-mongodb-와-reactive-streams-driver#Spring Data MongoDB 와 Reactive Streams Driver":"Spring Data MongoDB Reactive 라이브러리에는 아래와 같은 Database 접근 요소들이 있습니다.\nReactiveMongoRepository\nReactiveMongoTemplate\nReactiveMongoDatabaseFactory\n위와 같은 Spring Data MongoDB Reactive 라이브러리들은 아래의 Driver 기반의 코드들을 한단계 감싸서 고수준으로 제공하고 있습니다. 아주 드물게 복잡한 쿼리나 이런 것들을 작성해야 할 경우 아래와 같은 MongoClient, MongoDatabase, MongoCollection 기반으로 작성하기도 합니다.\nMongoCollection\nMongoDatabase\nMongoClient","reactive-streams-driver-1#Reactive Streams Driver":"Spring Data MongoDB Reactive 는 Reactive Streams Driver 의 API 를 감싸고 있는 고수준 API 입니다.Spring Data MongoDB Reactive 에서 Reactive Streams MongoDB Driver 를 이용해서 대표적으로 3 계층으로 나눠서 상호작용을 합니다.MongoClient\nMongoDB 클러스터를 가리키는 객체이며, 커넥션 객체들을 생성하거나 바인딩하고 있는 역할을 합니다.\n흔히 이야기하는 접속객체 같은 역할과 MongoDatabse Factory 역할을 합니다.\nMongoDatabase\nMongoDB 의 Database 를 가리키는 역할을 합니다.\ncodec, write concern, read preference 등과 같은 정보들을 바인딩하고 있습니다.\nMongoClient 객체를 통해서 MongoDatabase 객체를 얻어올 수 있습니다.\nMongoCollection\nMongoDB 의 collection 을 얻어오고 바인딩하고 있는 객체입니다.\nMongoDatabase 객체를 통해서 MongoCollection 객체를 얻어올 수 있습니다.\n마지막으로 위의 그림에는 없는 MongoClients 라는 클래스가 하나 더 있습니다.MongoClients 클래스는 MongoClient 라는 Mongodb 접속을 위한 MongoClient 객체를 만드는 MongoClient Factory 역할을 하는 클래스입니다. 그리고 이렇게 MongoClients 클래스를 통해 생성된 MongoClient 객체는 Connection 에 대한 정보들을 담고 있습니다.","eg-connection-생성#e.g. Connection 생성":"참고자료 : MongoDB Reactive Streams Driver Quick Start\n먼저 단순한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport com.mongodb.reactivestreams.client.MongoCollection;\r\nimport com.mongodb.reactivestreams.client.MongoDatabase;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.bson.Document;\r\n\r\n@Slf4j\r\npublic class MongoClientExample {\r\n  public static void main(String[] args) {\r\n    MongoClient mongoClient = MongoClients.create(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoDatabase helloworld = mongoClient.getDatabase(\"helloworld\");\r\n    log.info(\"database == {} \", helloworld.getName());\r\n    MongoCollection<Document> book = helloworld.getCollection(\"book\");\r\n    log.info(\"collection = {} \", book.getNamespace().getCollectionName());\r\n\r\n    log.info(\"Bye Bye. Close ~!!!\");\r\n    mongoClient.close();\r\n  }\r\n}\n위에서 설명했던 MongoClients 클래스를 통해 MongoClient 객체를 생성합니다. 그리고 얻어낸 mongoClient 객체로 database 명을 얻어오고, collection 을 얻어와서 컬렉션 명을 출력하고 있습니다. 접속 주소에는 컬렉션 명과, 데이터베이스 명을 지정하지 않았는데도 잘 읽어오는 것을 보면, MongoClient 는 내부적으로 접속을 위한 통신작업을 한다는 것을 알 수 있습니다.\n출력\n// ...\r\n\r\n19:28:56.824 [main] INFO io...MongoClientExample -- database == helloworld \r\n19:28:56.828 [main] INFO io...MongoClientExample -- collection = book \r\n19:28:56.828 [main] INFO io...MongoClientExample -- Bye Bye. Close ~!!!\n이번에는 조금 복잡한 버전의 예제입니다.\npackage io.chagchagchag.example_mongo.mongodb_reactive_example.examples;\r\n\r\nimport com.mongodb.ConnectionString;\r\nimport com.mongodb.MongoClientSettings;\r\nimport com.mongodb.reactivestreams.client.MongoClient;\r\nimport com.mongodb.reactivestreams.client.MongoClients;\r\nimport lombok.extern.slf4j.Slf4j;\r\n\r\n@Slf4j\r\npublic class MongoClientExample2 {\r\n  public static void main(String[] args) {\r\n    var connection = new ConnectionString(\r\n        \"mongodb+srv://[계정명]:[비밀번호]@[Mongo Cloud 접속 주소]/\"\r\n    );\r\n\r\n    MongoClientSettings mongoClientSettings = MongoClientSettings.builder()\r\n        .applyConnectionString(connection)\r\n        .build();\r\n\r\n    try(MongoClient mongoClient = MongoClients.create(mongoClientSettings)){\r\n      var database = mongoClient.getDatabase(\"helloworld\");\r\n      log.info(\"database : {}\", database.getName());\r\n\r\n      var collection = database.getCollection(\"book\");\r\n      log.info(\"collection : {}\", collection.getNamespace().getCollectionName());\r\n\r\n      log.info(\"Finish. Bye Bye~!!\");\r\n    }\r\n\r\n  }\r\n}\n내용은 위의 예제와 비슷하므로 설명은 생략하도록 하겠습니다.출력\n// ...\r\n\r\n19:36:06.295 [main] INFO io...MongoClientExample2 -- database : helloworld\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- collection : book\r\n19:36:06.301 [main] INFO io...MongoClientExample2 -- Finish. Bye Bye~!!"}},"/spring-data-mongodb-reactive/reactive-mongo-template":{"title":"Reactive Mongo Template","data":{"reactivemongotemplate#ReactiveMongoTemplate":"","reactivemongotemplate-1#ReactiveMongoTemplate":"","mongoconverter#MongoConverter":""}},"/spring-data-mongodb-reactive/reactive-mongo-repository":{"title":"Reactive Mongo Repository","data":{"reactivemongorepository#ReactiveMongoRepository":""}},"/spring-data-mongodb-reactive/mongodb-tools":{"title":"Mongodb Tools","data":{"mongodb-접근-도구들#MongoDB 접근 도구들":"","mongodb-클라우드-인스턴스#MongoDB 클라우드 인스턴스":"문서 작성을 위한 용도로 사용하는 MongoDB는 Atlas MongoDB 를 사용했습니다. 개발PC가 점점 노후화 되어서 팬 소음도 너무 크고 가끔은 컴퓨터가 터질것 같아 선택하게 되었습니다. 데이터베이스 등급은 무료 인스턴스를 선택했습니다.","mongodb-docker#MongoDB docker":"로컬에서만 실행하시거나, testcontainers 를 사용중이시라면, docker-compose 파일을 만들어두고 이것을 읽어들이는게 제일 편하고 빠릅니다. 이런 이유로 이번 문서에서는 docker-compose 파일도 추가해둡니다.","single-broker#single broker":"브로커 1기만 갖춰진 docker-compose 파일입니다.\nversion: '3.8'\r\nservices:\r\n  mongo:\r\n    image: mongo:6.0.5\r\n    ports:\r\n      - 27017:27017\r\n    environment:\r\n      MONGO_INITDB_DATABASE: foobar\r\n      MONGO_INITDB_ROOT_USERNAME: root\r\n      MONGO_INITDB_ROOT_PASSWORD: 1111","multi-broker#multi broker":"TODO : 추가예정입니다. 현재 개발 PC가 도커 구동시마다 팬 소음이 너무 커져서 문서작업을 되도록 뒤로 미루고 있습니다.","mongodb-compass#MongoDB compass":"Mongodb Compass\nwindows :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-win32-x64.msi\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/\nmacos :\nhttps://downloads.mongodb.com/compass/mongodb-compass-1.42.3-darwin-arm64.dmg\n접속 URL : mongodb+srv://유저명:<password>@[서버주소]/","mongodb-data-explorer#MongoDB Data Explorer":"설치한 Atlas 인스턴스는 Compass 로도 접속할 수 있겠지만, 브라우저에서 사용가능한 Mongodb Data Explorer 로도 접속가능합니다.\nhttps://cloud.mongodb.com","mongoose#mongoose":"몽구스를 이용한 스키마 모델링 방법도 있습니다.설치\nyarn add mongooose\nTODO : Mongoose 사용법에 대해서는 시간이 되는대로 정리하겠습니다.","mongodb-shell#MongoDB Shell":"","설치--환경변수-등록#설치 & 환경변수 등록":"windows\nhttps://downloads.mongodb.com/compass/mongosh-2.0.0-x64.msi 다운로드 & 설치\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nmacos\nbrew isntall mongosh\nmongosh \"mongodb+srv://[접속주소]\" --apiVersion 1 --username [유저명]\nbrew install 이 아닌 Manually Install 을 원하신다면 Install Mongosh → Procedure → macOS 를 선택해주세요. 그리고 사용가능한 바이너리를 확인하시려면  Install from .zip File. 을 확인해주세요.\nMS윈도우즈 사용자의 경우 다운로드 받은 mongosh 파일을 Path 에 추가시킨 후 터미널에서 접근 가능합니다. MacOS 사용자의 경우에도 brew 로 설치하기보다는 별도로 다운로드 받은 디렉터리를 추가하고 싶다면 별도로 바이너리를 다운받으신후 Path 에 추가해주시면 됩니다.제 경우에는 MacOS 를 사용할 때에는 ~/username/workspace/bin 같은 디렉터리에 바이너리를 모아두었었는데, Manually Install 방식이 친절하게 제공되면 Manually Install 로 설치 후에 필요 없어지면 바이너리와 이와 관련된 디렉터리를 지워버리는 방식으로 개발 PC를 관리해왔는데, 가능한 경우에 한해서 이 방식으로 설치를 했었습니다. 가끔은 불편하더라도 나중에 관리가 깔끔하게 되려면 오히려 이런 방식이 더 편할 것 같기도 합니다.","database-선택-접근#Database 선택, 접근":"### 데이터베이스 선택\r\nuse [데이터베이스명]\r\n\r\n### 현재 사용중인 데이터베이스 확인\r\ndb\r\n\r\n### 서버 내의 데이터베이스 리스트\r\n### 최소 한개의 Document 를 가진 DB만 출력됩니다.\r\nshow dbs\r\n\r\n### 컬렉션에 Document insert\r\ndb.[컬렉션명].insertOne({k:v, ...})\r\n\r\n### db 내에 도큐먼트 조회\r\ndb.[데이터베이스명].find()\r\n\r\n### 데이터베이스 drop\r\n### 현재 선택한 데이터베이스를 drop\r\ndb.dropDatabase()","collection#Collection":"Collection 에 대한 자세한 옵션들(clusteredIndex, timeseries 옵션 등등)에 대한 설명은 MongoDB Manual/db.createCollection() 을 참고해주시기 바랍니다.\n## Collection 생성\r\ndb.createCollection(컬렉션 명)\r\n\r\n## 생성된 컬렉션 들 조회\r\nshow collections\r\n\r\n## 컬렉션 내의 모든 document 리스트들 조회\r\ndb.book.find()\r\n\r\n## 컬렉션 DROP\r\ndb.book.drop()","eof#EOF":"이번 문서에서는 접근환경에 대해서만 간단하게 정리했습니다. 추후에 시간이 된다면, MongoDB에서 지원하는 조회쿼리, aggregation 쿼리나, Date 형식의 데이터들, 인덱싱 개념들 등을 정리해두도록 하겠습니다."}},"/spring-data-r2dbc":{"title":"Spring Data R2DBC","data":{}},"/spring-data-mongodb-reactive/query-methods":{"title":"Query Methods","data":{"query-메서드들#Query 메서드들":""}},"/spring-data-mongodb-reactive/mongo-collection-functions":{"title":"Mongo Collection Functions","data":{"mongocollection-의-다양한-연산들#MongoCollection 의 다양한 연산들":"","참고자료#참고자료":"mongodb.github.io/mongo-java-driver\ndirver core : Aggregates, Filters 등 다양한 집계 연산을 위한 core 라이브러리 및 여러가지 codec, geojson 등이 포함된 라이브러리입니다.\nAggregates, Filters 등과 같은 필터나 Aggregate 를 Bson 으로 생성하는 헬퍼 팩토리 메서드 들은 주로 com.mongodb.client.model 에 위치해있습니다.\nJava Reactive Streams Driver","요약#요약":"기본 연산\ncountDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\natomic 연산\nfindOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)\nindex 연산\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","기본-연산#기본 연산":"countDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nfind(ClientSession clientSession, Bson filter)\naggregate(List<? extends Bson> pipeline)\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)","countdocuments-#countDocuments (...)":"참고\nMongoCollection.java\ncountDocuments(ClientSession clientSession, Bson filter, CountOptions options)\nCollection 메타 데이터를 이용해서 컬렉션 내의 Document 의 갯수를 반환합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Counts the number of documents in the collection according to the given options.\r\n     * ...\r\n     */\r\n    Publisher<Long> countDocuments(ClientSession clientSession, Bson filter, CountOptions options);\r\n}\nClientSession : ClientSession 을 통해서 multi document transaction 을 지원합니다.\nBson filter : Bson 구현채를 이용해서 filter 연산이 가능합니다.\nCountOptions options : hint, limit, skip, maxTime, collation 등과 같은 정보를 Option 으로 넘기는 것이 가능합니다.","find-#find (...)":"참고\nMongoCollection.java\nFilters\nfind(ClientSession clientSession, Bson filter)\n컬렉션 내에서 filter 에 해당되는 모든 도큐먼트들을 불러옵니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Finds all documents in the collection.\r\n     * ...\r\n     */\r\n    FindPublisher<TDocument> find();\r\n}\nFilters 에서 제공하는 정적 팩토리 메서드 들 에는 eq, ne, gt, gte, lt, lte, in, nin, and, or, not, nor, exists, type, mod, regex, text 등과 같은 연산자를 지원하는 메서드 들이 있는데 모두 Bson 객체를 Filter 에 맞는 형식으로 객체를 생성하는 메서드 들입니다.\n자세한 내용은 IDE 에서 Filters 클래스를 찾아보거나 Filters 를 참고해주세요.","aggregate-#aggregate (...)":"참고\nMongoCollection.java\naggregate(List<? extends Bson> pipeline)\nAggregates\npipline 에 해당하는 Bson 식들에 대해 필터링, 집계, 그루핑 등과 같은 aggregation  을 수행합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Aggregates documents according to the specified aggregation pipeline.\r\n     * ...\r\n     */\r\n    AggregatePublisher<TDocument> aggregate(List<? extends Bson> pipeline);\r\n}\nAggregates 클래스에서는 aggregation 표현식을 Bson 객체로 생성해내는 다양한 종류의 정적 팩토리 메서드들이  헬퍼 메서드로 존재합니다.지원되는 메서드 들은 굉장히 다양하며 그 중 대표적으로 잘 알려진 메서드 들은 아래와 같습니다.\naddFields, set, bucket, bucketAuto\nsort, sortByCount\ncount\nmatch, project\nskip, limit, lookup\nfacet, graphLookup, group, unionWith, unwind, out, merge, replaceRoot, replaceWith, sample","watch-#watch (...)":"참고\nMongoCollection.java\nwatch(ClientSession clientSession, List<? extends Bson> pipeline)\nChangeStreamPublisher\n컬렉션에 대한 변경사항 발생시 변경사항에 대한 Stream (Change Stream) 을 만들어냅니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Creates a change stream for this collection.\r\n     * ...\r\n     */\r\n    ChangeStreamPublisher<Document> watch(ClientSession clientSession, List<? extends Bson> pipeline);\r\n}\nChangeStreamPublisher 타입을 반환합니다. 이렇게 만들어진 ChangeStream 은 subscribe 시에 onNext 이벤트를 통해 읽어들여집니다.","bulkwrite-#bulkWrite (...)":"참고\nMongoCollection.java\nbulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests, BulkWriteOptions options)\nBulkWriteOptions\nWriteModel\ninsert, updates, replaces, delete 연산을 한번에 모아서 bulk 연산을 수행합니다.\npackage com.mongodb.client;\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Executes a mix of inserts, updates, replaces, and deletes.\r\n     * ...\r\n     */\r\n    Publisher<BulkWriteResult> bulkWrite(ClientSession clientSession, List<? extends WriteModel<? extends TDocument>> requests,\r\n                              BulkWriteOptions options);\r\n}\n입력인자를 보면 WriteModel 이 보입니다. 이 WriteModel 은 interface 이며 구체타입 들은 아래와 같습니다.\nDeleteManyModel : 조건을 만족하는 모든 Document 를 찾아서 모두 삭제할 수 있도록 표현된 Model 객체입니다.\nDeleteOneModel : 조건을 만족하는 하나의 Document 를 찾아서 삭제할 수 있도록 표현된 Model 객체입니다.\nInsertOneModel : 하나의 Document 를 Inert 할 수 있도록 표현된 Model 객체입니다.\nReplaceOneModel : 조건을 만족하는 하나의 Document 를 찾아서 Replace 할 수 있도록 표현된 Model 객체입니다.\nUpdateManyModel : 조건을 만족하는 2개 이상의 Document 를 찾아서 수정할 수 있도록 표현된 Model 객체입니다.\nUpdateOneModel : 조건을 만족하는 하나의 Document 를 찾아서 수정할 수 있도록 표현된 Model 객체입니다.","insertone-#insertOne (...)":"참고\nMongoCollection.java\ninsertOne(ClientSession clientSession, TDocument document, InsertOneOptions options)\nInsertOneOptions, InsertOneOptions.java\n하나의 document 를 insert 할 수 있도록 MongoCollection 클래스에서 지원되는 메서드입니다.만약 id 와 같은 식별자가 누락되어 있다면, mongodb-java-driver 가 자동으로 생성합니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Inserts the provided document. If the document is missing an identifier, the driver should generate one.\r\n     * ...\r\n     */\r\n    Publisher<InsertOneResult> insertOne(ClientSession clientSession, TDocument document, InsertOneOptions options);\r\n}\nInsertOneOptions 가 보입니다. InsertOneOptions 는 validation 을 우회할 지 결정하는 필드를가지고 있습니다.\npackage com.mongodb.client.model;\r\n/**\r\n * The options to apply to an operation that inserts a single document into a collection.\r\n */\r\npublic final class InsertOneOptions {\r\n    private Boolean bypassDocumentValidation;\r\n    private BsonValue comment;\r\n    // ... \r\n}","insertmany-#insertMany (...)":"참고\nMongoCollection.java\ninsertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options)\nInsertManyOptions, InsertManyOptions.java\n여러개의 Document 를 insert 할 수 있도록 제공되는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Inserts one or more documents.  A call to this method is equivalent to a call to the {@code bulkWrite} method\r\n     * ...\r\n     */\r\n    Publisher<InsertManyResult> insertMany(ClientSession clientSession, List<? extends TDocument> documents, InsertManyOptions options);\r\n}\nInsertManyOptions 가 보입니다. InsertManyOptions 는 validation 을 우회할 지, insert 순서를 보장할지를 결정하는 필드들을 가지고 있습니다.\npackage com.mongodb.client.model;\r\n/**\r\n * The options to apply to an operation that inserts multiple documents into a collection.\r\n */\r\npublic final class InsertManyOptions {\r\n    private boolean ordered = true;\r\n    private Boolean bypassDocumentValidation;\r\n    private BsonValue comment;\r\n    // ...\r\n}","updateone-#updateOne (...)":"참고\nMongoCollection.java\nupdateOne(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nUpdateOptions, UpdateOptions.java\nfilter 를 통해 찾아지는 도큐먼트 1개를 update 하는 연산이며, UpdateOptions 를 통해서 upsert, hint, collation, variables 를 명시할 수 있습니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Update a single document in the collection according to the specified arguments.\r\n     * ...\r\n     */\r\n    Publisher<UpdateResult> updateOne(Bson filter, List<? extends Bson> update, UpdateOptions updateOptions);\r\n}\nUpdateOptions 가 보입니다. UpdateOptions 에는 아래와 같이 upsert, hint, collation, variables 등을 지정할 수 있는 필드들이 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply when updating documents.\r\n */\r\npublic class UpdateOptions {\r\n    private boolean upsert;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","updatemany-#updateMany (...)":"참고\nMongoCollection.java\nupdateMany(ClientSession clientSession, Bson filter, List<? extends Bson> update, UpdateOptions options)\nfilter 를 통해 찾아지는 1개 또는 두개 이상의 모든 도큐먼트들을 update 하는 연산이며, UpdateOptions 를 통해서 upsert, hint, collation, variables 를 명시할 수 있습니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Update all documents in the collection according to the specified arguments.\r\n     * ...\r\n     */\r\n    Publisher<UpdateResult> updateMany(ClientSession clientSession, Bson filter, Bson update, UpdateOptions updateOptions);\r\n}\nUpdateOptions 가 보입니다. UpdateOptions 에는 아래와 같이 upsert, hint, collation, variables 등을 지정할 수 있는 필드들이 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply when updating documents.\r\n */\r\npublic class UpdateOptions {\r\n    private boolean upsert;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","atomic-연산#atomic 연산":"findOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)","findoneanddelete-#findOneAndDelete (...)":"참고\nMongoCollection.java\nfindOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options)\n원자적으로 도큐먼트 하나를 찾아낸 후 삭제하는 것을 보장하는 연산입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and remove it.\r\n     * ...\r\n     */\r\n    Publisher<TDocument> findOneAndDelete(ClientSession clientSession, Bson filter, FindOneAndDeleteOptions options);\r\n}\nFindOneAndDeleteOptions.java 의 내용은 아래와 같습니다.sort 옵션, collation 옵션, hint 옵션, comment 옵션을 따로 지정할 수 있습니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and deletes it.\r\n */\r\npublic class FindOneAndDeleteOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private long maxTimeMS;\r\n    private Collation collation;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    \r\n    // ...\r\n}","findoneandreplace-#findOneAndReplace (...)":"참고\nMongoCollection.java\nfindOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options)\nfilter 에 해당하는 하나의 도큐먼트를 찾아서 원자적으로 Replace 하는 것이 보장되는 함수입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and replace it.\r\n     * ...\r\n     */\r\n    @Nullable\r\n    Publisher<TDocument> findOneAndReplace(ClientSession clientSession, Bson filter, TDocument replacement, FindOneAndReplaceOptions options);\r\n}\nFindOneAndReplaceOptions 의 코드는 아래와 같습니다. hint, sort, upsert 여부, validation 을 건너뛸지에 대한 여부인 bypassDocumentValidation, collation, hint 를 지정할 수 있음을 확인 가능합니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and replaces it.\r\n */\r\npublic class FindOneAndReplaceOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private boolean upsert;\r\n    private ReturnDocument returnDocument = ReturnDocument.BEFORE;\r\n    private long maxTimeMS;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","findoneandupdate#findOneAndUpdate(...)":"참고\nMongoCollection.java\nfindOneAndUpdate(ClientSession clientSession, Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options)\nfilter 에 해당하는 하나의 도큐먼트를 찾아서 원자적으로 Update 하는 것이 보장되는 함수입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Atomically find a document and update it.\r\n     * ...\r\n     */\r\n    @Nullable\r\n    Publisher<TDocument> findOneAndUpdate(Bson filter, List<? extends Bson> update, FindOneAndUpdateOptions options);\r\n}\nFindOneAndUpdateOptions.java 의 코드는 아래와 같습니다. upsert 여부, sort 를 어떻게할지, validation 을 skip 할지에 대한 옵션인 bypassDocumentValidation, collation, hint 를 옵션으로 설정할 수 있음을 확인 가능합니다.\npackage com.mongodb.client.model;\r\n\r\n// ...\r\n\r\n/**\r\n * The options to apply to an operation that atomically finds a document and updates it.\r\n */\r\npublic class FindOneAndUpdateOptions {\r\n    private Bson projection;\r\n    private Bson sort;\r\n    private boolean upsert;\r\n    private ReturnDocument returnDocument = ReturnDocument.BEFORE;\r\n    private long maxTimeMS;\r\n    private Boolean bypassDocumentValidation;\r\n    private Collation collation;\r\n    private List<? extends Bson> arrayFilters;\r\n    private Bson hint;\r\n    private String hintString;\r\n    private BsonValue comment;\r\n    private Bson variables;\r\n    // ...\r\n}","index-연산#index 연산":"컬렉션의 특정 필드들에 대해 insdex 생성, 조회, 삭제 기능을 제공합니다.\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\nlistIndexes(ClientSession clientSession)\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)","createindexes-#createIndexes (...)":"참고\nMongoCollection.java\ncreateIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions)\n인자로 전달된 IndexModel 리스트에 대해 여러개의 인덱스들을 생성하는 역할을 하는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Create multiple indexes.\r\n     * ...\r\n     */\r\n    Publisher<String> createIndexes(ClientSession clientSession, List<IndexModel> indexes, CreateIndexOptions createIndexOptions);\r\n}\nCreateIndexOptions.java 의 내용은 아래와 같습니다.\nmaxTimeMS : 연산 수행시 최대 몇 ms 만큼을 기다릴지를 결정합니다.\ncommitQuorum : 커밋 시에 여러 브로커 들 간에 투표시 어떻게 할지에 대한 옵션입니다. Quorum은 분산 시스템에서 데이터 일관성과 가용성을 보장하기 위한 개념 중 하나입니다.\npackage com.mongodb.client.model;\r\n\r\n/**\r\n * The options to apply to the command when creating indexes.\r\n *\r\n * @mongodb.driver.manual reference/command/createIndexes Index options\r\n * @since 3.6\r\n */\r\npublic class CreateIndexOptions {\r\n    private long maxTimeMS;\r\n    private CreateIndexCommitQuorum commitQuorum;\r\n    // ...\r\n}","listindexes-#listIndexes (...)":"참고\nMongoCollection.java\nlistIndexes(ClientSession clientSession)\n컬렉션에 존재하는 모든 index 들을 조회하는 메서드입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Get all the indexes in this collection.\r\n     * ...\r\n     */\r\n    ListIndexesPublisher<Document> listIndexes(ClientSession clientSession);\r\n}","dropindex-#dropIndex (...)":"참고\nMongoCollection.java\ndropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions)\n컬렉션에서 indexName 에 해당하는 인덱스를 DROP 하는 역할의 메서드 입니다.\npackage com.mongodb.client;\r\n// ...\r\n@ThreadSafe\r\npublic interface MongoCollection<TDocument> {\r\n    /** \r\n     * Drops the index given its name.\r\n     * ...\r\n     */\r\n    Publisher<Void> dropIndex(ClientSession clientSession, String indexName, DropIndexOptions dropIndexOptions);\r\n}\nDropIndexOptions.java 의 내용은 아래와 같습니다.\npackage com.mongodb.client.model;\r\n// ...\r\n\r\n/**\r\n * The options to apply to the command when dropping indexes.\r\n */\r\npublic class DropIndexOptions {\r\n    private long maxTimeMS;\r\n    // ...\r\n}"}},"/spring-data-mongodb-reactive/transactional":{"title":"Transactional","data":{"transactional#@Transactional":""}},"/spring-data-r2dbc/spring-data-r2dbc":{"title":"Spring Data R2dbc","data":{"spring-data-r2dbc#Spring Data R2DBC":""}},"/spring-data-mongodb-reactive/spring-data-object-mapping-and-creation":{"title":"Spring Data Object Mapping and Creation","data":{"spring-data-reactive-의-객채생성-방식과-매핑방식#Spring Data Reactive 의 객채생성 방식과 매핑방식":"","intro#intro":"아래의 ReactiveMongoTemplate 을 Bean 으로 설정하는 코드를 보면, MongoConverter 와 ReactiveMongoDatabaseFactory 를 주입받아서 ReactiveMongoTemplate 객체를 생성한다는 사실을 알 수 있습니다.\n@Configuration\r\npublic class MongoReactiveConfiguration{\r\n    @Value(\"${spring.data.mongodb.uri}\")\r\n    private String mongoUri;\r\n    \r\n    @Bean\r\n    public MongoClient reactiveMongoClient() {\r\n        return MongoClients.create(mongoUri);\r\n    }\r\n    \r\n    @Bean\r\n    public SimpleReactiveMongoDataFactory reactiveMongoDatabaseFactory(\r\n        MongoProperties properties, MongoClient mongoClient\r\n    ){\r\n        Spring database = properties.getMongoClientDatabase();\r\n        return new SimpleReactiveMongoDatabaseFactory(mongoClient, database);\r\n    }\r\n    \r\n    @Bean\r\n    public ReactiveMongoTransactionManager transactionManager(ReactiveMongoDatabaseFactory dbFactory) {\r\n        return new ReactiveMongoTransactionManager(dbFactory);\r\n    }\r\n    \r\n    @Bean\r\n    public MappingMongoConverter mappingMongoConverter(MongoMappingContext mongoMappingContext) {\r\n        return new MappingMongoConverter(mongoMappingContext);\r\n    }\r\n    \r\n    // 여기\r\n    @Bean\r\n    public ReactiveMongoTemplate reactiveMongoTemplate(\r\n        ReactiveMongoDatabaseFactory reactiveMongoDatabaseFactory,\r\n        MongoConverter mongoConverter\r\n    ) {\r\n        return new ReactiveMongoTemplate(reactiveMongoDatabaseFactory, mongoConverter);\r\n    }\r\n    \r\n    private String getDatabaseNameFromUri() {\r\n        return mongoUri.substring(mongoUri.lastIndexOf(\"/\") + 1);\r\n    }\r\n}\n이번 문서에서는 위의 코드에서 처럼 ReactiveMongoTemplate 객체를 만들기 위해 필요한 MongoConverter 를 알아봅니다. MongoConverter 는 객체를 BSON → Java 객체, Java 객체 → BSON 으로 변환해주는 역할을 수행합니다.","mongoconverter-mappingmongoconverter#MongoConverter, MappingMongoConverter":"MongoConverter 는 interface 이며 아래와 같이 선언되어 있습니다.\npackage org.springframework.data.mongodb.core.convert;\r\npublic interface MongoConverter extends EntityConverter<MongoPersistentEntity<?>, \r\n\t\t\t\t\t\t\t\t\t\tMongoPersistentProperty, Object, Bson>, \r\n\t\t\t\t\t\t\t\t\t\tMongoWriter<Object>,\r\n\t\t\t\t\t\t\t\t\t\tEntityReader<Object, Bson>, CodecRegistryProvider {\r\n\t// ... \r\n}\nMappingMongoConverter 는 대표적인 MongoConverter 타입의 구현체입니다.\npackage org.springframework.data.mongodb.core.convert;\r\n\r\n// ..\r\n\r\npublic class MappingMongoConverter extends AbstractMongoConverter\r\n\t\timplements ApplicationContextAware, EnvironmentCapable {\r\n    // ...\r\n}","mappingmongoconverter-의-매핑과정#MappingMongoConverter 의 매핑과정":"","customconverter#CustomConverter":"위의 그림에서 살펴봤듯, Spring Data Mongodb 는 Document 에 해당하는 객체를 생성시에 제일 먼저 CustomConverter 가 있는지를 살피고 CustomConverter 가 존재하면 이 CustomConverter 를 적용합니다.Converter 는 Read, Write 용도로 2개를 만들어두어야 합니다.아래는 그 예제입니다.","readingconverter#ReadingConverter":"@ReadingConverter\r\npublic class PersonDocumentReadingConverter implements Converter<Document, PersonDocument> {\r\n    @Override\r\n    public PersonDocument convert(Document source){\r\n        ObjectId id = source.getObjectId(\"_id\");\r\n        String name = source.getString(\"name\");\r\n        Integer age = source.getInteger(\"age\");\r\n        return new PersonDocument(id, name, age);\r\n    }\r\n}","writingconverter#WritingConverter":"@WritingConverter\r\npublic class PersonDocumentWritingConverter implements Converter<PersonDocument, Document> {\r\n    @Override\r\n    public Document convert(PersonDocument source){\r\n        Document document = new Document();\r\n        document.put(\"_id\", source.getId());\r\n        document.put(\"name\", source.getName());\r\n        document.put(\"age\", source.getAge());\r\n        return document;\r\n    }\r\n}","customconverter-등록-1#CustomConverter 등록 (1)":"위에서 생성한 ReadingConverter, WritingConverter 는 아래와 같이 등록 가능합니다.\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.core.convert.converter.Converter;\r\nimport org.springframework.data.mongodb.core.convert.MongoCustomConversions;\r\nimport org.springframework.data.mongodb.repository.config.EnableMongoRepositories;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\n\r\n@Configuration\r\n@EnableMongoRepositories\r\npublic class MongoConfig {\r\n\r\n    @Bean\r\n    public MongoCustomConversions mongoCustomConversions() {\r\n        List<Converter<?, ?>> converters = new ArrayList<>();\r\n        converters.add(new PersonDocumentReadingConverter());\r\n        converters.add(new PersonDocumentWritingConverter());\r\n        return new MongoCustomConversions(converters);\r\n    }\r\n}","customconverter-등록-2#CustomConverter 등록 (2)":"또는 아래와 같이 등록하는 것도 가능합니다.\n@Configuration\r\npublic class ReactiveMongoConfig extends AbstractMongoClientConfiguration{\r\n    @Override\r\n    protected String getDatabaseName(){\r\n        return \"helloworld\";\r\n    }\r\n    \r\n    @Override\r\n    protected void configureConverters(\r\n        MongoCustomConversions.MongoConverterConfigurationAdapter adapter\r\n    ){\r\n        adapter.registerConverter(new PersonDocumentReadingConverter());\r\n        adapter.registerConverter(new PersonDocumentWritingConverter());\r\n    }\r\n}","spring-data-object-mapping#Spring Data Object Mapping":"실제로는 아주 특수한 데이터 파싱이 필요한 것이 아닌 한, 사용자가 직접 CustomConverter 를 등록하지 않아도 되는 경우가 대부분입니다. 사용자 정의 CustomConverter 가 존재하지 않을 경우에는 Spring Data 에서 ObjectMapping 을 하게됩니다. 먼저 Object Creation 을 하기 위해 코딩컨벤션에 맞는 생성자가 맞는지를 찾고, 존재한다면 생성자를 통해 객체를 생성합니다. 만약 코딩컨벤션에 맞는 생성자가 존재하지 않는다면, Property Population 을 진행하는데, with- 접두어가 붙은 빌더 메서드를 사용해서 불변성이 유지된 객체를 생성할 수 있습니다.\nObject Creation\n코딩 컨벤션에 맞는 생성자가 있는지를 찾고, 존재한다면 코딩컨벤션에 맞는 생성자를 선택 후 객체를 생성\nProperty Population\nwith- 접두어가 붙은 빌더 메서드를 사용해서 불변성이 유지된 객체를 생성","object-creation#Object Creation":"일반적인 코딩 컨벤션에 맞는 생성자를 찾아서 객체를 생성하는 절차입니다.\n@PersistenceCreator 애노테이션을 갖는 static factory 메서드가 정확히 하나 존재할 경우 이 팩토리 메서드를 사용합니다.\n@PersistenceCreator 애노테이션을 갖는 constructor 가 있다면 이 constructor 를 사용합니다.\n인자가 없는 constructor 가 있을 경우 이 constructor 를 사용합니다.\nconstructor 가 하나만 존재한다면, 이 constructor 를 채택해서 사용합니다.","property-population#Property Population":"Spring Data MongoDB Reactive에서는 with 접두어를 가진 빌더 메서드를 사용하여 객체를 생성할 수 있습니다. with 접두어를 가진 메서드는 불변성을 유지하고 객체를 간단하게 생성하는 데에 사용됩니다.r2dbc 에서는 prorperty 가 mutable 해야만 proeprty 의 population 이 가능하지만, Spring Data Mongodb Reactive 에서는 with 메서드를 통해 불변 필드에도 객체생성이 가능 합니다.\nimport org.springframework.data.annotation.Id;\r\nimport org.springframework.data.mongodb.core.mapping.Document;\r\n\r\n@Document\r\npublic class Product {\r\n    \r\n    @Id\r\n    private String id;\r\n    \r\n    private String name;\r\n    private String description;\r\n\r\n    // 생성자는 private으로 선언하여 외부에서 직접 객체를 생성하지 못하도록 합니다.\r\n    private Product() {}\r\n\r\n    // with 메서드를 사용하여 객체를 생성하고 필드 값을 설정합니다.\r\n    // name, description 을 인자로 지정하고 with 구문과 함께 사용했다는 사실에 주목해주세요.\r\n    public static Product withNameAndDescription(String name, String description) {\r\n        Product product = new Product();\r\n        product.name = name;\r\n        product.description = description;\r\n        return product;\r\n    }\r\n\r\n    // Getter 메서드들은 필요에 따라 정의합니다.\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    public String getDescription() {\r\n        return description;\r\n    }\r\n}"}},"/spring-data-r2dbc/mysql-features":{"title":"Mysql Features","data":{"mysql-특징#MySQL 특징":"자세한 내용은 docs-mysql-essential을 참고해주시기 바랍니다."}},"/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{}},"/spring-data-redis-reactive/spring-data-redis-reactive":{"title":"Spring Data Redis Reactive","data":{"spring-data-redis-reactive#Spring Data Redis Reactive":""}},"/spring-data-redis-reactive/known-cache-strategies":{"title":"Known Cache Strategies","data":{"많이-알려진-캐시-전략들#많이 알려진 캐시 전략들":"Cache Aside\nfeat. Spring Cache Manager\nWrite Back\nfeat. 작업 대기열\nWirte Through\n캐싱과 IO 작업을 함께 처리"}},"/spring-data-redis-reactive/redis-data-structures":{"title":"Redis Data Structures","data":{"레디스-자료구조들#레디스 자료구조들":"String\nLIST\nSET\nSorted Set\nSortedSet\r\n정렬된 Set 자료구조입니다.\r\n잘 알려진 MergeSort 나 개선된 QuickSort 등을 통해 내부적으로 정렬을 수행하는데 보통 O(Nlog(M)) 또는 O(log(N)) 이 소요되는 경우가 많습니다.\r\n예를 들면, 주식 종목 검색이나 주식 종목 초성검색을 구현할 때 Sorted Set을 사용합니다.\r\n혹시라도 주식 종목검색, 초성검색 예제가 궁금하다면 여기를 참고하시면 될 것 같습니다.List, Set\r\nList 의 LPUSH, LPOP, RPUSH, RPOP 을 적절하게 활용해서 작업 대기열을 구성할 수도 있습니다. 요청의 고유값을 식별하기 위해서는 Set 에 요청 ID 를 기록해두는 방식을 사용합니다.\r\n최근 트렌드는 가급적 작업 대기열 등은 Kafka,Kafka Streams 또는 RabbitMQ를 사용하는 추세입니다. 하지만 팀내 인력상황, 마감기한 및 여러가지 운영 요소로 인해 큰 비용이 필요하지 않을 경우 간단하게 레디스 기반으로 작업 대기열을 구성하는 경우도 많습니다.\r\n이 경우, Redis 서버가 다운될 경우 작업 대기열의 데이터들 모두 유실될 수 있다는 점에 착안해서 예외 처리등을 명확히 해둬야 합니다.\nString\r\n특정 값을 저장하는 용도로 사용합니다. 단순 문자열을 저장할 수도 있겠지만 구분자(DELIMITER)를 기반으로 여러가지 요청 식별자를 조합해서 어떤 요청이 있었는지를 기반으로 조회가 가능하도록 저장하는 경우도 많습니다.","string-자료구조#String 자료구조":"단순한 문자열 데이터 형식\r\n주요 연산으로는 set, get 이 있습니다.\r\nset, get 은 시간복잡도가 각각 O(1) 입니다.","eg-set#e.g. set":"set coupon:1 \"Apple 50% Discount Event\"\r\nOK","eg-get#e.g. get":"get coupon:1\r\n\"Apple 50% Discount Event\"\n이렇게 생성한 자료구조는 del 명령어로 삭제 가능합니다.","list-자료구조#List 자료구조":"리스트와 같은 선형자료 구조\r\nLPUSH 로 리스트의 제일 왼쪽(head)에 데이터를 추가할 수도 있고 RPUSH 로 리스트의 제일 오른쪽(tail)에 데이터를 추가할 수 있습니다.","lrange#LRANGE":"redis.io/commands - LRANGE\nLIST 내의 지정된 범위에 해당하는 요소들을 반환합니다.\n시간복잡도 O(S+N) 에 해당하는 연산입니다.\nS는 시작 Offset 의 Head/Tail 로부터의 거리 (distance)를 의미합니다.\nN은 지정된 Range 내에 속한 요소들의 개수를 의미합니다.\nLRANGE key start stop","lpush#LPUSH":"redis.io/commands - LPUSH\n리스트의 제일 왼쪽(head)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLPUSH key element [element ...]","rpush#RPUSH":"redis.io/commands - RPUSH\n리스트의 제일 오른쪽(tail)에 데이터를 추가하는 연산입니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nRPUSH key element [element ...]","lpop#LPOP":"redis.io/commands - LPOP\n리스트의 첫 번째 요소(Head)를 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nLPOP key [count]\n리스트의 첫 번째로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 제일 처음 요소로부터 3개의 요소를 POP 하게 됩니다.","rpop#RPOP":"redis.io/commands - RPOP\n리스트의 제일 마지막 요소(Tail)을 지운 후 리턴하는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nRPOP key [count]\n리스트의 마지막으로부터 몇 번째 요소를 지울지를 지정해서 지울 수도 있는데 이 경우 LPOP key 3 과 같은 명령을 내리면 맨끝에서 3개의 요소를 POP 하게 됩니다.","llen#LLEN":"redis.io/commands - LLEN\n현재 리스트의 사이즈를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nLLEN key","lpos#LPOS":"redis.io/commands - LPOS\n리스트 내에서 일치하는 요소를 찾는 연산입니다.\n시간복잡도 O(N) 에 해당하는 연산입니다. 만약 MAXLEN 을 명시해서 호출하면 상수 시간 내에 수행됩니다.\nLPOS key element [RANK rank] [COUNT num-matches] [MAXLEN len]","set-자료구조#SET 자료구조":"어느 언어에서든 제공되는 Set 개념에 해당하는 자료구조입니다.","smembers#SMEMBERS":"redis.io/commands - SMEMBERS\nkey 에 해당하는 Set 에 저장된 모든 요소들을 반환합니다.\n시간복잡도 O(N) 에 해당하는 연산입니다.\nSMEMBERS key","sadd#SADD":"redis.io/commands - SADD\nkey 에 해당하는 Set 에 요소를 추가합니다. 이때 요소 하나만 지정할 수도 있고 요소 여러개를 지정해서 여러개의 요소를 한번에 추가할 수 도 있습니다.\n요소 하나를 추가할 때는 시간복잡도 O(1) 에 해당하는 연산입니다. 만약 요소 K 개를 하나의 명령어로 추가할 경우에는 O(K) 의 시간복잡도를 가집니다.\nSADD key member [member ...]","sismember#SISMEMBER":"redis.io/commands - SISMEMBER\nkey 에 해당하는 Set 에 member 에 해당하는 요소가 존재하는지 검사합니다. 존재한다면 1을, 존재하지 않는다면 0 을 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSISMEMBER key member","scard#SCARD":"redis.io/commands - SCARD\nkey 에 해당하는 Set의 사이즈(Cardinality, 요소의 갯수)를 리턴합니다.\n시간복잡도 O(1) 에 해당하는 연산입니다.\nSCARD key","srem#SREM":"redis.io/commands - SREM\nkey 에 해당하는 Set 내에서 인자값으로 전달받은 member를 삭제하는 연산입니다. 지우고자 하는 요소가 여러개라면 지루려는 요소들을 모두 인자값으로 전달해주면 됩니다.\n지워야하는 요소수가 K개일 경우 시간복잡도 O(K) 가 소요되는 연산입니다.\nSREM key member [member ...]","sorted-set#Sorted Set":"스코어를 기반으로 순서를 지정해서 정렬된 상태로 저장하는 문자열 컬렉션입니다.\r\nSet 자료구조이므로 중복을 허용하지 않습니다.","zrange#ZRANGE":"redis.io/commands - ZRANGE\nkey 에 해당하는 SortedSet 에서 cli 에 명시한 Range 에 해당하는 요소들을 리턴하는 연산입니다.\nO(log(N)+M) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미하며, M 은 반환된 요소 수를 의미합니다.\nZRANGE key start stop [BYSCORE | BYLEX] [REV] [LIMIT offset count]\r\n[WITHSCORES]","zadd#ZADD":"redis.io/commands - ZADD\nkey 에 해당하는 SortedSet 에 score 와 함께 요소들을 저장합니다. score 를 기반으로 정렬되며, score가 같은 요소는 문자열 정렬을 통해 오름차순 정렬되어 저장됩니다.\nO(log(N)) 의 시간복잡도가 소요됩니다. N 은 정렬된 집합의 요소 수를 의미합니다.\nZADD key [NX | XX] [GT | LT] [CH] [INCR] score member [score member\r\n...]\ne.g. redis> ZADD myzset 1 \"one\"\ne.g. redis> ZADD myzset 2 \"two\" 3 \"three\"","zcard#ZCARD":"redis.io/commands - ZCARD\nkey 에 해당하는 SortedSet 의 사이즈(Cardinality, 요소의 개수)를 리턴합니다.\nO(1) 의 시간복잡도가 소요됩니다.\nZCARD key","zpopmin#ZPOPMIN":"redis.io/commands - ZPOPMIN\nkey 에 해당하는 SortedSet 에서 score 가 가장 낮은 순으로 요소들 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMIN key [count]","zpopmax#ZPOPMAX":"redis.io/commands - ZPOPMAX\nkey 에 해당하는 SortedSet 에서 score 가 가장 높은 요소들을 제거한 후 제거한 요소들을 리턴합니다.\nO(log(N)*M) 의 시간복잡도가 소요됩니다.\nZPOPMAX key [count]"}}}